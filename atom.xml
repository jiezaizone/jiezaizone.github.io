<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术分享</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-27T02:15:35.290Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mandy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生产java.io.IOException Too many open files排查过程和解决方案</title>
    <link href="http://yoursite.com/2020/03/26/technique-sharing/2020/%E7%94%9F%E4%BA%A7java-io-IOException-Too-many-open-files%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2020/03/26/technique-sharing/2020/生产java-io-IOException-Too-many-open-files排查过程和解决方案/</id>
    <published>2020-03-26T09:05:47.000Z</published>
    <updated>2020-03-27T02:15:35.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>2020-03-23 08:10:07生产突然系统异常。<br>在系统重新之后恢复暂时恢复使用。一个比较诡异的错误，经过一番排查，最终才定位到问题代码，错误如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-03-20 08:10:07.039 [http-nio-8050-Acceptor-0] ERROR org.apache.tomcat.util.net.Acceptor - Socket accept failed</span><br><span class="line">java.io.IOException: Too many open files</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:446)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:70)</span><br><span class="line">at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:95)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、第一波排查"><a href="#二、第一波排查" class="headerlink" title="二、第一波排查"></a>二、第一波排查</h2><h3 id="1、问题持续时间"><a href="#1、问题持续时间" class="headerlink" title="1、问题持续时间"></a>1、问题持续时间</h3><p>8:10 - 8：25</p><h3 id="2、错误日志"><a href="#2、错误日志" class="headerlink" title="2、错误日志"></a>2、错误日志</h3><p>第一次出现错误是在</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">2020-03-20 08:10:07.039 ITGC [http-nio-8050-Acceptor-0] ERROR org.apache.tomcat.util.net.Acceptor - Socket accept failed</span></span><br><span class="line"><span class="xml">java.io.IOException: Too many open files</span></span><br></pre></td></tr></table></figure><p><img src="/images/20200323100419479.png" alt=""></p><h3 id="3、tcp连接数"><a href="#3、tcp连接数" class="headerlink" title="3、tcp连接数"></a>3、tcp连接数</h3><p>8:10:07的时候tcp连接数也是不多的，在200左右非常小，已经过了访问高峰</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">netstat -nat|grep -i "8050"|wc -l</span></span><br><span class="line"></span><br><span class="line"><span class="xml">2020-03-20 08:10:05</span></span><br><span class="line"><span class="xml">169</span></span><br><span class="line"><span class="xml">2020-03-20 08:10:07</span></span><br><span class="line"><span class="xml">177</span></span><br><span class="line"><span class="xml">2020-03-20 08:10:09</span></span><br><span class="line"><span class="xml">184</span></span><br><span class="line"><span class="xml">2020-03-20 08:10:11</span></span><br><span class="line"><span class="xml">188</span></span><br><span class="line"><span class="xml">2020-03-20 08:10:13</span></span><br><span class="line"><span class="xml">199</span></span><br></pre></td></tr></table></figure><h3 id="4、句柄打开数"><a href="#4、句柄打开数" class="headerlink" title="4、句柄打开数"></a>4、句柄打开数</h3><p> 对于打开的句柄发现大量未成功释放的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看进程打开的资源情况</span><br><span class="line">ls -l /proc/13544/fd/</span><br><span class="line">发现有大量tmpip.db未释放</span><br><span class="line">查看进程打开的tmpip.db 的数量</span><br><span class="line">ls -l /proc/13544/fd/ | grep tmpip.db |wc -l</span><br><span class="line">ls -l /proc/13544/fd/ | grep tmpip.db</span><br></pre></td></tr></table></figure><p>  <img src="/images/20200323094839824.png" alt=""><br>附上：<br>查看进程打卡的各个资源数量排序前八位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p 13544 |awk <span class="string">'&#123;print $9&#125;'</span>| sort|uniq -c |sort -nr | head -n 8</span><br></pre></td></tr></table></figure><h3 id="5、-分析"><a href="#5、-分析" class="headerlink" title="5、 分析"></a>5、 分析</h3><p>目前除了重启应用解决外，具体原因还未确认</p><p>1、当时的打卡人数每分钟不超过20人。</p><p>2、对于tcp连接是有记录实时日志的，连接数不到200。</p><p>3、对于当前打开文件数量是没有记录的。13544是进程pid，可以 ps -ef |grep java 查看或者直接 jps 查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ls -l /proc/13544/fd/  | wc -l</span><br></pre></td></tr></table></figure><p>4、Linux的文件句柄数设置是正常的。ulimit –n 是65534<br>5、根据上面步骤4，看得出有大量未释放的。</p><h3 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h3><p>因为持续了很多天没有发布重启过应用，在累计几周的情况下。应用突然崩溃。</p><p>1、打开的文件数没有做日志记录。在文件打开关闭有问题上面不排除有异常，因为lsof查看到每天有打开/tmpip.db文件但是一直未正确关闭，导致累计。</p><p>2、属于累计达到一定量之后崩溃的系统，那么在jvm上面也不排除有堆栈异常导致。</p><p>3、其他异常也正在排查</p><h2 id="三、第二波排查"><a href="#三、第二波排查" class="headerlink" title="三、第二波排查"></a>三、第二波排查</h2><h3 id="1、分析"><a href="#1、分析" class="headerlink" title="1、分析"></a>1、分析</h3><p>根据以上结论进行第二波：<br>首先针对最多未释放的资源tmpip.db进行排查，因为代码里面日志记录代码有使用该文件。每次打卡都会插入日志，日志里面记录ip地址解析对应的中文地址会使用 tmpip.db，接着进行排查。</p><p>查看每个用户允许打开的最大文件数  ulimit -a 或者 ulimit -n 查看<br>open files                      (-n) 65534 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">65534</span><br><span class="line">[root@CN07ATT01NGX01V ~]<span class="comment">#  ulimit -a</span></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 14996</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65534  </span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 14996</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line">open files       (-n) 65534</span><br></pre></td></tr></table></figure><p>查看系统允许打开的最大文件数 cat /proc/sys/fs/file-max</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@CN07ATT01NGX01V ~]<span class="comment"># cat /proc/sys/fs/file-max</span></span><br><span class="line">379184</span><br><span class="line">[root@CN07ATT01NGX01V ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>基于这个问题是日积月累之后突然爆发的，于是对比中午打卡和下午打卡人数和未释放的文件句柄数对比，发现基本是能对应的上的。</p><p>截止2020-03-20 19:24分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">中午打卡日志数量 334条</span><br><span class="line">下午打卡日志数量 530条</span><br><span class="line">中午打卡后</span><br><span class="line">[root@CN07ATT01NGX01V ~]<span class="comment"># ls -l /proc/13544/fd/ | wc -l</span></span><br><span class="line">835</span><br><span class="line">下午打卡后</span><br><span class="line">[root@CN07ATT01NGX01V ~]<span class="comment"># ls -l /proc/13544/fd/ | wc -l</span></span><br><span class="line">1368</span><br></pre></td></tr></table></figure><p>相差1368-835=533</p><p>可见，未释放的资源几乎是和打卡日志相同数量递增的，<br>接着从今天出现问题前的最后一次启动，到今天出现问题时候启动时间段内，把日志做了一次查询统计：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(1) from t_log <span class="built_in">where</span>  create_time&gt;<span class="string">"2020-03-03 21:29:00"</span> and create_time&lt;=<span class="string">"2020-03-20 08:10:07"</span>  order by create_time desc</span><br></pre></td></tr></table></figure><p><img src="/images/20200323094542768.png" alt=""></p><p>如上图，启动后一共产生打卡日志64001条。</p><p>每个用户允许打开的最大文件数65534</p><p>差额为65534-64001 =1533个文件打开数。</p><h3 id="2、结论"><a href="#2、结论" class="headerlink" title="2、结论"></a>2、结论</h3><p>因此结论一时正确的，附上具体结论内容：</p><p>[root@CN07ATT01NGX01V ~]# ls -l /proc/13544/fd</p><p>/tmpip.db的资源占用未及时释放导致系统的文件句柄数量越来越大。在今天超出。报异常</p><p>java.io.IOException: Too many open files</p><h3 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h3><p>1、日志方法记录ip的时候调用了AddressUtil的getCityInfo(String ip)<br>根据传入去得到对应的中文地址，内部逻辑使用了tmpip.db。因此针对这部分代码进行核查。看是否有未释放，果然对于dbsearch使用之后是没有释放的，于是添加dbSearch.close方法进行关闭资源。<br><img src="/images/20200323102106440.png" alt=""><br>2、在代码修改前，我们先在测试系统也还原到了这个问题，添加释放方法之后，资源释放问题得以解决！</p><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p>java.io.IOException: Too many open files问题常用命令<a href="https://blog.csdn.net/liyuguanguan/article/details/90716709" target="_blank" rel="noopener">https://blog.csdn.net/liyuguanguan/article/details/90716709</a><br>对于高并发的产生：java.io.IOException: Too many open files(打开文件句柄过多问题)<br><a href="https://my.oschina.net/czpdjx/blog/2980869" target="_blank" rel="noopener">https://my.oschina.net/czpdjx/blog/2980869</a><br>java.io.IOException: Too many open files问题<br><a href="https://blog.csdn.net/liyuguanguan/article/details/90716709" target="_blank" rel="noopener">https://blog.csdn.net/liyuguanguan/article/details/90716709</a><br>linux进程数和句柄数<br><a href="https://blog.csdn.net/Poetic_Vienna/article/details/87621371?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/Poetic_Vienna/article/details/87621371?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;2020-03-23 08:10:07生产突然系统异常。&lt;br&gt;在系统重新之后恢复暂时恢复使用。一个比较诡异的错误，经过一番排查，最终才定位到问题代码，错误如下：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2020-03-20 08:10:07.039 [http-nio-8050-Acceptor-0] ERROR org.apache.tomcat.util.net.Acceptor - Socket accept failed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.io.IOException: Too many open files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:446)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.apache.tomcat.util.net.NioEndpoint.serverSocketAccept(NioEndpoint.java:70)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.apache.tomcat.util.net.Acceptor.run(Acceptor.java:95)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.lang.Thread.run(Thread.java:748)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>web系统后端接口压测报告V1.0</title>
    <link href="http://yoursite.com/2020/03/26/technique-sharing/2020/web%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E5%8E%8B%E6%B5%8B%E6%8A%A5%E5%91%8AV1-0/"/>
    <id>http://yoursite.com/2020/03/26/technique-sharing/2020/web系统后端接口压测报告V1-0/</id>
    <published>2020-03-26T09:04:47.000Z</published>
    <updated>2020-03-27T02:15:35.275Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、测试目的"><a href="#一、测试目的" class="headerlink" title="一、测试目的"></a>一、测试目的</h3><p>针对uat环境的用户并发量和系统瓶颈，都是未知的。<br>本轮压力测试，抽取部分代表性查询接口，主要是为了测试后台系统UAT环境主要接口吞吐量和响应时间，初步找出系统的瓶颈。</p><h3 id="二、测试内容"><a href="#二、测试内容" class="headerlink" title="二、测试内容"></a>二、测试内容</h3><p>压测接口清单</p><ul><li>api/nonmetalPla/list（pla(post)）    </li><li>api/warehouse/searchCarType    （查询基础数据(post)    ）</li><li>api/dict/findDictByParentCode    （根据父类编码查询下级字典(post)    ）</li><li>压测数据库查询m_dict数据    （jdbc连接    ）</li></ul><h3 id="三、测试环境"><a href="#三、测试环境" class="headerlink" title="三、测试环境"></a>三、测试环境</h3><table><thead><tr><th>环境</th><th>机器型号</th><th>CPU</th><th>操作系统</th><th>内存</th><th align="right">磁盘</th></tr></thead><tbody><tr><td>应用服务器</td><td>linux虚拟机</td><td>CPUIntel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz<br>4个单核四线程</td><td>CentOS Linux release 7.5.1804 (Core) 单机</td><td>total：8G ，可用内存： free+buffers/cached = 2.3G</td><td align="right">tatal：26G used：15G</td></tr><tr><td>压测机器</td><td>宏碁4750</td><td>单个双核四线程</td><td>win10 单机</td><td>8G</td><td align="right">total:8G used:3G</td></tr></tbody></table><a id="more"></a><h3 id="四、测试方法"><a href="#四、测试方法" class="headerlink" title="四、测试方法"></a>四、测试方法</h3><h4 id="4-1、压测工具和指标"><a href="#4-1、压测工具和指标" class="headerlink" title="4.1、压测工具和指标"></a>4.1、压测工具和指标</h4><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>压测工具</td><td>apache-jmeter-5.1.1（单台win环境）</td></tr><tr><td>压测性能相关参数</td><td>协议: http <br>方法: get/post<br>并发数 、总请求数、吞吐率(TPS)、响应时间、错误率 <br></td></tr><tr><td>#### 4.2、测试时间</td><td></td></tr><tr><td>第一轮压测：</td><td></td></tr><tr><td>测试时间：9:00-12:00（工作时间） ，内网环境压测（<strong>VPN内网，非完全内网</strong>）</td><td></td></tr><tr><td>针对每个接口分别执行并发数10、30、90、270并发数执行120秒</td><td></td></tr><tr><td>第二轮压测：</td><td></td></tr><tr><td>测试时间：7:50-09:30（工作时间） ，内网环境压测（<strong>VPN内网，非完全内网</strong>）</td><td></td></tr><tr><td>针对每个接口分别执行并发数10、30、90、270并发数执行120秒</td><td></td></tr><tr><td>第三轮压测：</td><td></td></tr><tr><td>测试时间：09:00-09:30（工作时间） ，内网环境压测（<strong>VPN内网，非完全内网</strong>）</td><td></td></tr><tr><td>针对pla接口30并发数执行120秒</td><td></td></tr></tbody></table><h4 id="五、统计指标"><a href="#五、统计指标" class="headerlink" title="五、统计指标"></a>五、统计指标</h4><p>进行压力测试，并对产生的每秒TPS，响应时间（min，ave，max）及错误率进行统计</p><h3 id="六、测试结果"><a href="#六、测试结果" class="headerlink" title="六、测试结果"></a>六、测试结果</h3><h4 id="6-1、第一轮压测"><a href="#6-1、第一轮压测" class="headerlink" title="6.1、第一轮压测"></a>6.1、第一轮压测</h4><p>时间：9:00-12:00（工作时间）</p><h5 id="6-1-1、聚合报告"><a href="#6-1-1、聚合报告" class="headerlink" title="6.1.1、聚合报告"></a>6.1.1、聚合报告</h5><table>   <tr>      <td>接口名称</td>      <td>数据量</td>      <td>并发数</td>      <td>持续时间</td>      <td>samples</td>      <td>average</td>      <td>min</td>      <td>max</td>      <td>median</td>      <td>90%Line</td>      <td>95%Line</td>      <td>99%Line</td>      <td>error%</td>      <td>tps(s)</td>      <td>received(kb/s)</td>      <td>sent(kb/s)</td>   </tr>   <tr>      <td>pla(post)</td>      <td>limit 10</td>      <td></td>      <td>120s</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>10</td>      <td></td>      <td>5113</td>      <td>233</td>      <td>73</td>      <td>2458</td>      <td>191</td>      <td>345</td>      <td>408</td>      <td>827</td>      <td>0</td>      <td>42.41921434</td>      <td>1672.45209</td>      <td>21.91383241</td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>30</td>      <td></td>      <td>5323</td>      <td>673</td>      <td>146</td>      <td>8692</td>      <td>543</td>      <td>1196</td>      <td>1561</td>      <td>2619</td>      <td>0</td>      <td>43.96775313</td>      <td>1733.505954</td>      <td>22.71380996</td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>90</td>      <td></td>      <td>6224</td>      <td>1737</td>      <td>161</td>      <td>26447</td>      <td>1262</td>      <td>3238</td>      <td>4445</td>      <td>8283</td>      <td>0</td>      <td>49.34982556</td>      <td>1945.703621</td>      <td>25.49419699</td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>270</td>      <td></td>      <td>7586</td>      <td>4298</td>      <td>155</td>      <td>44290</td>      <td>3359</td>      <td>7611</td>      <td>9445</td>      <td>15606</td>      <td>0</td>      <td>59.22213375</td>      <td>2334.936724</td>      <td>30.59424683</td>   </tr>   <tr>      <td>查询基础数据(post)</td>      <td>limit 10</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>10</td>      <td></td>      <td>2602</td>      <td>459</td>      <td>113</td>      <td>3458</td>      <td>393</td>      <td>692</td>      <td>937</td>      <td>1496</td>      <td>0</td>      <td>21.5274388</td>      <td>1078.600366</td>      <td>11.28929163</td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>30</td>      <td></td>      <td>4456</td>      <td>805</td>      <td>105</td>      <td>7980</td>      <td>670</td>      <td>1369</td>      <td>1712</td>      <td>2686</td>      <td>0</td>      <td>36.9694355</td>      <td>1852.298689</td>      <td>19.38729186</td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>90</td>      <td></td>      <td>5044</td>      <td>2150</td>      <td>172</td>      <td>11822</td>      <td>1781</td>      <td>3441</td>      <td>4277</td>      <td>6622</td>      <td>0</td>      <td>41.092654</td>      <td>2058.886432</td>      <td>21.54956562</td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>270</td>      <td></td>      <td>6504</td>      <td>5022</td>      <td>154</td>      <td>79084</td>      <td>3997</td>      <td>8100</td>      <td>10222</td>      <td>17749</td>      <td>0</td>      <td>51.1437356</td>      <td>2562.480956</td>      <td>26.82049416</td>   </tr>   <tr>      <td>根据父类编码查询下级字典(post)</td>      <td>limit 10</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>10</td>      <td></td>      <td>652</td>      <td>1842</td>      <td>225</td>      <td>12681</td>      <td>1505</td>      <td>2617</td>      <td>5084</td>      <td>6542</td>      <td>0</td>      <td>5.201643464</td>      <td>3.682313378</td>      <td>2.722735251</td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>30</td>      <td></td>      <td>1942</td>      <td>1861</td>      <td>267</td>      <td>11447</td>      <td>1489</td>      <td>3467</td>      <td>4896</td>      <td>6968</td>      <td>0</td>      <td>15.58337346</td>      <td>10.10484372</td>      <td>8.156922043</td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>90</td>      <td></td>      <td>5464</td>      <td>1986</td>      <td>284</td>      <td>23215</td>      <td>1604</td>      <td>2840</td>      <td>5219</td>      <td>6941</td>      <td>0</td>      <td>43.72669217</td>      <td>28.97468862</td>      <td>22.88819043</td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>270</td>      <td></td>      <td>16931</td>      <td>1921</td>      <td>72</td>      <td>14632</td>      <td>1505</td>      <td>3356</td>      <td>5021</td>      <td>6597</td>      <td>1.07</td>      <td>131.6268411</td>      <td>88.65045632</td>      <td>68.13092412</td>   </tr>   <tr>      <td>jdbc连接</td>      <td>limit 10</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>10</td>      <td></td>      <td>17390</td>      <td>66</td>      <td>10</td>      <td>13343</td>      <td>40</td>      <td>116</td>      <td>179</td>      <td>312</td>      <td>0</td>      <td>145.2</td>      <td>145.46</td>      <td>0</td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>30</td>      <td></td>      <td>18909</td>      <td>181</td>      <td>10</td>      <td>8165</td>      <td>118</td>      <td>351</td>      <td>474</td>      <td>845</td>      <td>0</td>      <td>157.5</td>      <td>157.78</td>      <td>0</td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>90</td>      <td></td>      <td>15052</td>      <td>709</td>      <td>13</td>      <td>12010</td>      <td>538</td>      <td>1106</td>      <td>1566</td>      <td>6648</td>      <td>0.48</td>      <td>125.1</td>      <td>124.78</td>      <td>0</td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>270</td>      <td></td>      <td>19391</td>      <td>1681</td>      <td>13</td>      <td>10848</td>      <td>1517</td>      <td>2593</td>      <td>3232</td>      <td>7707</td>      <td>0</td>      <td>158.1647635</td>      <td>158.47</td>      <td>0</td>   </tr></table><h5 id="6-1-2、接口压测实况图（90并发）"><a href="#6-1-2、接口压测实况图（90并发）" class="headerlink" title="6.1.2、接口压测实况图（90并发）"></a>6.1.2、接口压测实况图（90并发）</h5><p>下面抽取并发量为90的情况下各个测试接口的资源情况，分别是内存和cpu状况图、响应时间、tps<br><img src="/images/20191113234912948.png" alt=""><br><img src="/images/20191113234957571.png" alt=""></p><p>一、api/nonmetalPla/list((post)）</p><p><img src="/images/20191113235056332.png" alt=""><br><img src="/images/20191113235109271.png" alt=""><br><img src="/images/20191113235117777.png" alt=""><br>二、/api/warehouse/searchCarType （查询基础数据(post) ）<br><img src="/images/20191113235151972.png" alt=""><br><img src="/images/20191113235157418.png" alt=""><br><img src="/images/20191113235210655.png" alt=""><br>三、/ api/dict/findDictByParentCode （根据父类编码查询下级字典(post) ）<br><img src="/images/20191113235239301.png" alt=""><br><img src="/images/2019111323524764.png" alt=""><br><img src="/images/20191113235258683.png" alt=""><br>四、压测数据库查询m_dict数据 （jdbc连接 ）<br><img src="/images/20191113235443992.png" alt=""><br><img src="/images/20191113235327335.png" alt=""><br><img src="/images/20191113235344162.png" alt=""></p><h5 id="6-1-3、第一轮压测分析"><a href="#6-1-3、第一轮压测分析" class="headerlink" title="6.1.3、第一轮压测分析"></a>6.1.3、第一轮压测分析</h5><ul><li>带宽、内存、内存、磁盘等指标在网页查看一直表现的比较正常，在命令行直接进去服务器查看，cpu有超过100%的几次状况。</li><li>并发数在90以内时，接口响应时间基本能保证在2s内</li><li>普通数据库查询接口tps有提升空间，pla接口在10-270的并发下均能保持40tps以上</li><li>warehouse查询(post)    接口相比pla接口仍较慢，可做进一步优化，考虑字段过多，sql查询方面的问题</li><li>根据父类编码查询下级字典(post)接口耗时非常严重，需要比较优先优化，考虑索引和sql方面的问题</li><li>数据库压测tps只有120-150左右，需要进一步提高，考虑服务器性能方面和mysql配置问题，在非工作时间有尝试压测</li><li>对于接口耗时较长的情况，目前引入了redis，但是目前用的地方很少，redis几乎闲置，接口可以考虑结合使用redis</li></ul><p> 一次压测数据不一定是准确的，有主要以下几点</p><ul><li>服务器网络变化</li><li>服务器性能改变</li><li>压测主机网络变化</li><li>DB数据量的变化</li><li>压测过程中部分请求 error / 超时影响 </li></ul><h4 id="6-2、第二轮压测"><a href="#6-2、第二轮压测" class="headerlink" title="6.2、第二轮压测"></a>6.2、第二轮压测</h4><p>压测时间：07:50-9:30（工作时间）</p><h5 id="6-2-1、聚合报告"><a href="#6-2-1、聚合报告" class="headerlink" title="6.2.1、聚合报告"></a>6.2.1、聚合报告</h5><table>   <tr>      <td>接口名称</td>      <td>数据量</td>      <td>并发数</td>      <td>持续时间</td>      <td></td>      <td>samples</td>      <td>average</td>      <td>min</td>      <td>max</td>      <td>median</td>      <td>90%Line</td>      <td>95%Line</td>      <td>99%Line</td>      <td>error%</td>      <td>tps(s)</td>      <td>received(kb/s)</td>      <td>sent(kb/s)</td>   </tr>   <tr>      <td>pla(post)</td>      <td>limit 10</td>      <td></td>      <td>120s</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>10</td>      <td></td>      <td>TOTAL</td>      <td>4038</td>      <td>296</td>      <td>95</td>      <td>9299</td>      <td>233</td>      <td>496</td>      <td>630</td>      <td>934</td>      <td>0</td>      <td>33.49841965</td>      <td>1330.286362</td>      <td>17.30533593</td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>30</td>      <td></td>      <td>TOTAL</td>      <td>5134</td>      <td>698</td>      <td>76</td>      <td>7882</td>      <td>602</td>      <td>921</td>      <td>1107</td>      <td>3601</td>      <td>0</td>      <td>42.68835175</td>      <td>1695.236156</td>      <td>22.05286921</td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>90</td>      <td></td>      <td>TOTAL</td>      <td>5830</td>      <td>1873</td>      <td>157</td>      <td>12518</td>      <td>1717</td>      <td>2293</td>      <td>3515</td>      <td>5551</td>      <td>0</td>      <td>47.52472019</td>      <td>1887.297604</td>      <td>24.55134471</td>   </tr>   <tr>      <td>api/nonmetalPla/list</td>      <td></td>      <td>270</td>      <td></td>      <td>TOTAL</td>      <td>5130</td>      <td>6483</td>      <td>459</td>      <td>26515</td>      <td>5727</td>      <td>10125</td>      <td>11911</td>      <td>16345</td>      <td>0</td>      <td>40.1323664</td>      <td>1593.733086</td>      <td>20.73244319</td>   </tr>   <tr>      <td>basedata(post)</td>      <td>limit 10</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>10</td>      <td></td>      <td>TOTAL</td>      <td>4272</td>      <td>451</td>      <td>94</td>      <td>17898</td>      <td>426</td>      <td>615</td>      <td>676</td>      <td>853</td>      <td>0.002340824</td>      <td>22.09544695</td>      <td>2040.372722</td>      <td>11.56003959</td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>30</td>      <td></td>      <td>TOTAL</td>      <td>3028</td>      <td>1186</td>      <td>187</td>      <td>4492</td>      <td>1120</td>      <td>1586</td>      <td>1807</td>      <td>2567</td>      <td>0</td>      <td>25.12883924</td>      <td>2325.840943</td>      <td>13.17791667</td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>90</td>      <td></td>      <td>TOTAL</td>      <td>2146</td>      <td>5096</td>      <td>264</td>      <td>37961</td>      <td>3563</td>      <td>10678</td>      <td>14950</td>      <td>24020</td>      <td>0</td>      <td>16.60528026</td>      <td>1536.928958</td>      <td>8.708042481</td>   </tr>   <tr>      <td>/api/warehouse/searchCarType</td>      <td></td>      <td>270</td>      <td></td>      <td>TOTAL</td>      <td>2916</td>      <td>11779</td>      <td>257</td>      <td>55320</td>      <td>10512</td>      <td>17029</td>      <td>20018</td>      <td>27637</td>      <td>0</td>      <td>21.09649694</td>      <td>1952.620886</td>      <td>11.06329966</td>   </tr>   <tr>      <td>根据父类编码查询下级字典(post)</td>      <td>limit 10</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>10</td>      <td></td>      <td>TOTAL</td>      <td>31344</td>      <td>37</td>      <td>19</td>      <td>3256</td>      <td>28</td>      <td>37</td>      <td>56</td>      <td>245</td>      <td>0</td>      <td>261.1586499</td>      <td>392.5030881</td>      <td>136.7002308</td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>30</td>      <td></td>      <td>TOTAL</td>      <td>69339</td>      <td>51</td>      <td>21</td>      <td>7120</td>      <td>42</td>      <td>58</td>      <td>132</td>      <td>215</td>      <td>0</td>      <td>577.6083969</td>      <td>868.1048074</td>      <td>302.3418952</td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>90</td>      <td></td>      <td>TOTAL</td>      <td>87335</td>      <td>122</td>      <td>22</td>      <td>14538</td>      <td>94</td>      <td>219</td>      <td>274</td>      <td>500</td>      <td>0</td>      <td>727.2886254</td>      <td>1093.063666</td>      <td>380.6901398</td>   </tr>   <tr>      <td>/api/dict/findDictByParentCode</td>      <td></td>      <td>270</td>      <td></td>      <td>TOTAL</td>      <td>94655</td>      <td>339</td>      <td>22</td>      <td>6125</td>      <td>296</td>      <td>451</td>      <td>496</td>      <td>1331</td>      <td>0</td>      <td>786.713432</td>      <td>1182.374973</td>      <td>411.7953121</td>   </tr>   <tr>      <td>jdbc连接</td>      <td>limit 10</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>10</td>      <td></td>      <td>查询</td>      <td>43653</td>      <td>24</td>      <td>9</td>      <td>4549</td>      <td>18</td>      <td>30</td>      <td>44</td>      <td>139</td>      <td>0</td>      <td>363.6689299</td>      <td>364.3792208</td>      <td>0</td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>30</td>      <td></td>      <td>查询</td>      <td>19069</td>      <td>187</td>      <td>20</td>      <td>22843</td>      <td>83</td>      <td>341</td>      <td>521</td>      <td>981</td>      <td>0</td>      <td>158.7694101</td>      <td>159.0795066</td>      <td>0</td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>90</td>      <td></td>      <td>查询</td>      <td>31774</td>      <td>333</td>      <td>10</td>      <td>9448</td>      <td>231</td>      <td>576</td>      <td>805</td>      <td>1814</td>      <td>0</td>      <td>264.096682</td>      <td>264.6124958</td>      <td>0</td>   </tr>   <tr>      <td>压测数据库查询m_dict数据</td>      <td></td>      <td>270</td>      <td></td>      <td>查询</td>      <td>27057</td>      <td>1196</td>      <td>26</td>      <td>15632</td>      <td>902</td>      <td>2004</td>      <td>2398</td>      <td>4520</td>      <td>0</td>      <td>222.8252366</td>      <td>223.2604421</td>      <td>0</td>   </tr></table><h5 id="6-2-2、接口压测实况图（90并发）"><a href="#6-2-2、接口压测实况图（90并发）" class="headerlink" title="6.2.2、接口压测实况图（90并发）"></a>6.2.2、接口压测实况图（90并发）</h5><p>下面抽取并发量为90的情况下各个测试接口的资源情况，分别是内存和cpu状况图、响应时间、tps<br><img src="/images/20191115175636405.png" alt=""><br><img src="/images/20191115175648288.png" alt=""><br>一、api/nonmetalPla/list((post)）<br><img src="/images/20191115163809271.png" alt=""><br><img src="/images/20191115163817864.png" alt=""><br><img src="/images/20191115163831910.png" alt=""><br>二、/api/warehouse/searchCarType （查询基础数据(post) ）<br><img src="/images/20191115163900384.png" alt=""><br><img src="/images/20191115163917977.png" alt=""><br><img src="/images/20191115163926648.png" alt=""><br>三、/ api/dict/findDictByParentCode （根据父类编码查询下级字典(post) ）<br><img src="/images/20191115163953431.png" alt=""><br><img src="/images/20191115164005365.png" alt=""><br><img src="/images/20191115164016844.png" alt=""><br>四、压测数据库查询m_dict数据 （jdbc连接 ）<br><img src="/images/20191115163601826.png" alt=""><br><img src="/images/2019111516372689.png" alt=""><br><img src="/images/20191115163741562.png" alt=""></p><h5 id="6-2-3、第二轮压测分析"><a href="#6-2-3、第二轮压测分析" class="headerlink" title="6.2.3、第二轮压测分析"></a>6.2.3、第二轮压测分析</h5><ul><li>二轮压测发现pla接口和warehouse接口都是比较相近的tps结果数据，</li><li>数据字典接口翻了将近10倍，其数据也是不多的，但是结果差别如此的大。</li><li>压测数据库查询tps也翻了一倍，<br>根据以上几个现象，首先能确定的是虽然内网环境，但是走vpn的情况下，网络存在不稳定，当前数据库仅该后台系统在使用，说明数据传输的耗时主要受网络方面的影响大。<br>结合第一轮压测出现的一些问题，两轮下来，需要第三轮的测试，<br>第三轮主要是判断数据量大小的网络传输，是否明细影响压测结果<h4 id="6-3、第三轮压测"><a href="#6-3、第三轮压测" class="headerlink" title="6.3、第三轮压测"></a>6.3、第三轮压测</h4><h5 id="6-3-1、聚合报告"><a href="#6-3-1、聚合报告" class="headerlink" title="6.3.1、聚合报告"></a>6.3.1、聚合报告</h5><table> <tr>    <td>接口名称</td>    <td>数据量</td>    <td>并发数</td>    <td>持续时间</td>    <td>samples</td>    <td>average</td>    <td>min</td>    <td>max</td>    <td>median</td>    <td>90%Line</td>    <td>95%Line</td>    <td>99%Line</td>    <td>error%</td>    <td>tps(s)</td>    <td>received(kb/s)</td>    <td>sent(kb/s)</td> </tr> <tr>    <td>pla(post)</td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td>    <td></td> </tr> <tr>    <td>api/nonmetalPla/list</td>    <td>10</td>    <td>30</td>    <td>120s</td>    <td>5207</td>    <td>689</td>    <td>74</td>    <td>5609</td>    <td>608</td>    <td>1054</td>    <td>1356</td>    <td>2167</td>    <td>0</td>    <td>43.3</td>    <td>1717.91</td>    <td>22.35</td> </tr> <tr>    <td>api/nonmetalPla/list</td>    <td>1</td>    <td>30</td>    <td>120s</td>    <td>17408</td>    <td>205</td>    <td>48</td>    <td>5707</td>    <td>113</td>    <td>317</td>    <td>472</td>    <td>2120</td>    <td>0</td>    <td>144.8</td>    <td>629.9</td>    <td>74.65</td> </tr> <tr>    <td>api/nonmetalPla/list</td>    <td>0</td>    <td>30</td>    <td>120s</td>    <td>47035</td>    <td>75</td>    <td>24</td>    <td>21001</td>    <td>52</td>    <td>120</td>    <td>187</td>    <td>321</td>    <td>0</td>    <td>391.8</td>    <td>171.41</td>    <td>208.88</td> </tr></li></ul></table><p><img src="/images/20191115170304747.png" alt=""></p><h5 id="6-3-2、接口压测实况图（30并发）"><a href="#6-3-2、接口压测实况图（30并发）" class="headerlink" title="6.3.2、接口压测实况图（30并发）"></a>6.3.2、接口压测实况图（30并发）</h5><p><strong>下面抽取并发量为30压测</strong>的情况下各个测试接口的资源情况，分别是内存和cpu状况图、响应时间、tps<br>压测接口：api/nonmetalPla/list((post)<br>并发量：30<br><img src="/images/20191118083953456.png" alt=""><br><img src="/images/20191118084007563.png" alt=""></p><p>一、查询0条<br><img src="/images/20191115164934968.png" alt=""><br><img src="/images/20191115165635519.png" alt=""><br><img src="/images/20191115164911940.png" alt=""><br><img src="/images/20191115164900320.png" alt=""><br>二、查询1条<br><img src="/images/20191115170052928.png" alt=""><br><img src="/images/20191115170109834.png" alt=""><br><img src="/images/20191115170118752.png" alt=""><br>三、查询10条<br><img src="/images/20191115165616709.png" alt=""><br><img src="/images/20191115165743751.png" alt=""><br><img src="/images/20191115165752503.png" alt=""></p><h5 id="6-3-3、第三轮压测分析"><a href="#6-3-3、第三轮压测分析" class="headerlink" title="6.3.3、第三轮压测分析"></a>6.3.3、第三轮压测分析</h5><ul><li>数据量大小的网络传输影响非常大</li><li>数据量越小传输越快，当前VPN的内网受VPN或内网网速影响较大</li><li>接口的数据量有必要缩减，会有明细的tps提升</li></ul><h3 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h3><p>结合压测一、二、三分析，得到以下一些结论和建议：</p><ul><li><p>主要问题在网络环境，网络的提升对压测tps的影响非常大。</p></li><li><p>工作时间的早上刚上班期间，服务器和带宽都是比较宽裕的状况，这几个目标接口的压测结果tps都提高了很多，vpn连接的内网压测对数据的准确性仍然有一定的影响</p></li><li><p>在网络正常的情况下，接口tps仍然只能在50左右。</p></li><li><p>服务器性能不是非常稳定，虚拟linux多个地方共用主机导致有波动，也影响接口性能，单独部署到一台服务器会事比较好的选择</p></li><li><p>数据库压测tps120-150，200+均出现，从二轮压测可以看出，除了网络之外，数据库tps仍可以继续提高，本地机器能达到1000tps，可以向着这个目标接近。</p></li><li><p>所有接口不需要的字段尽量缩减不返回到前端，可做进一步优化，考虑字段过多，sql查询方面的问题</p></li><li><p>对于接口耗时较长的情况，目前引入了redis，但是目前用的地方很少，redis几乎闲置，接口可以考虑结合使用redis</p></li><li><p>考虑下一轮的压测中直接在机房另一台linux/win下专门压测，并使用命令行方式直接导出报告的方式节省工作量</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;一、测试目的&quot;&gt;&lt;a href=&quot;#一、测试目的&quot; class=&quot;headerlink&quot; title=&quot;一、测试目的&quot;&gt;&lt;/a&gt;一、测试目的&lt;/h3&gt;&lt;p&gt;针对uat环境的用户并发量和系统瓶颈，都是未知的。&lt;br&gt;本轮压力测试，抽取部分代表性查询接口，主要是为了测试后台系统UAT环境主要接口吞吐量和响应时间，初步找出系统的瓶颈。&lt;/p&gt;
&lt;h3 id=&quot;二、测试内容&quot;&gt;&lt;a href=&quot;#二、测试内容&quot; class=&quot;headerlink&quot; title=&quot;二、测试内容&quot;&gt;&lt;/a&gt;二、测试内容&lt;/h3&gt;&lt;p&gt;压测接口清单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;api/nonmetalPla/list（pla(post)）    &lt;/li&gt;
&lt;li&gt;api/warehouse/searchCarType    （查询基础数据(post)    ）&lt;/li&gt;
&lt;li&gt;api/dict/findDictByParentCode    （根据父类编码查询下级字典(post)    ）&lt;/li&gt;
&lt;li&gt;压测数据库查询m_dict数据    （jdbc连接    ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;三、测试环境&quot;&gt;&lt;a href=&quot;#三、测试环境&quot; class=&quot;headerlink&quot; title=&quot;三、测试环境&quot;&gt;&lt;/a&gt;三、测试环境&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;环境&lt;/th&gt;
&lt;th&gt;机器型号&lt;/th&gt;
&lt;th&gt;CPU&lt;/th&gt;
&lt;th&gt;操作系统&lt;/th&gt;
&lt;th&gt;内存&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;磁盘&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;应用服务器&lt;/td&gt;
&lt;td&gt;linux虚拟机&lt;/td&gt;
&lt;td&gt;CPUIntel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz&lt;br&gt;4个单核四线程&lt;/td&gt;
&lt;td&gt;CentOS Linux release 7.5.1804 (Core) 单机&lt;/td&gt;
&lt;td&gt;total：8G ，可用内存： free+buffers/cached = 2.3G&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;tatal：26G used：15G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;压测机器&lt;/td&gt;
&lt;td&gt;宏碁4750&lt;/td&gt;
&lt;td&gt;单个双核四线程&lt;/td&gt;
&lt;td&gt;win10 单机&lt;/td&gt;
&lt;td&gt;8G&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;total:8G used:3G&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jenkins构建项目简易教程</title>
    <link href="http://yoursite.com/2020/03/26/technique-sharing/2020/Jenkins%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/26/technique-sharing/2020/Jenkins构建项目简易教程/</id>
    <published>2020-03-26T09:03:22.000Z</published>
    <updated>2020-03-27T02:15:35.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><ul><li>需要使用自动化构建工具jenkins构建项目到应用服务器，项目分前端后端。</li><li>前端使用npm构建的vue项目，后端是使用maven的springboot项目。</li></ul><p>除了安装jenkins外，还需要额外安装tomcat、maven、jdk、git、npm。</p><p>附言：一年前我搭建时候也写过一篇，但是安装包比较零散，所以重新搭建构建系统的时候我才重新写了这篇。一年前的帖子也可以参考看看<br>超全git+tomcat+jenkins实现自动化构建部署教程<a href="https://blog.csdn.net/u011456337/article/details/89303647" target="_blank" rel="noopener">https://blog.csdn.net/u011456337/article/details/89303647</a></p><a id="more"></a><h2 id="二、安装包"><a href="#二、安装包" class="headerlink" title="二、安装包"></a>二、安装包</h2><p>步骤三四需要用的安装包较多，单独去找如果怕麻烦的话可以直接用百度云里面的这些，包含jenkins、maven、maven配置文件、jdk、git。<br><img src="/images/20191202105632194.png" alt=""><br>链接：<a href="https://pan.baidu.com/s/1wH5bx3QO4SZRi7fVqFolsA" target="_blank" rel="noopener">https://pan.baidu.com/s/1wH5bx3QO4SZRi7fVqFolsA</a><br>提取码：7z2t </p><h2 id="三、安装java环境"><a href="#三、安装java环境" class="headerlink" title="三、安装java环境"></a>三、安装java环境</h2><p><strong>下面的工具已安装的可以跳过</strong></p><p>当前软件下载位置：/opt/soft/,进入该位置</p><h3 id="3-1、安装jdk"><a href="#3-1、安装jdk" class="headerlink" title="3.1、安装jdk"></a>3.1、安装jdk</h3><p>安装包使用百度云下载的或者进入下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz</span><br><span class="line"><span class="comment"># 移动位置</span></span><br><span class="line">mv jdk1.8.0_144/ /usr/<span class="built_in">local</span>/java</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 文件末尾添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile   </span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h3 id="3-2、安装tomcat"><a href="#3-2、安装tomcat" class="headerlink" title="3.2、安装tomcat"></a>3.2、安装tomcat</h3><p>使用百度云安装包或者直接<br>wget <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.39/bin/apache-tomcat-8.5.39.tar.gz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.39/bin/apache-tomcat-8.5.39.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf apache-tomcat-8.5.39.tar.gz</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/tomcat</span><br><span class="line"><span class="comment"># 移动</span></span><br><span class="line">mv apache-tomcat-8.5.39 /usr/<span class="built_in">local</span>/tomcat/</span><br></pre></td></tr></table></figure><p>可选操作-修改tomcat端口并启动测试能够访问</p><p><img src="/images/20191202115009288.png" alt=""></p><h3 id="3-3、安装maven"><a href="#3-3、安装maven" class="headerlink" title="3.3、安装maven"></a>3.3、安装maven</h3><p>使用百度云解压包或者下载maven安装包<br>wget <a href="http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf apache-maven-3.5.4-bin.tar.gz </span><br><span class="line"><span class="comment"># 可以解压到/usr/local/maven,这里我的直接用了soft下面的安装包略过了该步</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="comment"># 文件末尾添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME=/opt/soft/maven/apache-maven-3.5.4</span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$MAVEN_HOME</span>/bin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使配置生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile      </span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">mvn -v</span><br><span class="line"><span class="comment"># 默认的仓库比较慢，可以配置阿里云和华为云的中央仓库，直接看步骤二下载的setting.xml，可以直接粘贴进去或者参考</span></span><br></pre></td></tr></table></figure><h3 id="3-4、安装git"><a href="#3-4、安装git" class="headerlink" title="3.4、安装git"></a>3.4、安装git</h3><p><strong>提示</strong>：安装git经常会遇到一些错误<br>使用百度云的解压包或者额外下载 <a href="https://www.kernel.org/pub/software/scm/git" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf git-2.9.5.tar.gz</span><br><span class="line"><span class="comment"># 进去解压后目录执行，</span></span><br><span class="line">./configure  --prefix=/usr/<span class="built_in">local</span>/git</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 前两步如果有遇到错，要么直接百度，要么就是缺少一些包，下面给出一些常见报错依赖度的环境</span></span><br><span class="line">yum install curl-devel</span><br><span class="line">yum install zlib</span><br><span class="line">yum install zlib-devel</span><br><span class="line">yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</span><br><span class="line">yum install curl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试是否安装成功</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h3 id="3-5、安装npm"><a href="#3-5、安装npm" class="headerlink" title="3.5、安装npm"></a>3.5、安装npm</h3><p>进入jenkins插件中心安装nodejs，接着去系统设置→系统设置（全局设置）&gt;找到npm，配置如下<br>进入jenkins插件中心安装nodejs，接着去系统设置→系统设置（全局设置）&gt;找到npm，配置如下</p><p><img src="/images/20191204175909595.png" alt=""></p><h2 id="三、安装jenkins"><a href="#三、安装jenkins" class="headerlink" title="三、安装jenkins"></a>三、安装jenkins</h2><h3 id="3-1、安装jenkins"><a href="#3-1、安装jenkins" class="headerlink" title="3.1、安装jenkins"></a>3.1、安装jenkins</h3><p>3.1.1、版本选择：2.164.1。<br>3.1.2、下载各个版本地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/</a></p><p>3.1.3、安装方式：不用yum安装，使用tomcat容器部署jenkins，方便修改工作空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用百度云提供的war包或者自行下载</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;war-stable&#x2F;2.164.1&#x2F;jenkins.war</span><br><span class="line"># 移动war文件到tomcat下</span><br><span class="line">mv jenkins.war &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-8.5.49&#x2F;webapps</span><br></pre></td></tr></table></figure><p>3.1.4、启动：直接启动tomcat方式即可启动jenkins<br>3.1.5、验证是否成功，访问Jenkins，<a href="http://IP地址:8080/jenkins/" target="_blank" rel="noopener">http://IP地址:8080/jenkins/</a></p><h3 id="3-2、配置初始页"><a href="#3-2、配置初始页" class="headerlink" title="3.2、配置初始页"></a>3.2、配置初始页</h3><p>3.2.1、这里有一个临时密码需要输入，在/home/tomcat/.jenkins/secrets/initialAdminPassword里面<br><img src="/images/20191202143714163.png" alt=""><br>3.2.2、选择第二个，select plugin to install，这里其实不安装东西也没关系，进去主页面之后再去安装插件即可，确认<br><img src="/images/20191202143733163.png" alt=""><br> 3.2.3、创建用户名密码<img src="/images/20191202143858955.png" alt=""><br> 3.2.4、进入主页<br> <img src="/images/20191202144007199.png" alt=""></p><h3 id="3-3、插件、凭据、工具配置"><a href="#3-3、插件、凭据、工具配置" class="headerlink" title="3.3、插件、凭据、工具配置"></a>3.3、插件、凭据、工具配置</h3><p>1、插件安装：系统管理-&gt;插件管理&gt;搜索过滤插件-&gt;安装<br> 当前需要安装的插件有：</p><ul><li>Git</li><li>Git Parameter Plug-In</li><li>GitLab Plugin</li><li>Maven Integration plugin</li><li>Publish Over SSH</li></ul><p>2、凭据配置：选择凭据-&gt;系统-&gt;添加域，输入一个域名或者ip<br> <img src="/images/20191202145904197.png" alt=""><br> 点击添加一些凭据<br>     <img src="/images/20191202150035710.png" alt=""><br> 添加之后账户密码信息之后保存<br> <img src="/images/20191202150105566.png" alt=""><br> 3、ssh scp 配置<br>系统管理-&gt;系统设置 ssh server 配置：<br>如果用的是统一的key或者密码，则配置一次就可以了。<br>如果每个服务器密码都不一样，需要点击高级按钮，把<br>复选框 Use password authentication, or use a different key 勾选上就行了。</p><ul><li>Passphrase                服务器的密码</li><li>Path to key                  连接远程服务器密钥文件的路径</li><li>Key                             密钥文件的内容 </li><li>Name                         自定义服务器名</li><li>HostName                  服务器IP外网地址</li><li>UserName                  服务器用户名</li><li>Remote Directory     传输文件的目录</li></ul><p><img src="/images/20191202154305682.png" alt=""><br>4、配置本地maven、jdk、git<br>maven，jdk，git、这些尽量使用本地配置<br>如下图<br><img src="/images/20191202150756711.png" alt=""><br><img src="/images/20191202150837714.png" alt=""></p><h2 id="四、新建maven项目"><a href="#四、新建maven项目" class="headerlink" title="四、新建maven项目"></a>四、新建maven项目</h2><p>4.1、新建选择新建一个maven项目，如果没有安装Maven Integration plugin插件，则不会出现该item。</p><p><img src="/images/20191202152253689.png" alt=""><br>4.2、配置多条件分支参数<br><img src="/images/20191202152418545.png" alt=""><br>4.3、选择git项目，选择凭据，指定分支（为空时代表any）    填写上面配置的分支参数myBranch（如果Repository URL报http错，则是http不被git支持，需要进去git目录 yum install curl-devel 安装后重新执行上面步骤3.4中的git两条编译配置命令）。</p><p><img src="/images/20191202152646954.png" alt=""><br>4.4、构建前删除源文件和编译文件<br><img src="/images/20191212171944159.png" alt="">选择pom.xml<br><img src="/images/20191202153134627.png" alt=""><br>4.5、后置操作步骤选下拉框中的【Send files or execute commands over SSH】接着进行配置。</p><ul><li>Source files     项目构建后的目录</li><li>Remove prefix    去前缀</li><li>Remote directoty 发布的目录</li><li>Exec command     发布完执行的命令<br><img src="/images/20191202153239497.png" alt=""></li></ul><p>4.6、确认构建后启动脚本是否有误</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml">echo "构建完成"</span></span><br><span class="line"><span class="xml">echo "停止java进程"</span></span><br><span class="line"></span><br><span class="line"><span class="xml">ps -aux | grep java|grep soso-admin| awk '&#123;print $2&#125;' | while read pid</span></span><br><span class="line"><span class="xml">do</span></span><br><span class="line"><span class="xml">    echo "正在杀死进程，pid=$pid"</span></span><br><span class="line"><span class="xml">    kill -9 $pid</span></span><br><span class="line"><span class="xml">    echo "kill result: $?"</span></span><br><span class="line"><span class="xml">done</span></span><br><span class="line"></span><br><span class="line"><span class="xml">cd /opt/project/java/soso</span></span><br><span class="line"></span><br><span class="line"><span class="xml">ls -lht</span></span><br><span class="line"></span><br><span class="line"><span class="xml">nohup java -jar soso-admin.jar -spring.profiles.active=sit &gt; nohup.out 2&gt;&amp;1 &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">echo "启动中"</span></span><br></pre></td></tr></table></figure><p><img src="/images/20191202154922464.png" alt=""><br>4.7、尝试构建<br>选择build with parameter<br><img src="/images/20191202155049290.png" alt=""><br>选择需要构建的分支之后构建进度如下，接着点击进度条进入构建日志详情查看具体信息<br><img src="/images/20191202155103139.png" alt=""><br>如下图所示则构建成功，直接进去看应用启动日志或者直接访问应用的url地址<br><img src="/images/20191202162336106.png" alt=""></p><h2 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h2><ul><li>ssh发送文件到远程服务器报错，一般是因为设置路径不对，可能是远程服务器设置路径，或者发送位置不正确，一般有下面两种配置错误<br>1、系统管理-&gt;系统设置-&gt;Publish over SSH-&gt;Remote Directory    &gt;设置默认远程服务器根目录 /<br>2、构建配置中Send build artifacts over SSH-&gt;Remote directory ，为文件发送远程目标目录（相对路径）<br>结合1、2，最终发送文件位置是【根目录+相对路径】</li></ul><p>可以直接在远程服务器执行如：find / -name  soso-admin.jar查找文件位置，解决路径错误</p><ul><li>遇到一些git问题可以根据具体的报错百度</li><li>遇到jenkins的自己的页面没有下拉选项应该少安装了插件，需要去安装插件。</li><li>修改jenkins工作空间workspace需要自行百度<h2 id="六、构建npm前端项目简述"><a href="#六、构建npm前端项目简述" class="headerlink" title="六、构建npm前端项目简述"></a>六、构建npm前端项目简述</h2><h3 id="6-1-1、前端npm项目构建"><a href="#6-1-1、前端npm项目构建" class="headerlink" title="6.1.1、前端npm项目构建"></a>6.1.1、前端npm项目构建</h3>1、构建一个自由风格的项目<br>2、【源码管理】选择git版本和分支选择同前面maven的一致<br>3、接下来就不一样了，<br>4、【构建环境】选择 Provide Node &amp; npm bin/ folder to PATH<br><img src="/images/20191204173751542.png" alt=""><br>5、构建shell</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/jenkins/workspace/intelligence-web</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">rm -rf intelligence</span><br><span class="line">rm -rf intelligence-web</span><br><span class="line">rm -rf intelligence-web.tar.gz</span><br><span class="line">cnpm install</span><br><span class="line">npm run build</span><br><span class="line">mv intelligence intelligence-web</span><br><span class="line">tar -zcvf intelligence-web.tar.gz intelligence-web</span><br></pre></td></tr></table></figure><p>6、构建后文件发送到应用服务器<br><img src="/images/20191204174049871.png" alt=""></p><h2 id="七、克隆方式创建新项目"><a href="#七、克隆方式创建新项目" class="headerlink" title="七、克隆方式创建新项目"></a>七、克隆方式创建新项目</h2><p>选择构建自由风格的项目→copy from 已有项目-&gt;点击保存即可，接着按照自己需要修改版本git地址和脚本配置<br><img src="/images/20191204180530298.png" alt=""></p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><p>超全git+tomcat+jenkins实现自动化构建部署教程<a href="https://blog.csdn.net/u011456337/article/details/89303647" target="_blank" rel="noopener">https://blog.csdn.net/u011456337/article/details/89303647</a><br>Jenkins自动构建部署项目到远程服务器上<br><a href="https://blog.csdn.net/ming19951224/article/details/80958761" target="_blank" rel="noopener">https://blog.csdn.net/ming19951224/article/details/80958761</a><br>jenkins配置，一键打包,备份，部署多服务器，多环境启动<br><a href="https://blog.csdn.net/li740207611/article/details/84261430" target="_blank" rel="noopener">https://blog.csdn.net/li740207611/article/details/84261430</a><br>基于gitlab和jenkins的自动化部署实例<br><a href="https://blog.csdn.net/aaaaaab_/article/details/82012044" target="_blank" rel="noopener">https://blog.csdn.net/aaaaaab_/article/details/82012044</a><br>Jenkins自动化构建vue项目然后发布到远程Linux服务器<br><a href="https://www.cnblogs.com/djlsunshine/p/11059690.html" target="_blank" rel="noopener">https://www.cnblogs.com/djlsunshine/p/11059690.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需要使用自动化构建工具jenkins构建项目到应用服务器，项目分前端后端。&lt;/li&gt;
&lt;li&gt;前端使用npm构建的vue项目，后端是使用maven的springboot项目。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了安装jenkins外，还需要额外安装tomcat、maven、jdk、git、npm。&lt;/p&gt;
&lt;p&gt;附言：一年前我搭建时候也写过一篇，但是安装包比较零散，所以重新搭建构建系统的时候我才重新写了这篇。一年前的帖子也可以参考看看&lt;br&gt;超全git+tomcat+jenkins实现自动化构建部署教程&lt;a href=&quot;https://blog.csdn.net/u011456337/article/details/89303647&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u011456337/article/details/89303647&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Git开发者教程</title>
    <link href="http://yoursite.com/2020/03/26/technique-sharing/2020/Git%E5%BC%80%E5%8F%91%E8%80%85%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/26/technique-sharing/2020/Git开发者教程/</id>
    <published>2020-03-26T09:01:56.000Z</published>
    <updated>2020-03-27T02:15:35.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是git？"><a href="#一、什么是git？" class="headerlink" title="一、什么是git？"></a>一、什么是git？</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p> git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作也就是伟大的Linux创始人Linus创作。</p><h3 id="1-2、常见代码托管平台"><a href="#1-2、常见代码托管平台" class="headerlink" title="1.2、常见代码托管平台"></a>1.2、常见代码托管平台</h3><ul><li><p>全世界最大的代码托管网站: <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>。</p></li><li><p>国内较多用户使用的网站：<a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a>。</p></li><li><p>可以免费搭建自己的代码托管网站的 gitLab</p></li><li><p>版本控制工具还有cvs、svn</p><a id="more"></a><h3 id="1-2、对比svn"><a href="#1-2、对比svn" class="headerlink" title="1.2、对比svn"></a>1.2、对比svn</h3><p>简单列举一些和svn的比较：</p></li><li><p>svn是集中式版本控制系统，git是分布式版本控制系统</p></li><li><p>svn是直接与服务器进行交互，git是将文件存到本地然后再推送到服务器</p></li><li><p>svn必须在连网的情况下工作，git可以不连网开发</p></li><li><p>svn易发生冲突，git相对于svn不易发生冲突</p></li><li><p>svn适用于多项目并行开发，git适用于单项目开发</p></li><li><p>git内容完整性要优于svn，git内容存储使用的是SHA-1哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p></li><li><p>相比svn，git对分支的隔离是逻辑隔离而不是物理隔离，这意味着创建分支非常快速、存储分支不会占用过多磁盘空间</p></li></ul><hr><h2 id="二、git分支介绍"><a href="#二、git分支介绍" class="headerlink" title="二、git分支介绍"></a>二、git分支介绍</h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h3><ul><li><p>分支(branch)可以理解为是仓库(repository)的一种隔离视图。<br>分支的目的为了支持多人、多版本开发。</p></li><li><p>Git支持多分支开发，并鼓励使用本地多分支，这些分支之间是彼此完全独立的。</p></li><li><p>常见的分支操作包括：创建分支、切换分支、合并分支、删除分支。</p><h3 id="2-2、常见分支操作"><a href="#2-2、常见分支操作" class="headerlink" title="2.2、常见分支操作"></a>2.2、常见分支操作</h3></li></ul><p>2.2.1. 创建分支：给分支名取一个简短且有意义的名字。<br>2.2.2. 提交改动：填写有意义的commit message: what &amp; why，推荐的commit message格式为 <issue id>: <description> ，比如：512: 增加了对NFS的支持。<br>2.2.3. 发起合并请求：同时发起code review和讨论，不经过review的代码不允许合并进public branch。<br>2.2.4. 代码评审和讨论：</p><ul><li>审查代码是否满足功能、规范、测试结果、测试覆盖等要求。</li><li>审查合格才允许合并合进public branch，不合格的代码退回重新修改。</li><li>鼓励使用同行评审（Peer Review）而不是上下级评审，鼓励积极反馈、互动。</li><li>评审对事不对人，多建议，不批评，不指责。</li><li>评审过程对reviewer和代码提交者双方都是一个学习提升的过程。</li><li>部署：使用经过完整测试的分支来部署到生产环境，部署后发生问题需要回退时，用上一个版本进行回退。</li><li>合并回master分支。</li></ul><p>部署成功，没有问题后才合并到master分支。</p><h2 id="三、分支策略"><a href="#三、分支策略" class="headerlink" title="三、分支策略"></a>三、分支策略</h2><p>用git首先得了解项目需要采用哪一种分支策略。<br>目前主流的git工作流模式有<a href="https://www.jianshu.com/p/1889b0fe073b" target="_blank" rel="noopener">git flow、github flow、gitlab flow</a>，需要根据软件集成方式和团队规模和协作方式，调整自己团队的分支策略。<br>几种模型各有所长，下面简述一下</p><ul><li>git flow：出现时间最早，基于git的workflow的开山鼻祖，可以说给出了一个git flow的最佳实践，缺点是流程比较复杂，release branch和hotfix branch几乎没人使用，另外需要长期维护master和dev两个分支，在规模不大的场景下维护成本比较高</li><li>github flow：相当精简，只有master主干和feature branch这两种，结构相当清晰，缺点是master默认为当前上线的最新版本，在对于版本管理要求比较复杂的场景下灵活性不足</li><li>gitlab flow：出现的最晚，可以说集合了前两家的长处，既保证只有一个长期主干，结构清晰，同时也定义了不同场景下的branch，增强了灵活性。</li></ul><h3 id="3-1、git-flow简介"><a href="#3-1、git-flow简介" class="headerlink" title="3.1、git flow简介"></a>3.1、git flow简介</h3><p>大多数公司都基于<a href="(https://www.jianshu.com/p/1889b0fe073b)">git flow</a>的模式，并在此基础上做了调整。<br><img src="/images/20191119163946896.png" alt=""></p><h3 id="3-2、其他工作流模式"><a href="#3-2、其他工作流模式" class="headerlink" title="3.2、其他工作流模式"></a>3.2、其他工作流模式</h3><p>工作流模式每个公司的不一样，都可能在gitflow的基础上做了很大改动<br>下面列举三种基于gitflow的改造后模式。</p><h4 id="3-2-1、模式一"><a href="#3-2-1、模式一" class="headerlink" title="3.2.1、模式一"></a>3.2.1、模式一</h4><p>模式一简要描述：</p><ul><li>功能模块的同一个feature分支开发人员共同开发（也可额外创建自己的分支定期push到feature）</li><li>一个feature对应一个测试环境</li><li>功能分支sit测试完成后，直接到release版本</li><li>release版本验收成功之后发生产。</li><li>hotfixes直接基于master进行修改和上线。<br><img src="/images/2019111917451583.png" alt=""></li></ul><h4 id="3-2-2、模式二"><a href="#3-2-2、模式二" class="headerlink" title="3.2.2、模式二"></a>3.2.2、模式二</h4><p>每个开发者都有自己的分支，时不时地往dev分支上合并就可以了。跟模式一的区别在于，模式一的测试环境主要以feature为准，到测试基本完成后发布到develop的基本是小改动，小改动验收完成后直接develop到生产，而模式而强调每个人一个分支，测试主要以develop为准。</p><p>所以，团队合作的分支看起来就像这样：<br><img src="/images/20191120205011829.png" alt=""><br>对于多个业务模块并行开发的具体场景如下<br><img src="/images/20191121153605711.png" alt=""></p><h4 id="3-2-3、模式三"><a href="#3-2-3、模式三" class="headerlink" title="3.2.3、模式三"></a>3.2.3、模式三</h4><p>模式三和模式一、模式二很类似，主要区别在于不需要每个开发者创建分支，共同在一个feature分支上面去做开发。模式三和模式一的区别在于，模式一强调以feature分支作为开发和测试的分支，而模式一稳定版本后直接发布到release分支，而模式三强调所有修改以develop为测试基准，测试完成直接发布到master。</p><ul><li>开发【feature分支】：从develop拉新分支，命名feature/迭代版本号_功能说明，不可以从feature分支再拉新分支</li><li>测试【develop分支】：将feature分支合并到develop分支，再部署到测试环境</li><li>发布【master分支】：将develop测试后的稳定版本合并到master分支，打版本标签，再进行发布，未经测试的不稳定代码不可以合并到master</li><li>修复线上问题【hotfix分支】：从master分支拉新分支，命名hotfix/xxx，修复bug后合并到master分支，再将修复从master分支合并到develop分支<br><img src="/images/20191120214424390.png" alt=""></li></ul><h4 id="3-2-4、几种模式对比"><a href="#3-2-4、几种模式对比" class="headerlink" title="3.2.4、几种模式对比"></a>3.2.4、几种模式对比</h4><p>模式名称 | 本地分支 |  测试环境分支|预生产环境|线上分支|<br>|-|-|-|-|-|<br>|模式一 |feature/** | feature/** |release|master|<br>|模式二 | blob/john | develop |无|master|<br>|模式三 | feature/** | develop |无|master|</p><hr><h2 id="四、安装和运行"><a href="#四、安装和运行" class="headerlink" title="四、安装和运行"></a>四、安装和运行</h2><p>登录git官网: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载git for windows，安装后有3个程序：</p><ul><li>git bash （模拟linux终端）- git cmd (windows终端)</li><li>git gui (windows界面)</li></ul><p>推荐使用git bash，git cmd和git gui可以忽略。</p><p>在linux和mac上使用git和在windows上使用git bash一样，不再赘述。<br>现在主流的ide（比如intellij idea和eclipse) 都对git有非常好的支持。<br>推荐通过ide + git bash 方法来使用git。</p><h2 id="五、git开发操作流程"><a href="#五、git开发操作流程" class="headerlink" title="五、git开发操作流程"></a>五、git开发操作流程</h2><h3 id="5-1、基本操作概览"><a href="#5-1、基本操作概览" class="headerlink" title="5.1、基本操作概览"></a>5.1、基本操作概览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master创建新分支：</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment"># 创建并切换到 issues1234</span></span><br><span class="line">git checkout -b  issues1234</span><br><span class="line"><span class="comment"># 推送新分支到远程仓库</span></span><br><span class="line">git push origin issues1234</span><br><span class="line"><span class="comment"># 添加所有本地修改文件</span></span><br><span class="line">git add ..</span><br><span class="line"><span class="comment"># commit所有本地修改文件到本地仓库</span></span><br><span class="line">git commit -m <span class="string">"***"</span></span><br><span class="line"><span class="comment"># push到远程仓库</span></span><br><span class="line">git push origin issues1234</span><br></pre></td></tr></table></figure><p>如下两图，主要区别在于</p><ul><li>图一直接拉取git现有代码，</li><li>图二初始化之后关联远程空仓库<h3 id="5-2、操作流程步骤"><a href="#5-2、操作流程步骤" class="headerlink" title="5.2、操作流程步骤"></a>5.2、操作流程步骤</h3></li></ul><p>基本开发流程如：</p><ol><li>建立远程仓库</li><li>拉取远程仓库代码同步到本地仓库和workspace</li><li>创建分支</li><li>基于分支开发</li><li>提交开发代码并同步到仓库（提交前先pull远程代码，如果有冲突则需要比对并解决冲突）<br><img src="/images/20191120223308550.png" alt=""><br><img src="/images/2019112022483230.png" alt=""></li></ol><h2 id="六、常用命令"><a href="#六、常用命令" class="headerlink" title="六、常用命令"></a>六、常用命令</h2><p>常用命令比如：拉取、提交、添加、对比、提交、删除、创建分支、合并分支、merge、强制回退、还原、部分还原、查看历史，设置全局用户名密码、git免登陆、代码审查</p><h3 id="6-1、命令文档"><a href="#6-1、命令文档" class="headerlink" title="6.1、命令文档"></a>6.1、命令文档</h3><ul><li>git no deep shit:<br><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/</a></li><li>常用Git命令清单（阮一峰）: <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li><li>git操作规范(Miss_Ye): <a href="https://segmentfault.com/a/1190000014461898" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014461898</a></li><li>命令大全<br><a href="https://www.jianshu.com/p/31fa525d0853" target="_blank" rel="noopener">https://www.jianshu.com/p/31fa525d0853</a></li></ul><h3 id="6-2、git-help"><a href="#6-2、git-help" class="headerlink" title="6.2、git help"></a>6.2、git help</h3><p><img src="/images/20191121115435585.png" alt=""></p><h3 id="6-3、git常用命令速查表"><a href="#6-3、git常用命令速查表" class="headerlink" title="6.3、git常用命令速查表"></a>6.3、git常用命令速查表</h3><p><img src="/images/20191121115259366.png" alt=""><br>git：http和ssh的区别</p><h2 id="七、常见场景"><a href="#七、常见场景" class="headerlink" title="七、常见场景"></a>七、常见场景</h2><h3 id="7-1、在gitlab上新建一个项目（repository）"><a href="#7-1、在gitlab上新建一个项目（repository）" class="headerlink" title="7.1、在gitlab上新建一个项目（repository）"></a>7.1、在gitlab上新建一个项目（repository）</h3><p> 7.1.1、 操作步骤</p><ol><li>打开gitlab首页</li><li>点击new project按钮</li><li>进入blank project填写 项目名、项目描述（选填）、是否公开的项目</li><li>点击 create project。</li></ol><p>7.1.2、创建完成之后，</p><ol><li>进入新建项目的首页</li><li>找到clone 按钮</li><li>查看git 地址，分为http方式和ssh方式两个地址</li></ol><p>地址分为SSH和HTTP(S)两种方式如:</p><ul><li>http方式：<a href="https://github.com/lufei222/san-aitoubao.git" target="_blank" rel="noopener">https://github.com/lufei222/san-aitoubao.git</a></li><li>ssh方式：<a href="mailto:git@github.com">git@github.com</a>:lufei222/san-aitoubao.git</li></ul><p><strong>SSH和HTTP(S)两种方式的主要区别是：</strong></p><ul><li>SSH方式需要将本地的SSH public key添加到GitLab账号的setting中，比较安全。</li><li>HTTP(S)方式第一次push到GitLab时需要提供用户名和密码登陆，操作比较简单。<br><img src="/images/2019112108591345.png" alt=""><br><img src="/images/20191121090535256.png" alt=""><h3 id="7-2、远程gitlab项目clone到本地"><a href="#7-2、远程gitlab项目clone到本地" class="headerlink" title="7.2、远程gitlab项目clone到本地"></a>7.2、远程gitlab项目clone到本地</h3>7.2.1、设置git config的user.name 和 user.email :</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看git config</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Global的user.name和user.email</span></span><br><span class="line">git config --global user.name user_name</span><br><span class="line">git config --global user.email user_email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看git config确认</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><p>7.2.2、从gitLab上clone一个repository到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSH 方式</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo_git_url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP 方式</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repo_http_url&gt;</span><br></pre></td></tr></table></figure><h3 id="7-3、分支管理"><a href="#7-3、分支管理" class="headerlink" title="7.3、分支管理"></a>7.3、分支管理</h3><h4 id="7-3-1、本地创建、切换分支"><a href="#7-3-1、本地创建、切换分支" class="headerlink" title="7.3.1、本地创建、切换分支"></a>7.3.1、本地创建、切换分支</h4><p>从master分支创建dev分支并切换到dev分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment"># 基于master分支，创建并切换到dev分支</span></span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>其中，git checkout -b dev 等价于:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建dev分支</span></span><br><span class="line">git branch dev</span><br><span class="line"><span class="comment"># 切换到dev分支</span></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>查看本地当前的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地当前的分支，分支前面带“*”表示当前分支，剩下的分支表示本地有的分支。</span></span><br><span class="line">git branch</span><br><span class="line"><span class="comment"># 查看远程全部的分支，白色的表示本地有的，红色的表示本地没有，仅在远程存在。</span></span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="/images/20191121092151919.png" alt=""></p><h4 id="7-3-2、分支常见操作"><a href="#7-3-2、分支常见操作" class="headerlink" title="7.3.2、分支常见操作"></a>7.3.2、分支常见操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="7-4、提交本地代码修改到gitlab（开发日常）"><a href="#7-4、提交本地代码修改到gitlab（开发日常）" class="headerlink" title="7.4、提交本地代码修改到gitlab（开发日常）"></a>7.4、提交本地代码修改到gitlab（开发日常）</h3><h4 id="7-4-1、本地代码提交流程"><a href="#7-4-1、本地代码提交流程" class="headerlink" title="7.4.1、本地代码提交流程"></a>7.4.1、本地代码提交流程</h4><p>本地开发流程如下图步骤，中间可能涉及到文件对比、代码冲突合并解决见其他场景</p><ol><li>pull最新的远程代码</li><li>add本地修改的文件</li><li>commit到本地仓库</li><li>push到远程仓库</li></ol><p><img src="/images/20191121094814727.png" alt=""></p><h4 id="7-4-2、命令行方式提交"><a href="#7-4-2、命令行方式提交" class="headerlink" title="7.4.2、命令行方式提交"></a>7.4.2、命令行方式提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新working directory</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改动代码...此处省略2048个字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看working tree状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较改动前后，查看改动了什么 (用IDE来比较更加直观)</span></span><br><span class="line">git diff &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新建的文件到Git Stage中</span></span><br><span class="line">git add &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或添加全部新建的文件到Git Stage中</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交改动到local repository</span></span><br><span class="line">git commit -m <span class="string">"&lt;commit_message&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到remote repository，创建remote new branch，并设置upstream reference</span></span><br><span class="line">git push -u origin &lt;new_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果第一次push时不通过-u 来push新的branch，在git pull时会提示要先设置upstream reference</span></span><br><span class="line"><span class="comment"># 设置upstream reference</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#之后的push可以不需要再加-u参数：</span></span><br><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/20191121094107966.png" alt=""></p><h4 id="7-4-3、idea方式提交"><a href="#7-4-3、idea方式提交" class="headerlink" title="7.4.3、idea方式提交"></a>7.4.3、idea方式提交</h4><ol><li>确认当前所在分支</li><li>pull远程最新代码到本地</li><li>查看本地的local changes代码改动，和改动前做比对</li><li>选中要提交的代码，右键点击commit</li><li>进入commit的窗口，再次确认是否勾选刚刚勾选的文件</li><li>也可以在这个窗口中进行文件对比，比local changes中对比更方便</li><li>填写commit信息，尽量描述清楚本次修改点，以便bug修复跟踪和代码review或者回退</li><li>去除勾选的右边代码分析之类的操作，加快提交速度</li><li>下拉commit选项，选择commit and push，<strong>即可完成提交</strong>。（如果没有信心是否提交成功，或者只commit到本地了仓库了，那么可以去顶部菜单栏找到VCS–&gt;Git-&gt;Push。点击push即可查看本地仓库未推送的提交记录，并点击推送），也可以去gitlab的项目页面去查看最新提交记录）<br><img src="/images/20191121100923693.png" alt=""><br><img src="/images/2019112110101585.png" alt=""><br><img src="/images/20191121101906684.png" alt=""><h3 id="7-5、-增加-删除文件"><a href="#7-5、-增加-删除文件" class="headerlink" title="7.5、 增加/删除文件"></a>7.5、 增加/删除文件</h3></li><li>5.1、命令行方式<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure></li></ol><p>7.5.2、idea的方式</p><ul><li>直接常规操作复制到本项目即可，idea自动把文件添加到git的local changes中</li><li>删除同添加一样删除后在local changes中会变成灰色的文件</li></ul><p><img src="/images/2019112110344444.png" alt=""></p><h3 id="7-6、-本地新项目上传到git"><a href="#7-6、-本地新项目上传到git" class="headerlink" title="7.6、 本地新项目上传到git"></a>7.6、 本地新项目上传到git</h3><p>7.6.1、（先进入项目文件夹）通过命令 git init 把这个目录变成git可以管理的仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>7.6.2、把文件添加到版本库中，使用命令 git add .添加到暂存区里面去，不要忘记后面的小数点“.”，意为添加文件夹下的所有文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>7.6.3、用命令 git commit告诉Git，把文件提交到仓库。引号内为提交说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure><p>6.6.4、关联到远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 你的远程库地址</span><br><span class="line">如：</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;githubusername&#x2F;demo.git</span><br></pre></td></tr></table></figure><p>7.6.5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>7.6.6、把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>7.6.7、状态查询命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><hr><h3 id="7-7、-配置-gitignore忽略提交文件"><a href="#7-7、-配置-gitignore忽略提交文件" class="headerlink" title="7.7、 配置.gitignore忽略提交文件"></a>7.7、 配置.gitignore忽略提交文件</h3><p>在项目根目录下创建.gitignore文件。.gitignore 文件内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/.idea/</span><br><span class="line">/target/</span><br><span class="line">/<span class="built_in">log</span>/</span><br><span class="line">application-uat.yml</span><br><span class="line">!.mvn/wrapper/maven-wrapper.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">### STS ###</span></span><br><span class="line">.apt_generated</span><br><span class="line">.classpath</span><br><span class="line">.factorypath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">.springBeans</span><br><span class="line">.sts4-cache</span><br><span class="line">.lst</span><br><span class="line"><span class="comment">### IntelliJ IDEA ###</span></span><br><span class="line">.idea</span><br><span class="line">*.iws</span><br><span class="line">*.iml</span><br><span class="line">*.ipr</span><br><span class="line"></span><br><span class="line"><span class="comment">### NetBeans ###</span></span><br><span class="line">/nbproject/private/</span><br><span class="line">/build/</span><br><span class="line">/nbbuild/</span><br><span class="line">/dist/</span><br><span class="line">/nbdist/</span><br><span class="line">/.nb-gradle/</span><br></pre></td></tr></table></figure><p>在项目目录下执行该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update .gitignore&quot;</span><br></pre></td></tr></table></figure><h3 id="7-8、-reset-revert版本回退"><a href="#7-8、-reset-revert版本回退" class="headerlink" title="7.8、 reset/revert版本回退"></a>7.8、 reset/revert版本回退</h3><h4 id="7-8-1、reset-revert比对"><a href="#7-8-1、reset-revert比对" class="headerlink" title="7.8.1、reset/revert比对"></a>7.8.1、reset/revert比对</h4><p>假设有一次提交a文件前commit id 为 34719a7，提交的commit id为34719a8，接着又有人提交了b、c文件，提交的commit id为34719a9，如下表：<br>tag| commit id |  commit 的文件| 操作|<br>|-|-|-|-|<br>| | 34719a7|  |<br> || 34719a8| a.java |把数据库地址从192变成了127|<br> |head| 34719a9| b.java、c.java|b、c的查询db方法都改成查询redis，a地址变为localhost<br> 基于34719a9进行回退到34719a8</p><ul><li>revert：仅会把a文件回退到34719a8变更前的内容，其他文件不会变动，<br>即：34719a7提交后a文件=revert后的a文件，最终a的内容还是192。</li><li>reset：回退到那次commit id=34719a8提交后的样子，后面的b、c文件也全盘回退，即34719a8 commit后项目内容=reset 到 34719a8项目内容，最终b、c还是查询db，a数据库地址为127。</li></ul><p>如下表<br>操作|回退前commit id|回退版本commit id|操作前 | 操作后|<br>|:-|:-|:-|:-|:-|<br> | revert|34719a9| 34719a8|a为127，b、c连接redis |a变为192，b、c的不变，查询redis|<br> | reset|34719a9 |34719a8|a为127，b、c连接redis    |a变为127，b、c的变化，查询db方法</p><h4 id="7-8-2、版本回退"><a href="#7-8-2、版本回退" class="headerlink" title="7.8.2、版本回退"></a>7.8.2、版本回退</h4><p>对于本次变动的回退，一般情况建议使用revert，以防使用reset把其他开发人员提交的代码给回退了。</p><p>7.8.2.1、在本地改动后，在git add 前回退，撤销本地改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>推荐使用idea的revert功能，更加简单直观。<br>控制台-&gt; local changes -&gt; 右键 -&gt; revert</p><p>7.8.2.2、在本地改动后，在git push 前回退，这里直接用远程覆盖可以直接用<strong>reset</strong><br>用远程repository强制替换本地文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin&#x2F;&lt;branch&gt;</span><br></pre></td></tr></table></figure><p>推荐使用idea的reset功能，更加简单直观。<br>version control-&gt;log -&gt; 右键选择最后一次提交-&gt; Reset current branch to here -&gt; select “Hard”</p><p>7.8.2.3、在本地改动后，在git push后回退</p><ul><li><p>方法一：手工回退后，重新提交改动去覆盖remote branch。</p></li><li><p>方法二：使用idea的revert功能。<strong>（推荐）</strong><br>version control -&gt;log -&gt; 右键点击revert -&gt; 填写commit的message。</p></li><li><p>方法三：根据commit id 手动回退<br>方法三如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看git commit log，复制要回退的版本commit id</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br><span class="line"><span class="comment">#将本地回退到指定版本</span></span><br><span class="line">git reset --hard &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看working tree状态，此时本地落后于远程1个commit</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制用本地覆盖远程（危险操作！！）</span></span><br><span class="line">git push -f origin &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看working tree状态，此时本地和远程应该同步</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>推荐使用方法二</p></li></ul><p>方法三比较危险，不推荐使用；强烈建议通过protect branch来防止强制用本地覆盖远程分支。</p><h3 id="7-9、-查看文件修改历史"><a href="#7-9、-查看文件修改历史" class="headerlink" title="7.9、 查看文件修改历史"></a>7.9、 查看文件修改历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按树形结构显示</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列表显示</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单粗暴显示</span></span><br><span class="line">git <span class="built_in">log</span> [file]</span><br></pre></td></tr></table></figure><h3 id="7-10、文件对比与解决冲突"><a href="#7-10、文件对比与解决冲突" class="headerlink" title="7.10、文件对比与解决冲突"></a>7.10、文件对比与解决冲突</h3><h4 id="7-10-1、命令行文件对比"><a href="#7-10-1、命令行文件对比" class="headerlink" title="7.10.1、命令行文件对比"></a>7.10.1、命令行文件对比</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较改动前后，查看改动了什么 (用idea来比较更加直观)</span></span><br><span class="line">git diff &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"><span class="comment"># 显示出所有有差异的文件列表</span></span><br><span class="line">git diff branch1 branch2 --<span class="built_in">stat</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件的详细差异</span></span><br><span class="line">git diff branch1 branch2 具体文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示出所有有差异的文件的详细差异</span></span><br><span class="line">git diff branch1 branch2</span><br></pre></td></tr></table></figure><h4 id="7-10-2、idea中文件对比"><a href="#7-10-2、idea中文件对比" class="headerlink" title="7.10.2、idea中文件对比"></a>7.10.2、idea中文件对比</h4><p>如图可见，可以与历史版本或者其他分支的该文件进行对比，比命令行更加直观<br><img src="/images/20191121141708503.png" alt=""></p><h4 id="7-10-3、命令行解决文件冲突"><a href="#7-10-3、命令行解决文件冲突" class="headerlink" title="7.10.3、命令行解决文件冲突"></a>7.10.3、命令行解决文件冲突</h4><p>7.10.3.1、发生冲突的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>其中，git使用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记文件中自己和别人产生冲突的部分。</p><p>在&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======之间为自己的代码；<br>=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间为别人的代码。</p><p>如果保留自己的代码，将别人的代码删掉即可。</p><p>7.10.3.2、冲突解决后提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add ***</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"fix conflict"</span></span><br><span class="line"></span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><hr><h4 id="7-10-4、idea解决文件冲突"><a href="#7-10-4、idea解决文件冲突" class="headerlink" title="7.10.4、idea解决文件冲突"></a>7.10.4、idea解决文件冲突</h4><p>产生冲突的场景</p><ul><li><p>accept yours:代表以自己的为准；</p></li><li><p>accept theris:代表以更新下来的文件为准；</p></li><li><p>merge:代表手动合并</p></li><li><p>一般解决冲突我们都是选择merge</p></li></ul><p>将需要的内容点击：”&gt;&gt;”既可以合并内容到result中，不需要的内容点击“x”即可，合并完成后点击apply即可。</p><p>值得注意的是，最将所有的“x &gt;&gt;”符号都要处理完，不需要的点击“x”,需要的点击“&gt;&gt;”<br>最后，不论是什么场景下产生的冲突解决方法是一样的。<br><img src="/images/20191121141254421.png" alt=""><br><img src="/images/20191121141405593.png" alt=""></p><h3 id="7-11、合并分支"><a href="#7-11、合并分支" class="headerlink" title="7.11、合并分支"></a>7.11、合并分支</h3><h4 id="7-11-1、命令行合并"><a href="#7-11-1、命令行合并" class="headerlink" title="7.11.1、命令行合并"></a>7.11.1、命令行合并</h4><p>对于复杂的系统，我们可能要开好几个分支来开发，具体git合并操作如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、进入要合并的分支（如本地分支luo合并到develop，则进入develop目录）</span><br><span class="line">git checkout develop</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">2、使用merge合并luo分支到develop</span><br><span class="line">git merge luo</span><br><span class="line"></span><br><span class="line">3、查看合并之后的状态</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">4、有冲突的话，通过idea解决冲突，比命令行直观；</span><br><span class="line"></span><br><span class="line">5、解决冲突之后，将冲突文件提交暂存区</span><br><span class="line">git add 冲突文件</span><br><span class="line"></span><br><span class="line">6、提交merge之后的结果</span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line">如果不是使用git commit -m <span class="string">"备注"</span> ，那么git会自动将合并的结果作为备注，提交本地仓库；</span><br><span class="line"></span><br><span class="line">7、本地仓库代码提交远程仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>将develop合并到开发者本地分支、开发分支合并到master操作相同，合并慎重，避免错误提交导致频繁回退的麻烦。</p><h4 id="7-11-2、idea合并"><a href="#7-11-2、idea合并" class="headerlink" title="7.11.2、idea合并"></a>7.11.2、idea合并</h4><p>把2.1.0分支合并到master步骤<br>1、拉取最新代码<br>2、切换到master<br>3、如果有冲突或者其他异常，则再一次拉取代码，直到确保切换到最新的master<br>4、选择origin/2.1.0分支<br>5、点击merge into current。<br>6、如果有冲突，则文件比对解决冲突<br>7、完成了2.1.0合并到master的操作<br>8、push代码到远程仓库，选择vsc-&gt;git-&gt;push<br>9、完成<br><img src="/images/20191121143848154.png" alt=""><br><img src="/images/20191121143802313.png" alt=""><br><img src="/images/20191121144331474.png" alt=""></p><h2 id="八、代码review"><a href="#八、代码review" class="headerlink" title="八、代码review"></a>八、代码review</h2><ul><li>代码审查，通过merge request。</li><li>审查代码是否满足功能、规范、测试结果、测试覆盖等等。</li><li>借助工具来提升代码审查的效率。</li><li>审查合格才允许合进public branch，不合格的代码退回重新修改。</li><li>鼓励使用同行评审（Peer Review）而不是上下级评审，鼓励积极反馈、互动。</li></ul><hr><h2 id="九、参考文档"><a href="#九、参考文档" class="headerlink" title="九、参考文档"></a>九、参考文档</h2><p>git flow<br><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/</a><br>git版本控制、分支策略与代码评审<br><a href="https://blog.csdn.net/nklinsirui/article/details/80303605" target="_blank" rel="noopener">https://blog.csdn.net/nklinsirui/article/details/80303605</a><br>常用git命令<br><a href="https://blog.csdn.net/web_csdn_share/article/details/79243308" target="_blank" rel="noopener">https://blog.csdn.net/web_csdn_share/article/details/79243308</a><br>idea中的解决git文件冲突<br><a href="https://www.cnblogs.com/newAndHui/p/10851807.html" target="_blank" rel="noopener">https://www.cnblogs.com/newAndHui/p/10851807.html</a><br>git操作<br><a href="https://segmentfault.com/a/1190000014461898" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014461898</a><br>其他<br><a href="https://www.cnblogs.com/hezhiying/p/9292314.html" target="_blank" rel="noopener">https://www.cnblogs.com/hezhiying/p/9292314.html</a><br><a href="https://www.cnblogs.com/aylin/p/6042653.html" target="_blank" rel="noopener">https://www.cnblogs.com/aylin/p/6042653.html</a><br><a href="https://www.jianshu.com/p/c2aefcf6b2b7" target="_blank" rel="noopener">https://www.jianshu.com/p/c2aefcf6b2b7</a><br><a href="https://www.cnblogs.com/Gaoqiking/p/11116380.html" target="_blank" rel="noopener">https://www.cnblogs.com/Gaoqiking/p/11116380.html</a><br><a href="https://www.jianshu.com/p/1889b0fe073b" target="_blank" rel="noopener">https://www.jianshu.com/p/1889b0fe073b</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、什么是git？&quot;&gt;&lt;a href=&quot;#一、什么是git？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是git？&quot;&gt;&lt;/a&gt;一、什么是git？&lt;/h2&gt;&lt;h3 id=&quot;1-1、简介&quot;&gt;&lt;a href=&quot;#1-1、简介&quot; class=&quot;headerlink&quot; title=&quot;1.1、简介&quot;&gt;&lt;/a&gt;1.1、简介&lt;/h3&gt;&lt;p&gt; git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作也就是伟大的Linux创始人Linus创作。&lt;/p&gt;
&lt;h3 id=&quot;1-2、常见代码托管平台&quot;&gt;&lt;a href=&quot;#1-2、常见代码托管平台&quot; class=&quot;headerlink&quot; title=&quot;1.2、常见代码托管平台&quot;&gt;&lt;/a&gt;1.2、常见代码托管平台&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;全世界最大的代码托管网站: &lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;国内较多用户使用的网站：&lt;a href=&quot;https://gitee.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以免费搭建自己的代码托管网站的 gitLab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;版本控制工具还有cvs、svn&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Confluence开发者教程</title>
    <link href="http://yoursite.com/2020/03/26/technique-sharing/2020/Confluence%E5%BC%80%E5%8F%91%E8%80%85%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/26/technique-sharing/2020/Confluence开发者教程/</id>
    <published>2020-03-26T08:52:03.000Z</published>
    <updated>2020-03-27T02:15:35.269Z</updated>
    
    <content type="html"><![CDATA[<hr><p> <strong>外链</strong>：<a href="https://blog.csdn.net/u011456337/article/details/103085058" target="_blank" rel="noopener">为什么使用confluence？</a></p><p><strong>版本</strong>：Atlassian Confluence 6.3.1</p><hr><h3 id="一、Confluence简介"><a href="#一、Confluence简介" class="headerlink" title="一、Confluence简介"></a>一、Confluence简介</h3><p>Confluence是一个企业级的Wiki软件，可用于在企业、部门、团队内部进行信息共享和协同编辑。</p><a id="more"></a><hr><h4 id="1-1、能做什么？"><a href="#1-1、能做什么？" class="headerlink" title="1.1、能做什么？"></a>1.1、能做什么？</h4><p>团队将日常的工作任务进度管理、技术知识分享、开发文档、操作手册、文档附件都放置入Confluence中进行统一管理，富文本编辑器使文档内容支持更加丰富，（一般confluence配套使用jira，jira专注于项目bug管理，更多请【百度jira】）</p><h4 id="1-2、基础概念"><a href="#1-2、基础概念" class="headerlink" title="1.2、基础概念"></a>1.2、基础概念</h4><p>Confluence的使用并不复杂，只需掌握如下几个基础概念。空间（Space）空间是Confluence系统中的一个区域，用于存储wiki页面，并可实现对空间中的所有文档进行统一的权限管理。<br>通常，我们可以针对每个项目单独创建一个空间，然后将与该项目相关的文档信息放置到该空间中，并只对项目成员开设访问/编辑权限。<br>除了项目空间，每个成员都有一个个人空间。平时成员可以将工作总结或笔记等文档放置到自己的空间中；对于对团队有帮助的文档，就可以将文档移动至团队项目空间中。</p><h5 id="1-2-1、Dashboard"><a href="#1-2-1、Dashboard" class="headerlink" title="1.2.1、Dashboard"></a>1.2.1、Dashboard</h5><p>Dashboard是Confluence系统的主页，在Dashboard界面中包含了Confluence站点中的所有空间列表，以及最近更新内容的列表。</p><h5 id="1-2-2、页面（Page）"><a href="#1-2-2、页面（Page）" class="headerlink" title="1.2.2、页面（Page）"></a>1.2.2、页面（Page）</h5><p>在Confluence系统中，页面是存储和共享信息的主要方式。<br>页面可以互相链接、连接、组织和访问，并以树状结构进行组织，放置于空间之中。页面遵循所见即所得的编辑方式，操作上简单易用。更强大的地方在于，页面支持大量的内容展现形式，除了富文本文档外，还包括图表、视频、附件（可预览）、流程图、公式等等；如果还不够，还可以通过海量的第三方插件进行扩展。<br>在页面中可以通过@其它成员，通知相关成员查看文档。文档保存成功后，被@的成员就会收到邮件，并可根据邮件中的链接访问到该文档，然后进行评论或者协同编辑。</p><h5 id="1-2-3、模板（template）"><a href="#1-2-3、模板（template）" class="headerlink" title="1.2.3、模板（template）"></a>1.2.3、模板（template）</h5><p>创建页面时除了采用空白文档，也可以选择模板。模板是在空白文档的基础上，根据特定需求添加了一些文档要素，可辅助用户更好更快地创建文档。<br>Confluence内置了大量的模板，可辅助用于项目工作的各个环节，包括产品需求、会议记录、决策记录、指导手册（How-to）、回顾记录、工作计划、任务报告等等。并且由于Confluence和JIRA是同一家公司的产品，在Confluence中可以和JIRA进行无缝衔接，实现对产品质量实现更好的展现。<br>如果对Confluence自带的模板不满意，还可以对模板进行调整，或者根据自己的需求创建其它类型的模板。</p><h5 id="1-2-4、权限（Permission）"><a href="#1-2-4、权限（Permission）" class="headerlink" title="1.2.4、权限（Permission）"></a>1.2.4、权限（Permission）</h5><p>在安全性方面，Confluence具有完善和精细的权限控制，可以很好地控制用户在Wiki中创建、编辑内容和添加注释。<br>权限控制分3个维度，分别是团队（Group），个人（Individual Users），匿名用户（Anonymous）。<br>使用团队级的权限控制时，需要在Confluence服务器中对公司员工进行分组，好处在于配置比较方便，只需要对整个团队进行统一的权限配置。<br>但在实际项目中，经常会存在同一个项目包含多个跨团队成员的情况，这个时候就不适合采用团队权限配置方式，只能采用逐个添加成员的方式，并对各个成员分别配置权限。<br>另外一种情况，就是对于未登录的用户，以及项目成员以外的用户，可以开设部分权限，例如只读（View）。</p><hr><h3 id="二、常见操作"><a href="#二、常见操作" class="headerlink" title="二、常见操作"></a>二、常见操作</h3><p>熟悉了Confluence的基础概念，基本上就可以摸索着对Confluence进行上手了。不过，为了减少摸索时间，在这里我再将Confluence中的常用操作进行说明。</p><h4 id="2-1、文档查看与操作"><a href="#2-1、文档查看与操作" class="headerlink" title="2.1、文档查看与操作"></a>2.1、文档查看与操作</h4><p>用户账户登录首页-&gt;选择要查看的【空间】-&gt;【****开发项目管理】-&gt;【项目管理】-&gt;选择对应的项目→查看您想看的文档<br><img src="/images/20191115141617777.png" alt=""></p><h4 id="2-2、添加文档"><a href="#2-2、添加文档" class="headerlink" title="2.2、添加文档"></a>2.2、添加文档</h4><p>在Confluence中文件以树状结构进行组织。<br>推荐的创建方式是，先进入父目录的页面，然后再点击【Create】进行创建。在创建文档页面中，可以看到新建文档的“父级”，表示新文档创建后将位于“父级”文件的下一个层级中。</p><p>在新建文档时，需要选择文档模板。这个就根据文档的实际类型或用途进行选择即可，如果觉得都不合适，就选择“Blank page”。<br><img src="/images/2019111514172047.png" alt=""></p><h4 id="2-3、编写文档"><a href="#2-3、编写文档" class="headerlink" title="2.3、编写文档"></a>2.3、编写文档</h4><p>在编写文档时，页面遵循所见即所得的编辑方式，基本上跟在MS Word中的操作类似。<br>Confluence也集成了许多编辑工具，可以很方便地插入图表、链接、附件、代办列表等等。如果还不满足需求，可以点击【插入】-&gt;【其他宏】，查找更多的扩展插件。<br><img src="/images/20191115141759727.png" alt=""></p><ul><li>2.3.1、 选择【格式化】-&gt;【代码块】-&gt;【语法高亮】-&gt;自由选择风格【选择sql】-&gt;自由选择主题【选择】-&gt;【emacs】,接着确认，即可插入sql<br><img src="/images/20191115141859333.png" alt=""></li></ul><p><img src="/images/2019111514204243.png" alt=""></p><ul><li>2.3.2、 插入表格，插入开发状态颜色，点击【+】-&gt;选择【状态】<br><img src="/images/20191115142129799.png" alt=""><ul><li>2.3.3、 插入图片和附件 选择【插入文件和图片】<br>例如，Confluence默认是不支持Markdown编辑模式的，如果想采用Markdown来编写文档，就可以通过上述方式到插件市场寻找Markdown的插件。<br>不过根据实践发现，当前Confluence的Markdown插件支持的还不够好，使用体验上不尽如人意。比较推荐的做法，还是在单独的Markdown编辑器上采用markdown语法进行编辑，编辑完成后进行预览，然后将渲染后的文档内容复制粘贴到Confluence中。<br><img src="/images/20191115142145441.png" alt=""></li><li>2.3.4、移动文档<br>很多时候我们需要调整目录结构，这就涉及到需要将文档移动到别的目录层级下。<br>操作方式如下：先进入到待移动的文档页面中，点击页面右上角的【…】-&gt;【移动】；<br>然后选择移动到新的目录即可。<br><img src="/images/20191115142255424.png" alt=""></li></ul></li></ul><h4 id="2-4、创建目录"><a href="#2-4、创建目录" class="headerlink" title="2.4、创建目录"></a>2.4、创建目录</h4><p>与创建文档方式一致，直接创建标题保存即可</p><h4 id="2-5、模板方式创建文档"><a href="#2-5、模板方式创建文档" class="headerlink" title="2.5、模板方式创建文档"></a>2.5、模板方式创建文档</h4><p> 选择【以层级方式查看】-&gt;[模板]-&gt;【编辑】<br> <img src="/images/20191115142338772.png" alt=""><br> <img src="/images/20191115142418741.png" alt=""></p><h3 id="三、发表评论"><a href="#三、发表评论" class="headerlink" title="三、发表评论"></a>三、发表评论</h3><p><img src="/images/2019111514254892.png" alt=""></p><h3 id="四、上传文档附件"><a href="#四、上传文档附件" class="headerlink" title="四、上传文档附件"></a>四、上传文档附件</h3><p>样例<br><img src="/images/20191115142607965.png" alt=""></p><h3 id="五、导出"><a href="#五、导出" class="headerlink" title="五、导出"></a>五、导出</h3><p><img src="/images/20191115142620952.png" alt=""></p><h3 id="六、文档权限管理"><a href="#六、文档权限管理" class="headerlink" title="六、文档权限管理"></a>六、文档权限管理</h3><p>选择【…】-&gt;【限制】<br><img src="/images/20191115142705591.png" alt=""></p><h3 id="七、创建空间"><a href="#七、创建空间" class="headerlink" title="七、创建空间"></a>七、创建空间</h3><p>新建一个项目时，首先要做的就是创建一个空间，并进行初始化配置。<br>创建空间的方式很简单，可以从顶部菜单进行创建：【空间】-&gt;【创建】；也可以从Dashboard页面的Spaces页面中进行创建。<br><img src="/images/20191115142751374.png" alt=""></p><ol><li>进入创建空间页面后，需要选择空间类型。这个需要根据空间的用途进行选择，对于团队协作的空间，推荐选择“Team Space”，如果实在不知道选择什么类型，选择“Blank Space”也是可以的。</li><li>然后是填写空间的基本信息。所有类型的空间都有两个必填字段，空间名和空间标识符。空间标识符可以理解为空间的ID，不同空间的空间标识符不能重复，但空间名是可以重复的。</li><li>另外，对于“Team Space”类型的空间，多了一个“Team members”字段，用于添加空间的成员。成员的名称是其公司邮箱的前缀。<br>需要说明的是，空间创建完成后，Space key字段是不能修改的，其它字段以及团队成员都可以进行修改。<br><img src="/images/20191115142824300.png" alt=""><br><img src="/images/20191115142908257.png" alt=""><h3 id="八、配置空间权限"><a href="#八、配置空间权限" class="headerlink" title="八、配置空间权限"></a>八、配置空间权限</h3>创建空间后，根据项目需要，可以给空间设置权限。只有空间的管理员才能对空间权限进行配置。<br>操作方式如下：首先进入空间的页面，在空间左下角中，【空间管理】-&gt;【权限】，进入权限管理页面。</li></ol><p>Confluence的权限控制比较完善，可以根据团队规范进行较为精细粒度的设置。<br><img src="/images/20191115142930420.png" alt=""><br><img src="/images/20191115143010490.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt; &lt;strong&gt;外链&lt;/strong&gt;：&lt;a href=&quot;https://blog.csdn.net/u011456337/article/details/103085058&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么使用confluence？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本&lt;/strong&gt;：Atlassian Confluence 6.3.1&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、Confluence简介&quot;&gt;&lt;a href=&quot;#一、Confluence简介&quot; class=&quot;headerlink&quot; title=&quot;一、Confluence简介&quot;&gt;&lt;/a&gt;一、Confluence简介&lt;/h3&gt;&lt;p&gt;Confluence是一个企业级的Wiki软件，可用于在企业、部门、团队内部进行信息共享和协同编辑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="wiki" scheme="http://yoursite.com/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>无缝滚动</title>
    <link href="http://yoursite.com/2020/01/14/technique-sharing/2020/%E6%97%A0%E7%BC%9D%E6%BB%9A%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/01/14/technique-sharing/2020/无缝滚动/</id>
    <published>2020-01-14T15:29:08.000Z</published>
    <updated>2020-03-25T10:24:48.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无缝滚动效果"><a href="#无缝滚动效果" class="headerlink" title="无缝滚动效果"></a>无缝滚动效果</h1><h2 id="使用插件：vue-seamless-scroll"><a href="#使用插件：vue-seamless-scroll" class="headerlink" title="使用插件：vue-seamless-scroll"></a>使用插件：vue-seamless-scroll</h2><p>详细demo请<a href="https://chenxuan0000.github.io/component-document/index_prod.html#/component/seamless-default" target="_blank" rel="noopener">查看</a></p>]]></content>
    
    <summary type="html">
    
      网站使用无缝滚动技术记录
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="vue-seamless-scroll" scheme="http://yoursite.com/tags/vue-seamless-scroll/"/>
    
  </entry>
  
  <entry>
    <title>vue中使用AOS动画插件</title>
    <link href="http://yoursite.com/2020/01/13/technique-sharing/2020/vue%E4%B8%AD%E4%BD%BF%E7%94%A8AOS%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/01/13/technique-sharing/2020/vue中使用AOS动画插件/</id>
    <published>2020-01-13T15:29:08.000Z</published>
    <updated>2020-03-25T10:24:48.191Z</updated>
    
    <content type="html"><![CDATA[<p>新版网站首页需要做到动画的效果，为了满足产品的需求，我选择使用AOS插件来做动画。<br>AOS 是一个用于在页面滚动的时候呈现元素动画的工具库，在页面往回滚动时，元素会恢复到原来的状态。可以看下它的demo演示：(<a href="http://michalsnik.github.io/aos/" target="_blank" rel="noopener">http://michalsnik.github.io/aos/</a>)</p><a id="more"></a><p>以下是具体使用方案：<br>1、安装AOS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aos --save</span><br></pre></td></tr></table></figure><p>2、在vue中引入模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#39;aos&#x2F;dist&#x2F;aos.css&#39;</span><br><span class="line">import AOS from &#39;aos&#x2F;dist&#x2F;aos.js&#39;</span><br></pre></td></tr></table></figure><p>3、初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">&#x2F;&#x2F; 你也可以在这里设置全局配置</span><br><span class="line">  AOS.init(&#123;</span><br><span class="line">    offset: 200,   </span><br><span class="line">    duration: 600,   </span><br><span class="line">    easing: &#39;ease-in-sine&#39;,   </span><br><span class="line">    delay: 100</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、使用<code>data-aos</code>属性设置动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div  data-aos &#x3D; “fade-in”&gt; &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>也可以通过使用<code>data-aos-*</code>属性来调整单个动画行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div </span><br><span class="line">   data-aos &#x3D; “fade-in”</span><br><span class="line">   data-aos-id &#x3D; “fadeIn”</span><br><span class="line">   data-aos-offset &#x3D; “ 200 ”</span><br><span class="line">   data-aos-delay &#x3D; “ 50 ”</span><br><span class="line">   data-aos-duration &#x3D; “1000 ”</span><br><span class="line">   data-aos-easing &#x3D; &quot;ease-in-out&quot;</span><br><span class="line">&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>5、禁用AOS</p><p>如果你项在小屏幕设备中禁用AOS，可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AOS.init(&#123;   </span><br><span class="line">    disable: &#39;mobile&#39;  &#x2F;&#x2F; mobile、phone或tablet。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者传入一个函数，返回true或false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disable: function () &#123;</span><br><span class="line">    var maxWidth &#x3D; 1024;</span><br><span class="line">    return window.innerWidth &lt; maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、监听AOS动画<br>AOS提供了两个事件：<code>aos:in</code>以及<code>aos:out</code>每当任何元素动画化时，你就可以在JS中做一些额外的事情。<br>也可以通过设置<code>data-aos-id</code>属性来告诉AOS在特定元素上触发自定义事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div data-aos&#x3D;&quot;fade-in&quot; data-aos-id&#x3D;&quot;super-duper&quot;&gt; &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>然后，能够监听两个自定义事件：</p><ul><li><code>aos:in:super-duper</code></li><li><code>aos:out:super-duper</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动画进来时候</span><br><span class="line">document.addEventListener(&#39;aos:in:super-duper&#39;, (&#123; detail &#125;) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; 如果还有其他动画效果就可以在这儿添加了</span><br><span class="line">  console.log(&#39;animated in&#39;, detail);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 动画离开时候</span><br><span class="line">document.addEventListener(&#39;aos:out:super-duper&#39;, (&#123; detail &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;animated out&#39;, detail);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>7、API<br>AOS对象作为全局变量公开，目前有三种可用方法：</p><ul><li><code>init</code>-初始化AOS</li><li><code>refresh</code>-重新计算元素的所有偏移量和位置（在窗口调整大小时调用）</li><li><code>refreshHard</code>-使用AOS元素和触发器重新初始化数组<code>refresh</code>（调用与<code>aos</code>元素相关的DOM更改）</li></ul><p>更多AOS动画配置可以看下它的github：<a href="https://github.com/michalsnik/aos" target="_blank" rel="noopener">https://github.com/michalsnik/aos</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新版网站首页需要做到动画的效果，为了满足产品的需求，我选择使用AOS插件来做动画。&lt;br&gt;AOS 是一个用于在页面滚动的时候呈现元素动画的工具库，在页面往回滚动时，元素会恢复到原来的状态。可以看下它的demo演示：(&lt;a href=&quot;http://michalsnik.github.io/aos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://michalsnik.github.io/aos/&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="aos" scheme="http://yoursite.com/tags/aos/"/>
    
  </entry>
  
  <entry>
    <title>常见开发场景安全</title>
    <link href="http://yoursite.com/2019/12/24/technique-sharing/2019/%E5%B8%B8%E8%A7%81%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/12/24/technique-sharing/2019/常见开发安全场景/</id>
    <published>2019-12-24T15:29:08.000Z</published>
    <updated>2020-03-25T10:24:48.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-常见开发场景安全"><a href="#1-常见开发场景安全" class="headerlink" title="1. 常见开发场景安全"></a>1. 常见开发场景安全</h1><h2 id="1-1-敏感信息使用场景"><a href="#1-1-敏感信息使用场景" class="headerlink" title="1.1 敏感信息使用场景"></a>1.1 敏感信息使用场景</h2><p> 敏感信息指用户的 身份证号、银行卡号、手机号 等身份信息。重要敏感信息的脱敏规范如下。</p><table><thead><tr><th>敏感信息类型</th><th>展示规范</th></tr></thead><tbody><tr><td>身份证</td><td>显示前 1 位 + <em>(实际位数) + 后 1 位，如： 3<strong><strong><strong>***</strong></strong></strong></em>3</td></tr><tr><td>银行卡</td><td>显示前 6 位 + <em>(实际位数) + 后 4 位，如：622575*****</em>1496</td></tr><tr><td>手机号</td><td>显示前 3 位 + <strong>** + 后 4 位，如：137**</strong>9050</td></tr></tbody></table><a id="more"></a><h3 id="1-1-1-敏感信息用于展示的场景"><a href="#1-1-1-敏感信息用于展示的场景" class="headerlink" title="1.1.1 敏感信息用于展示的场景"></a>1.1.1 <span id="1.1.1">敏感信息用于展示的场景</span></h3><ul><li>原则：敏感信息的展示请严格按照脱敏规范进行脱敏<ul><li>说明：脱敏的逻辑必须在服务端完成，不能使用 Javascript 在客户端进行脱敏，包括代码注释、隐藏域、url 参数、cookies 等处的数据也必须脱敏。</li><li>说明：不能使用可逆的编码/加密方式，如 base64 编码等代替脱敏规范。</li><li>说明：若敏感信息明文展示在应用中，没有按照脱敏规范完成脱敏。支付宝开放平台将有权暂停敏感数据相关接口的开放。</li></ul></li></ul><h3 id="1-1-2-敏感信息用于身份校验的场景"><a href="#1-1-2-敏感信息用于身份校验的场景" class="headerlink" title="1.1.2 敏感信息用于身份校验的场景"></a>1.1.2 <span id="1.1.2">敏感信息用于身份校验的场景</span></h3><ul><li>原则：不要直接将敏感信息的明文信息在客户端与服务端之间传递<ul><li>说明：可以将敏感信息在服务端关联到用户标识 ID，在客户端保存用户标识 ID 并提交到服务端，服务端根据 ID 取出对应信息后进行校验。</li><li>说明：如果服务端没有用户标识 ID 的机制，同时也必须在客户端与服务端之间传递敏感信息，请使用 AES128 对称加密算法进行加密后传输，并且不能将解密密钥传输给用户端。</li></ul></li></ul><h2 id="1-2-HTML-页面渲染"><a href="#1-2-HTML-页面渲染" class="headerlink" title="1.2. HTML 页面渲染"></a>1.2. HTML 页面渲染</h2><ul><li><p>原则：所有在页面渲染的敏感数据 (身份证、银行卡号、手机号) 必须进行脱敏</p><ul><li>说明：参考章节 <a href="#1.1.1">1.1.1. 敏感信息用于展示的场景</a></li></ul></li><li><p>原则：禁止在 Cookie 中 明文写入 敏感数据</p><ul><li>说明：参考章节 <a href="#1.1.2">1.1.2. 敏感信息用于用于身份校验的场景</a></li></ul></li><li><p>原则：禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据</p><ul><li>说明：用户数据不仅仅包括用户正常数据，同时包括攻击者可修改，伪造的其他数据。</li><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li><li><p>原则：HTML 页面动态输出 JSON、JavaScript 必须对其中的字符串值做 XSS 防御处理</p><ul><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li><li><p>原则：默认设置 HTTP Header 中的 HttpOnly 属性为 true</p><ul><li>说明：设置 HttpOnly 为 true，将可以禁止 JavaScript 读取页面 Cookie 信息，一定程度上防范 XSS 攻击。</li><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li><li><p>原则：如果网站使用 HTTPS 协议，默认设置 HTTP Header 中的 secure 属性为 true</p><ul><li>说明：设置 secure 为 true，Cookie 信息将不会在 HTTP 连接中传输，一定程度上防范 XSS 攻击。</li><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li></ul><h2 id="1-3-接口调用操作"><a href="#1-3-接口调用操作" class="headerlink" title="1.3. 接口调用操作"></a>1.3. 接口调用操作</h2><ul><li><p>原则：AJAX 接口必须执行 CSRF 过滤</p><ul><li>说明：参考章节 <a href="#2.6">2.6 CSRF 漏洞</a></li></ul></li><li><p>原则：AJAX 接口输出 JSON 字符串禁止通过字符串拼接构造，且输出的 JSON 需要经过安全过滤</p><ul><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li><li><p>原则：AJAX 接口返回头必须设置 Content-Type 为 application/json;charset=utf-8</p></li></ul><h2 id="1-4-表单提交操作"><a href="#1-4-表单提交操作" class="headerlink" title="1.4. 表单提交操作"></a>1.4. 表单提交操作</h2><ul><li><p>原则：统一使用 POST 方式提交表单</p><ul><li>说明：Get 请求可以通过构造 img 等标签发起，造成 CSRF</li><li>说明：参考章节 <a href="#2.6">2.6 CSRF 漏洞</a></li></ul></li><li><p>原则：Form 表单提交必须执行 CSRF 过滤</p><ul><li>说明：参考章节<a href="#2.6">2.6 CSRF 漏洞</a></li></ul></li><li><p>原则：用户输入的富文本浏览器展示之前必须由服务器端做安全过滤</p><ul><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li></ul><h2 id="1-5-数据库操作"><a href="#1-5-数据库操作" class="headerlink" title="1.5. 数据库操作"></a>1.5. 数据库操作</h2><ul><li>原则：编写的 SQL 必须预编译，不允许通过字符串拼接的方式合成<ul><li>说明：部分特殊场景，必须通过拼接合成，则拼接的变量必须经过处理，只允许 [a-zA-Z0-9_-.]＋ 字符。</li><li>说明：参考章节 <a href="#2.5">2.5 SQL 注入漏洞</a></li></ul></li></ul><h2 id="1-6-跨域操作"><a href="#1-6-跨域操作" class="headerlink" title="1.6. 跨域操作"></a>1.6. 跨域操作</h2><h3 id="1-6-1-JSONP-跨域"><a href="#1-6-1-JSONP-跨域" class="headerlink" title="1.6.1. JSONP 跨域"></a>1.6.1. JSONP 跨域</h3><ul><li>原则：JSONP 接口 Callback 必须验证有效性</li><li>原则：JSONP 接口输出 JSON 字符串禁止通过字符串拼接构造，且输出的 JSON 需要经过安全过滤<ul><li>说明：参考章节 <a href="#2.2">2.2 跨站脚本（XSS）漏洞</a></li></ul></li><li>原则：JSONP 接口必须对 Referer 进行白名单校验，或执行 CSRF 检查</li><li>原则：JSONP 接口返回头必须正确设置 Content-Type 为 application/javascript;charset=utf-8</li></ul><h3 id="1-6-2-CORS-跨域"><a href="#1-6-2-CORS-跨域" class="headerlink" title="1.6.2. CORS 跨域"></a>1.6.2. CORS 跨域</h3><ul><li>原则：支持 CORS 跨域的接口，返回头 Access-Control-Allow-Origin 必须使用白名单验证，禁止直接返回*</li></ul><h2 id="1-7-文件上传与下载"><a href="#1-7-文件上传与下载" class="headerlink" title="1.7 文件上传与下载"></a>1.7 文件上传与下载</h2><ul><li>原则：限制可下载文件所在的目录为预期范围，并通过指定文件编号的方式来定位待下载文件<ul><li>说明：参考章节 <a href="#2.4">2.4 目录遍历漏洞</a></li><li>说明：参考章节 <a href="#2.4">文件下载漏洞</a></li></ul></li><li>原则：保存上传文件的目录不提供直接访问</li><li>原则：对上传文件的大小和类型进行校验，定义上传文件类型白名单<ul><li>说明：参考章节 <a href="#2.4">文件上传漏洞</a></li></ul></li></ul><h1 id="2-常见安全漏洞及修复方案"><a href="#2-常见安全漏洞及修复方案" class="headerlink" title="2. 常见安全漏洞及修复方案"></a>2. 常见安全漏洞及修复方案</h1><h2 id="2-1-源代码仓库安全"><a href="#2-1-源代码仓库安全" class="headerlink" title="2.1  源代码仓库安全"></a>2.1  源代码仓库安全</h2><p>源代码泄露也不是个新的话题了。但前段时间的“B站工程源码泄露”又把源代码泄露推上了热搜。</p><p>那么问题来了，源代码是怎么被泄露的怎么能预防呢？</p><p>源代码的泄露大部分都是在 <code>源代码仓库</code>，<code>内部泄露</code>和<code>线上项目文件权限设置问题</code>，接下来我们来重点讲解一下 <code>源代码仓库</code> 这种。这种方式最为普遍，危险程度也是最高的。</p><p>在<code>源代码仓库</code>泄露代码也分为很多种 密码被破解、仓库权限设置错误、宿主机漏洞、Web 程序漏洞、SSH 漏洞等等。</p><p>我们拿<code>仓库权限</code>举个栗子：</p><h3 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h3><p>利用搜索引擎的高级搜索来搜索一些gitlab私服，这里我提供了以下几种关键字可以去搜索gitlab私服：</p><p>谷歌：<a href="https://www.google.com/search?q=allinurl%3Acn+%2B+%2Fexplore%2Fprojects&oq=allinurl%3Acn+%2B+%2Fexplore%2Fprojects&aqs=chrome..69i57j69i58j69i60.1422j0j9&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener">allinurl:cn + /explore/projects</a></p><p>谷歌：<a href="https://www.google.com/search?safe=active&sxsrf=ACYBGNRk0K-Saxyd2iBaNxORQjLnmnNKsw%3A1573098014524&ei=HpLDXZ7DH9bZhwOO7YPQCA&q=%E6%B5%8F%E8%A7%88%E9%A1%B9%E7%9B%AE%2C%E7%BE%A4%E7%BB%84%E5%92%8C%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%82%E4%B8%8E%E4%BB%96%E4%BA%BA%E5%88%86%E4%BA%AB%E6%82%A8%E7%9A%84%E9%A1%B9%E7%9B%AE&oq=%E6%B5%8F%E8%A7%88%E9%A1%B9%E7%9B%AE%2C%E7%BE%A4%E7%BB%84%E5%92%8C%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E3%80%82%E4%B8%8E%E4%BB%96%E4%BA%BA%E5%88%86%E4%BA%AB%E6%82%A8%E7%9A%84%E9%A1%B9%E7%9B%AE&gs_l=psy-ab.3..35i39.58956.58956..59128...0.0..0.98.98.1......0....2j1..gws-wiz.DkcTrcCS_UU&ved=0ahUKEwieyujiltflAhXW7GEKHY72AIoQ4dUDCAs&uact=5" target="_blank" rel="noopener">浏览项目,群组和代码片段。与他人分享您的项目</a></p><p>百度：<a href="https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&ch=3&tn=98010089_dg&wd=%E9%A1%B9%E7%9B%AE%C2%B7%20%E6%8E%A2%E7%B4%A2%C2%B7%20GitLab%20-%20%E7%99%BB%E5%BD%95%C2%B7%20GitLab&oq=%25E6%25B5%258F%25E8%25A7%2588%25E9%25A1%25B9%25E7%259B%25AE%252C%25E7%25BE%25A4%25E7%25BB%2584%25E5%2592%258C%25E4%25BB%25A3%25E7%25A0%2581%25E7%2589%2587%25E6%25AE%25B5%25E3%2580%2582%25E4%25B8%258E%25E4%25BB%2596%25E4%25BA%25BA%25E5%2588%2586%25E4%25BA%25AB%25E6%2582%25A8%25E7%259A%2584%25E9%25A1%25B9%25E7%259B%25AE&rsv_pq=e75cc08d0005f615&rsv_t=ca5dM1ytGKtvDf%2Br5X6uRql5pkfiySg%2BNW%2BCeQGnF0mIantQOdF%2BOg6rFbDtvPyAaE4&rqlang=cn&rsv_enter=1&rsv_dl=tb&inputT=314&rsv_sug3=6&rsv_n=2&rsv_sug2=0&rsv_sug4=598" target="_blank" rel="noopener">项目· 探索· GitLab - 登录· GitLab</a></p><p>搜索结果大概如下：<br><img src="https://upload.cc/i1/2019/11/07/BTJlEQ.png" alt="images"></p><p>我们发现了很多gitlab私服，我们随便点击几个就发现了很多权限设置为公开的项目，这些项目我们分分钟都可以同步回本地，这些仓库都带了全部的代码提交以及操作记录。</p><p><img src="https://upload.cc/i1/2019/11/07/jiIFeG.png" alt="image"></p><h2 id="利用案例"><a href="#利用案例" class="headerlink" title="利用案例"></a>利用案例</h2><p>这里随便搜集了几个私服地址：</p><p><a href="http://gitlab.gongwuyun.cn/explore/projects" target="_blank" rel="noopener">http://gitlab.gongwuyun.cn/explore/projects</a></p><p><a href="http://git.neweservice.com/explore/projects" target="_blank" rel="noopener">http://git.neweservice.com/explore/projects</a></p><p><a href="http://www.shenjia.net/explore/projects" target="_blank" rel="noopener">http://www.shenjia.net/explore/projects</a></p><blockquote><p>代码泄露还不是最危险的。最危险的是代码里面的各种硬编码、密钥以及证书！！！</p></blockquote><h3 id="防范方式"><a href="#防范方式" class="headerlink" title="防范方式"></a>防范方式</h3><ol><li><p>使用强密码降低被破解的风险，开启双重身份验证，使用SSH密钥等……</p></li><li><p>定期更新系统安全补丁，升级应用版本。</p></li><li><p>项目权限设置：<code>管理中心 &gt; 通用 &gt; 可见性与访问控制</code><br><img src="https://upload.cc/i1/2019/11/07/LwO9vm.png" alt="image"></p></li><li><p>定期检查开放的项目 <code>管理中心 &gt; 项目 &gt; 公开</code><br><img src="https://upload.cc/i1/2019/11/07/1oVrD2.png" alt="image"></p></li></ol><h2 id="2-2-跨站脚本攻击—XSS"><a href="#2-2-跨站脚本攻击—XSS" class="headerlink" title="2.2 跨站脚本攻击—XSS"></a><span id="2.2">2.2 跨站脚本攻击—XSS</span></h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>跨站脚本攻击(Cross Site Scripting, XSS)发生在客户端，可被用于进行窃取隐私、钓鱼欺骗、偷取密码、传播恶意代码等攻击行为。<br>XSS 攻击，==一般是指攻击者通过在网页中注入恶意脚本，当用户浏览网页时，恶意脚本执行，控制用户浏览器行为的一种攻击方式==。</p><p>XSS 攻击类型一般分为两类：</p><ul><li>==Reflected XSS（反射型的 XSS 攻击）==</li><li>==Stored XSS（存储型的 XSS 攻击）==</li></ul><p>==两类下有分为若干种方式（例：DOM-based、JSONP XSS）==。</p><p><code>反射型 XSS</code> 和 <code>DOM 型 XSS</code> 算是 <code>非持久型 XSS 攻击</code>，而 <code>存储型 XSS</code> 算是 <code>持久型 XSS 攻击</code>。</p><h3 id="2-2-1-Reflected-XSS（反射型的-XSS-攻击）"><a href="#2-2-1-Reflected-XSS（反射型的-XSS-攻击）" class="headerlink" title="2.2.1 Reflected XSS（反射型的 XSS 攻击）"></a>2.2.1 Reflected XSS（反射型的 XSS 攻击）</h3><blockquote><p>反射型XSS，非持久化，用户通过Web客户端提交给服务端的数据，立刻用于解析和显示该用户的结果页面(数据没有在服务端存储)</p></blockquote><h4 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。<br>因为这个过程就像一次反射，故称为反射型 XSS。</p><h4 id="攻击步骤："><a href="#攻击步骤：" class="headerlink" title="攻击步骤："></a>攻击步骤：</h4><ol><li>攻击构造出特殊的 URL ，其中包含恶意代码。</li><li>用户被诱导打开带有恶意代码的 URL，服务器端将恶意代码从 URL 中取出当做参数处理，然后返回给用户带有恶意代码的数据。</li><li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>我们接收一个Name的参数然后把它显示在界面。</p><p><img src="https://upload.cc/i1/2019/11/12/cp84SX.png" alt="image"><br><img src="https://upload.cc/i1/2019/11/12/ZPw3A0.png" alt="image"></p><p>下面是一个正常的流程</p><p><a href="http://127.0.0.1:888/ReflectedXSS?name=User" target="_blank" rel="noopener">http://127.0.0.1:888/ReflectedXSS?name=User</a></p><p><img src="https://upload.cc/i1/2019/11/12/cT0zLt.png" alt="image"></p><p>显示效果正常。</p><p>因为这里没有对用户输入的数据做处理，所以我们构造这样一个链接：</p><p><a href="http://127.0.0.1:888/ReflectedXSS?name=%3Cscript%3Ealert(%22xss%22)%3C/script%3E" target="_blank" rel="noopener">http://127.0.0.1:888/ReflectedXSS?name=%3Cscript%3Ealert(%22xss%22)%3C/script%3E</a></p><p>然后诱导他人点击这个链接，就可以完成一次反射型 XSS 攻击。</p><p><img src="https://upload.cc/i1/2019/11/12/x5PD7X.png" alt="image"></p><p>==假如客户认识XSS，看见链接有js代码不访问了怎么办？我们还可以伪装伪装，转为短网址或者二维码==。</p><p>短网址：<a href="http://i6q.cn/4YSo03" target="_blank" rel="noopener">http://i6q.cn/4YSo03</a></p><p>也许你觉得只是一个弹框而已，问题不大，但如果我们把攻击代码变为加载一个第三方的 js 文件呢？变为用 <code>document.cookie</code> 盗取 cookie 的代码呢？总之如果是真的攻击的话，就不会只是一个弹框这么简单了。</p><h3 id="2-2-2-Stored-XSS（存储型的-XSS-攻击）"><a href="#2-2-2-Stored-XSS（存储型的-XSS-攻击）" class="headerlink" title="2.2.2 Stored XSS（存储型的 XSS 攻击）"></a>2.2.2 Stored XSS（存储型的 XSS 攻击）</h3><blockquote><p>存储型XSS，持久化，用户通过Web客户端提交给服务端的数据，由服务端保存，然后永久显示在其他用户的页面上。</p></blockquote><h4 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>存储型 XSS 跟 反射型 XSS 的区别是：==存储型 XSS 的恶意代码存在服务器上，反射型 XSS 的恶意代码存在 URL 里==。</p><p>存储型 XSS 攻击时恶意脚本会存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行。它是最危险的一种跨站脚本，比反射性 XSS 和 DOM 型 XSS 都更有隐蔽性，因为它不需要用户手动触发。任何允许用户存储数据的 Web 程序都可能存在存储型 XSS 漏洞。若某个页面遭受存储型 XSS 攻击，所有访问该页面的用户都会被 XSS 攻击。</p><blockquote><p>基于存储的 XSS 攻击，是通过提交带有恶意脚本的内容存储在服务器上，当其他人看到这些内容时发起 Web 攻击。一般提交的内容都是通过一些富文本编辑器编辑的，很容易插入危险代码。</p></blockquote><h4 id="攻击步骤：-1"><a href="#攻击步骤：-1" class="headerlink" title="攻击步骤："></a>攻击步骤：</h4><ol><li>攻击者把恶意代码提交到目标网站的服务器中。</li><li>用户打开目标网站，网站服务器端把带有恶意代码的数据取出，当做正常数据返回给用户。</li><li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p><img src="https://upload.cc/i1/2019/11/07/4Xv8mo.png" alt="image"></p><h4 id="举个栗子：-1"><a href="#举个栗子：-1" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p><a href="https://www.kkkk1000.com/xss/Stored/index.html" target="_blank" rel="noopener">https://www.kkkk1000.com/xss/Stored/index.html</a></p><p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3cd8c79ed1324?imageslim" alt="image"></p><p>但是，评论的内容是没有处理过的，所以我们如果输入这样的内容：<br><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code><br>同样是可以作为评论的。</p><p>我们用这样的内容作为评论后，所有打开这篇文章的用户都会遭到存储型 XSS 攻击。</p><p><img src="./study-images/16" alt="image"></p><h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><h4 id="1-浏览器自带防御-（X-XSS-Protection）"><a href="#1-浏览器自带防御-（X-XSS-Protection）" class="headerlink" title="1. 浏览器自带防御 （X-XSS-Protection）"></a>1. 浏览器自带防御 （X-XSS-Protection）</h4><p>HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个功能，当检测到跨站脚本攻击(XSS)时，浏览器将停止加载页面。<br>他可以设置4个值：<br>X-XSS-Protection: 0<br>禁止XSS过滤。     </p><p>X-XSS-Protection: 1<br>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。  </p><p>X-XSS-Protection: 1; mode=block<br>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。  </p><p>X-XSS-Protection: 1; report=<reporting-uri><br>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。<br>复制代码这种浏览器自带的防御功能只对反射型 XSS 有一定的防御力，其原理是检查 URL 和 DOM 中元素的相关性，但这并不能完全防止反射型 XSS，而且也并不是所有浏览器都支持 X-XSS-Protection。</p><h4 id="2-转义"><a href="#2-转义" class="headerlink" title="2. 转义"></a>2. 转义</h4><p>在 XSS 攻击中，攻击者主要是通过构造特殊字符来注入脚本，所以对用户的输入进行检测就很有必要，并且需要在客户端与服务端都进行输入检测，然后对用户输入的数据进行转义。<br>主要就是对输入所包含的特殊字符进行转义，如 &lt;，&gt;，&amp;，”，’，来防止 XSS 攻击。<br>下面是一个用于转义的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>);</span><br><span class="line">    str = str..replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#39;"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-过滤"><a href="#3-过滤" class="headerlink" title="3. 过滤"></a>3. 过滤</h4><p>在富文本中因为需要保留 HTML ，所以我们不能使用转义的方法防御 XSS 攻击，这里使用过滤的方式防御 XSS 攻击，也就是通过只使用白名单允许的 HTML 标记及其属性，来防御攻击。<br>这里推荐一个名为 ==<a href="https://github.com/leizongmin/js-xss/blob/master/README.zh.md" target="_blank" rel="noopener">XSS</a>== 的组件 ，这就是一个根据白名单过滤 HTML，防止 XSS 攻击的组件。</p><h4 id="4-内容安全策略（CSP）"><a href="#4-内容安全策略（CSP）" class="headerlink" title="4. 内容安全策略（CSP）"></a>4. 内容安全策略（CSP）</h4><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">内容安全策略（Content Security Policy，CSP）</a>，实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。</p><p>两种方法可以启用 CSP。<br>一种是通过 HTTP 头信息的 Content-Security-Policy 的字段。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#39;self&#39;; </span><br><span class="line">                         object-src &#39;none&#39;;</span><br><span class="line">                         style-src cdn.example.org third-party.org; </span><br><span class="line">                         child-src https:</span><br></pre></td></tr></table></figure><br>另一种是通过网页的 <meta> 标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot;</span><br><span class="line">      content&#x3D;&quot;script-src &#39;self&#39;;</span><br><span class="line">               object-src &#39;none&#39;;</span><br><span class="line">               style-src cdn.example.org third-party.org;</span><br><span class="line">               child-src https:&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>上面代码中，CSP 做了如下配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 脚本： 只信任当前域名</span><br><span class="line">- &lt;object&gt;标签： 不信任任何 URL，即不加载任何资源</span><br><span class="line">- 样式表： 只信任 cdn.example.org 和 third-party.org</span><br><span class="line">- 页面子内容，如 &lt;frame&gt;、&lt;iframe&gt;： 必须使用HTTPS协议加载</span><br><span class="line">- 其他资源： 没有限制</span><br></pre></td></tr></table></figure><p>启用后，不符合 CSP 的外部资源就会被阻止加载。</p><p>Chrome 的报错信息。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091303.png" alt="image"></p><p>更多资料访问这里：<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/csp.html</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>XSS 攻击的本质就是输入的内容被当做程序执行了，所以我们对于用户输入的内容不能完全的信任，需要考虑如何避免其被当做程序执行。</p><h2 id="2-3-JSONP-XSS"><a href="#2-3-JSONP-XSS" class="headerlink" title="2.3 JSONP XSS"></a>2.3 JSONP XSS</h2><p>先说 JSONP。通过 JavaScript 调用，被调用域名和当前页面域名不一致，就需要用到 JSONP。</p><blockquote><p>浏览器为了保证跨域访问的安全性，会默认发一个 callback 参数到后台，接口拿到这个参数之后，需要将返回的 JSON 数据外面包上 callback 参数。一般而言，利用跨站脚本攻击，攻击者可窃会话 Cookie 从而窃取网站用户的隐私。</p></blockquote><p>JSONP 的 <code>callback</code> 参数非常危险，他有两种风险可能导致 XSS</p><p>1、callback 参数意外截断js代码，特殊字符单引号双引号，换行符均存在风险。</p><p>2、callback 参数恶意添加标签（如 <code>&lt;script&gt;</code> ），造成 XSS 漏洞。</p><p>参考 <a href="http://blog.knownsec.com/2015/03/jsonp_security_technic/" target="_blank" rel="noopener">JSONP 安全攻防</a></p><h3 id="攻击步骤：-2"><a href="#攻击步骤：-2" class="headerlink" title="攻击步骤："></a>攻击步骤：</h3><ol><li>攻击构造出特殊的 URL ，其中包含恶意代码。</li><li>用户被诱导打开带有恶意代码的 URL，服务器端将恶意代码从 URL 中取出当做参数处理，然后返回给用户带有恶意代码的数据。</li><li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>已经在网站 “A” 登录了。网站 “A”有JSONP XSS。我们在网站 “B” 加载含XSS的链接，攻击成功。</p><p><a href="http://127.0.0.1:888/jsonpHtml" target="_blank" rel="noopener">http://127.0.0.1:888/jsonpHtml</a></p><h3 id="举个栗子：-2"><a href="#举个栗子：-2" class="headerlink" title="举个栗子："></a>举个栗子：</h3><p>在网站 “192.168.3.4:888” 登录设置了Cookie。</p><p><a href="http://192.168.3.4:888/jsonp/login" target="_blank" rel="noopener">http://192.168.3.4:888/jsonp/login</a></p><p><img src="https://upload.cc/i1/2019/11/12/OBglV1.png" alt="image"></p><p>然后在其他地方打开包括有恶意代码的链接。</p><p><a href="http://192.168.3.4:888/jsonp/xss?callback=aaaaaaaaa%3C/script%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E" target="_blank" rel="noopener">http://192.168.3.4:888/jsonp/xss?callback=aaaaaaaaa%3C/script%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E</a></p><p><img src="https://upload.cc/i1/2019/11/12/579cN0.png" alt="image"></p><p>网站“192.168.3.4:888”直接执行了恶意代码。</p><p>防御内容：</p><ul><li>callback 函数名只允许 <code>[</code>, <code>]</code>, <code>a-zA-Z0123456789_</code>, <code>$</code>, <code>.</code>，防止一般的 XSS，utf-7 XSS等攻击。</li><li>后端定义返回头类型</li></ul><h2 id="2-4-目录遍历漏洞"><a href="#2-4-目录遍历漏洞" class="headerlink" title="2.4 目录遍历漏洞"></a><span id="2.4">2.4 目录遍历漏洞</span></h2><h3 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ../、或者附加 ../ 的一些变形（如 ..\ 或 ..// 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>严格检查文件路径参数，限制在指定的范围。</li><li>严格限制文件路径参数，不允许用户控制文件路径相关的参数，限定文件路径范围。</li></ul><h3 id="业务漏洞"><a href="#业务漏洞" class="headerlink" title="业务漏洞"></a>业务漏洞</h3><p>一般业务漏洞是跟具体的应用程序相关，比如参数篡改（连续编号 ID / 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）等。</p><h2 id="2-5-SQL-注入"><a href="#2-5-SQL-注入" class="headerlink" title="2.5 SQL 注入"></a><span id="2.5">2.5 SQL 注入</span></h2><h3 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>SQL 注入攻击(SQL Injection)，被广泛用于非法获取网站控制权，是发生在应用程序的数据库层上的安全漏洞。 在设计不良的程序当中，忽略了对输入字符串中夹带的 SQL 指令的检查，那么这些夹带进去的指令就会被数据库误认为是正常的 SQL 指令而运行，从而使数据库受到攻击，可能导致数据被窃取、更改、删除，以及进一步导致网站被嵌入恶意代码、被植入后门程序等危害。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。</li><li>对进入数据库的特殊字符 ‘“&lt;&gt;&amp;*; 等进行转义处理，或编码转换。</li><li>确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为 int 型。</li><li>数据长度应该严格规定，能在一定程度上防止比较长的 SQL 注入语句无法正确执行。</li><li>网站每个数据层的编码统一，建议全部使用 UTF-8 编码，上下层编码不一致有可能导致一些过滤模型被绕过。</li><li>严格限制网站所用数据库账号的权限，给此用户仅提供能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</li><li>避免网站显示 SQL 错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</li></ul><h2 id="2-6-CSRF-跨站请求伪造"><a href="#2-6-CSRF-跨站请求伪造" class="headerlink" title="2.6 CSRF 跨站请求伪造"></a><span id="2.6">2.6 CSRF 跨站请求伪造</span></h2><h3 id="漏洞描述-5"><a href="#漏洞描述-5" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><p>跨站请求伪造(Cross-Site Request Forgery, CSRF)，恶意网站通过脚本向当前用户浏览器打开的其它页面的 URL 发起恶意请求，由于同一浏览器进程下 Cookie 可见性，导致用户身份被盗用，完成恶意网站脚本中指定的操作。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>CSRF漏洞修复方案主要思路有两类：</p><ul><li>验证请求是信任页面发起，这类修复方案有：<ul><li>在表单中填充一次性随机的 csrf token 防止攻击者伪造 form 表单进行 CSRF。同时将此串 token 置入 session，在后端再进行一次一致性校验。</li><li>referer 验证。</li></ul></li><li>验证请求是合法用户发起，这类修复方案有：<ul><li>验证码</li><li>密码验证</li><li>OTP 验证</li></ul></li></ul><p>更多：<br><a href="https://codepen.io/rvernagus/pen/xrKOXp" target="_blank" rel="noopener">https://codepen.io/rvernagus/pen/xrKOXp</a></p><p><a href="https://xss-game.appspot.com/level1" target="_blank" rel="noopener">https://xss-game.appspot.com/level1</a></p><p>@ 韦世裔</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-常见开发场景安全&quot;&gt;&lt;a href=&quot;#1-常见开发场景安全&quot; class=&quot;headerlink&quot; title=&quot;1. 常见开发场景安全&quot;&gt;&lt;/a&gt;1. 常见开发场景安全&lt;/h1&gt;&lt;h2 id=&quot;1-1-敏感信息使用场景&quot;&gt;&lt;a href=&quot;#1-1-敏感信息使用场景&quot; class=&quot;headerlink&quot; title=&quot;1.1 敏感信息使用场景&quot;&gt;&lt;/a&gt;1.1 敏感信息使用场景&lt;/h2&gt;&lt;p&gt; 敏感信息指用户的 身份证号、银行卡号、手机号 等身份信息。重要敏感信息的脱敏规范如下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;敏感信息类型&lt;/th&gt;
&lt;th&gt;展示规范&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;身份证&lt;/td&gt;
&lt;td&gt;显示前 1 位 + &lt;em&gt;(实际位数) + 后 1 位，如： 3&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;***&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;银行卡&lt;/td&gt;
&lt;td&gt;显示前 6 位 + &lt;em&gt;(实际位数) + 后 4 位，如：622575*****&lt;/em&gt;1496&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;手机号&lt;/td&gt;
&lt;td&gt;显示前 3 位 + &lt;strong&gt;** + 后 4 位，如：137**&lt;/strong&gt;9050&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈Kafka核心原理</title>
    <link href="http://yoursite.com/2019/08/24/technique-sharing/2019/%E6%B5%85%E8%B0%88Kafka%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/24/technique-sharing/2019/浅谈Kafka核心原理/</id>
    <published>2019-08-24T15:29:08.000Z</published>
    <updated>2020-03-27T02:15:35.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈Kafka核心原理"><a href="#浅谈Kafka核心原理" class="headerlink" title="浅谈Kafka核心原理"></a>浅谈Kafka核心原理</h1><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​    Kafka起初是由LinkedIn公司采用Scala语言开发的一个多分区、多副本且基于Zookeeper协调的分布式消息系统，现已捐献给Apache基金会。目前Kafka已经被定为为一个分布式流式处理平台，它以高吞吐、可持久化、可水平拓展、支持流数据处理等多种特性而被广泛使用。</p><p>​    Kafka之所以受到越来越多的青睐，与它所”扮演“的三大角色是分不开的：</p><p>​    <strong>消息系统：</strong>作为消息中间件，具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费等功能。</p><p>​    <strong>存储系统：</strong>Kafka把消息持久化到磁盘，有效降低了数据丢失的风险。也正是得益于Kafka的消息持久化功能和多副本机制，我们可以把Kafka作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。</p><p>​    <strong>流式处理平台：</strong></p><a id="more"></a><h4 id="消息队列（Message-Queue）使用场景"><a href="#消息队列（Message-Queue）使用场景" class="headerlink" title="消息队列（Message Queue）使用场景"></a>消息队列（Message Queue）使用场景</h4><h5 id="·-解耦："><a href="#·-解耦：" class="headerlink" title="·  解耦："></a>·  解耦：</h5><h6 id="未使用MQ的耦合场景："><a href="#未使用MQ的耦合场景：" class="headerlink" title="未使用MQ的耦合场景："></a>未使用MQ的耦合场景：</h6><p>​    现有A服务在自己代码中调用B服务的接口和C服务的接口发送数据</p><p><img src="/images/1570349327919.png" alt=""></p><p>​        此时新增D服务也需要A服务发送数据，则需要A服务在自己代码里修改，发送数据给D服务，紧接着C服务又说不需要A服务给自己发送数据了</p><p><img src="/images/pic/1570353961427.png" alt=""></p><p>​        负责A服务的人还得考虑，如果调用的B服务挂了怎么办？如果D服务访问超时怎么办？由于A服务产生了比较关键的数据，许多服务需要A服务发送该数据过来，这也导致了A服务与其他服务的严重耦合。</p><p><strong>使用MQ解耦场景：</strong></p><p><img src="/images/1570354023234.png" alt=""></p><p>我们自己使用的场景</p><p><img src="/images/1571154041749.png" alt=""></p><h5 id="·-异步："><a href="#·-异步：" class="headerlink" title="·  异步："></a>·  异步：</h5><p><strong>未使用MQ的同步高延时请求场景：</strong></p><p>​    现有一用户请求，调用服务A接口</p><p><img src="/images/1570355189888.png" alt=""></p><p>​        我们来计算一下，服务A先是在自己本地执行SQL，然后调用了服务B、服务C和服务D的接口，4个步骤下来，需要耗时的总时长为970ms。用户通过浏览器发起请求，等待1秒才得到响应，几乎不可接受。一般对于用户的直接的操作，要求是每个请求都必须在200ms内完成，对用户几乎是无感知的。</p><p><strong>使用MQ进行异步化：</strong></p><p><img src="/images/1570358228532.png" alt=""></p><p>​    使用MQ进行异步化之后，此时用户发起请求调用服务A的总耗时变成了20+5=25ms。 </p><h5 id="·-削峰："><a href="#·-削峰：" class="headerlink" title="·  削峰："></a>·  削峰：</h5><p><strong>未使用MQ削峰大量用户请求场景：</strong></p><p><img src="/images/1570376006119.png" alt=""></p><p><strong>使用MQ进行削峰场景：</strong></p><p><img src="/images/1570377103963.png" alt=""></p><p>​        MQ中每秒有2000个请求进来，就只有1000个请求出去，结果就是导致在高峰期（假设1个小时）可能有几十万甚至上百万的请求积压在MQ中，但是高峰期过后，每秒钟只有20个请求，系统还是会按照每秒1000个请求的速度处理，差不多1个多小时就可以把积压的上百万条消息给处理掉，就没有积压了。</p><h4 id="引入MQ后可能存在的一些问题"><a href="#引入MQ后可能存在的一些问题" class="headerlink" title="引入MQ后可能存在的一些问题"></a>引入MQ后可能存在的一些问题</h4><p><strong>系统可用性降低：</strong>系统引入的外部依赖越多，越容易挂掉。拿上图举例，MQ一旦故障，A服务没发发送消息到MQ了，然后BCD服务也没发消费到消息了，整个系统就崩溃了，没法运转了。</p><p><strong>系统复杂性提高：</strong>消息丢失，消息重复，消息顺序性问题如何保证？例如A服务本来只需要给B服务发送一条数据就可以了，结果因为A服务和MQ之间协调出现问题，A服务不小心把同一条数据发了两次到MQ中给B服务消费，导致B服务插入两条一模一样的数据。</p><p><strong>一致性问题：</strong>如A服务处理完了直接返回成功了，都认为这个请求成功了，但是要BCD服务都写库成功才是真正的成功，如果其中有一个写库失败了，这样数据就不一致了。</p><h4 id="典型的Kafka体系架构"><a href="#典型的Kafka体系架构" class="headerlink" title="典型的Kafka体系架构"></a>典型的Kafka体系架构</h4><p><img src="/images/1570434633144.png" alt=""></p><p>先简单介绍下Kafka中的术语：</p><p>（1）Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。</p><p>（2）Consumer：消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。</p><p>（3）Broker：服务代理节点。可以将其看做一台服务器上部署的一台Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成了一个Kafka集群。</p><p>（4）Topic：主题。Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题，而消费者负责订阅主题并进行消费。</p><p>（5）Partition：分区。一个topic可以分为多个partition，每个partition是一个有序的队列。</p><p>（6）offset：偏移量。同一个topic下的不同partition包含的消息是不同的，partition在存储层面可以看作一个可追加的日志文件，消息在被追加到分区日志的时候都会分配一个特定的偏移量（offset）。offset是消息在分区中的唯一标识，Kafka通过它来保证消息在分区中的顺序性，不过offset并不跨越分区，也就是说，Kafka保证的是分区有序而不是主题有序。</p><p>如图，某个主题中有3个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka中的分区可以分布在不同的broker上，也就是说，一个topic的数据可以分布在多个broker上</p><p><img src="/images/1570435400123.png" alt=""></p><p>​    Kafka之所以将topic分成多个分区，分布在不同的broker上，就是提供负载均衡的能力，也就是实现系统的高伸缩性。</p><h4 id="Kafka多副本机制"><a href="#Kafka多副本机制" class="headerlink" title="Kafka多副本机制"></a>Kafka多副本机制</h4><p>​        Kafka为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是“一主多从”的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中从新选举新的leader副本对外提供服务。Kafka通过多副本机制实现 了故障的自动转移，当Kafka集群中某个新的broker失效时，仍然能保证服务可用。</p><p><img src="/images/1570458914836.png" alt=""></p><p>​        如图所示，Kafka集群中有3个broker，某个topic中有3个分区，且副本因子（即副本个数）也为3，如此每个分区便有1个leader副本和2个follower副本。生产者和消费者只与leader副本进行交互，而follower副本只负责消息的同步，很多时候follower副本中的消息相对于leader而言会有一定的滞后。</p><p>​        分区中的所有副本统称为 <strong>AR</strong>（Assigned Replicas）。所有与leader副本保持一定程度的同步的副本（包括leader副本在内）组成 <strong>ISR</strong>（In-Sync Replicas），ISR集合是AR集合的一个子集。消息会先发送到leader副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间内follower副本相对于leader副本会有一定程度的滞后。与leader副本同步滞后过多的副本（不包括leader副本）组成<strong>OSR</strong>（Out-of-Sync Replicas），由此可见，AR = ISR + OSR。在正常情况下，所有的follower副本都应该与leader副本保持一定程度的同步，即 AR = ISR，OSR集合为空。</p><p>​        leader副本负责维护和跟着ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果OSR集合中所有的follower副本“追上”了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader。</p><p>​        ISR与HW和LEO也有紧密的关系。HW是High Watermark的缩写，俗称高水位，它标识了一个特定的消息偏移量（offset），消息只能拉取到这个offset之前的消息。</p><p><img src="/images/1570463237141.png" alt=""></p><p>​        如上图所示，表示一个分区中各种偏移量的说明。它代表一个日志文件，这个日志文件中有9条消息，第一条消息的offset为0，最后一条消息的offset为8,offset为9代表下一条待写入的消息的位置。日志文件的HW为6，表示消费者只能拉取到offset在0至5之间的消息，而offset为6的消息对消费者而言是不可见的。<strong>LEO</strong>是Log End Offset的缩写，标识当前日志文件下一条待写入的消息的offset。分区ISR集合中的每个副本都会维护自身的的LEO，而集合中最小的LEO即为分区的HW，对消费者而言，只能消费HW之前的消息。下面举个例子来更好的说明ISR集合与HW和LEO之间的关系：</p><p><img src="/images/1570466677914.png" alt=""></p><p><img src="/images/1570466932355.png" alt=""></p><p>​    在同步过程中，不同的follower副本的同步效率也不尽相同。</p><p><img src="/images/1570467298346.png" alt=""></p><p>​        在某一时刻，follower1完全跟上了leader副本而follower2只同步到了消息3，如此leader副本的LEO为5，follower1的LEO为5，follower2的LEO为4，那么当前分区的HW取最小值4，此时消费者可以消费到offset为0至3之间的消息。</p><p><img src="/images/1570467513662.png" alt=""></p><p>​        所有的消息都成功写入了消息3和消息4，整个分区的HW和LEO都变为5，因此消费者可以消费到offset为4的消息了。由此可见，Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的follower副本都复制完，这条消息才会被确认为已成功提交，这种复制方式极大地影响了性能。而在异步复制方式下，follower副本异步地从leader副本中复制数据，数据只要被leader副本写入就被认为已经成功提交了。在这种情况下，如果follower副本都还没有复制完而落后于leader副本，突然leader副本宕机，则会造成数据丢失。Kafka使用的这种ISR的方式则有效地权衡了数据可靠性和性能之间的关系。</p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>​    一个正常的生产逻辑为以下几个步骤：配置客户端参数，创建相应的生产者实例，构建待发送的消息，发送消息。</p><p>​    客户端参数配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br></pre></td></tr></table></figure><p>​        bootstrap.servers：该参数用来指定生产者客户端连接Kafka集群所需的broker地址清单，格式为host1:port1,host2:port2,这里不一定需要配置所以的broker地址，因为生产者会从给定的broker里找到其他broker信息。但至少配置2个以上，当其中一个宕机了，能够保证生产者仍然能连接到kafka集群上。key.serializer和value.serializer指定序列化操作的序列化器。这三个参数都没有默认值，所以在配置生产者客户端时是必填的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties.put(<span class="string">"acks"</span>,<span class="string">"0"</span>);</span><br></pre></td></tr></table></figure><p>​        acks，可取值0，1，-1，这个参数是用来指定分区中必须要有多少个副本接收到这条消息，之后生产者才会认为这条消息写入成功。默认值为1，生产者发送消息之后，只要分区的leader副本成功写入消息，那么它就会收到来自服务端的成功响应。如果消息写入leader副本并返回成功响应给生产者，且在被其他follower副本拉取前leader副本崩溃了，那么此时消息还是会丢失，因为新选举的leader副本中并没有这条对应的消息。acks=0，生产者发送消息之后不需要等待任何服务端的响应。这样可以达到最大的吞吐量，但是也存在问题，如果在消息发送到写入Kafka的过程中出现某些异常，导致Kafka没有接收到这条消息，那么生产者也不知道，消息也就丢失了。acks=-1或acks=all，生产者在消息发送之后，需要等待ISR中的所有副本都成功写入消息之后才能够收到来自服务端的成功响应。设置成-1可以达到最强的可靠性，但这并不意味着消息就一定可靠，因为如果ISR中可能只有leader副本，这样就退化成acks=1的情况了。所以acks默认为1，是消息可靠性和吞吐量之间的一个折中方案。</p><p>​    构建消息，即创建ProducerRecord对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerRecord</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic; <span class="comment">//主题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer partition; <span class="comment">//分区号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key; <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value; <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timestamp; <span class="comment">//消息的时间戳</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        其中topic和partition字段分别指代消息要发往的主题和分区号。value是指消息体，即你要发送的内容。key是用来指定消息的键，它不仅是消息的附加信息，还可以用来计算分区号进而可以让消息发往特定的分区。消息以主题为单位进行归类，而这个key可以让消息再进行二次归类，同一个key的消息会被划分到同一个分区中。说到key，这里如果要保证消息的顺序性，可以把需要保证消息消费顺序的指定同一个key。消息在通过send()方法发往broker的过程中，有可能需要经过拦截器、序列化器和分区器。拦截器一般不是必需的，但序列化器是必需的。生产者需要用序列化器把对象转换成字节数组才能通过网络发送给Kafka。</p><p><img src="/images/1570549324737.png" alt=""></p><p>​        如果在构造消息时在ProducerRecord中指定了partition字段，那么就不需要分区器的作用，如果没有指定，那么就需要依赖分区器根据key这个字段来计算partition的值。在默认分区器的方法中，如果key部位null，那么默认的分区器会对key进行哈希，最终根据等到的哈希值来计算分区号，有相同key的消息会被写入同一个分区。如果key为null，那么消息将会以轮询的方式发往主题内的各个可用分区。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p><strong>消费者</strong>(Consumer)：负责订阅Kafka中的主题（topic），并且从订阅的主题上拉取消息。</p><p><strong>消费组</strong>（Consumer Group）：每个消费者都有一个对应的消费组，消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。</p><p><img src="/images/1570634727822.png" alt=""></p><p>​        如上图所示，某个主题共有3个分区，有两个消费组A和B都订阅了这个主题。按照Kafka默认的规则，消费组A中每个消费者分配到1个分区，消费组B中C3分配到两个分区，C4分配到1个分区。两个消费组之间互不影响，每个消费组只能消费所分配到的分区中的消息，换言之，每一个分区只能被一个消费组中的一个消费者所消费。消费组是一个逻辑上的概念，它将属于同一组的消费者归为一类，每一个消费者只隶属于一个消费组，课通过消费者客户端参数group.id来配置消费组。</p><p>对于消息中间件一般有两种消息投递模式：</p><p><strong>点对点（P2P，Point-to-Point）模式</strong>：基于队列，生产者发送消息到队列，消费者从队列中接收消息。一般是一对一。</p><p><strong>发布/订阅（Pub/Sub）模式</strong>：主题作为消息传递的中介，生产者将消息发布到某个主题，消费者可主题中订阅消息。该模式在消息的一对多广播时采用。</p><p>​    Kafka同时支持两种消息投递模式，而这正得益于它的消费者与消费组模型设计：</p><ul><li>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均匀的投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式。</li><li>如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式。</li></ul><p>​        一个正常的<strong>消费逻辑步骤</strong>：配置消费者客户端参数，创建消费者实例，订阅主题，拉取消息并消费，提交消费位移等。</p><p>​        配置必要的消费者客户端参数，有4个参数是必填的。同生产者一样，bootstrap.servers、key.deserializer和value.deserializer三个参数是必配的，只不过key、value的变成了反序列化器，还有一个group.id配置消费者隶属的消费组名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"goupA"</span>);</span><br></pre></td></tr></table></figure><p>​        消息的消费一般有两种模式：推模式——是服务端主动将消息推送给消费者，拉模式——是消费者主动向服务端发起请求来拉取消息。Kafka中的消费基于拉模式的。Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用poll（）方法，返回所订阅的主题（分区）上的一组消息。</p><p>​    消费者消费到的每条消息类型为ConsumerRecord，这个和生产者发送的消息类型ProducerRecord对应，不过字段更丰富：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRecord</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic; <span class="comment">//消息所属主题名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition; <span class="comment">//消息所属分区编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> offset; <span class="comment">//消息所属分区偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp; <span class="comment">//时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimestampType timestampType; <span class="comment">//两种类型，CreateTime消息创建的时间戳，   //LogAppendTime消息追加到日志的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value; <span class="comment">//一般业务应用所要读取的值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>位移提交</strong></p><p>​        Kafka中每条消息都有唯一的offset，表示该消息处在的partition中的位置，叫作“偏移量”。消费者中也有一个offset概念，表示消费者消费到分区中某个消息所在的位置，我们把它与消息的区分开，可叫作“位移”。在旧消费者客户端（用Scala编写的客户端版本）中，消费位移是保存在ZooKeeper中的，而在新消费者客户端（用Java编写的客户端）中，消费位移存储在Kafka内部的主题_consumer_offsets中。这里将消费位移存储起来（持久化）的动作称为“提交”。</p><p><img src="/images/1570640588699.png" alt=""></p><p>​        当前消费者消费的位移为X，但它需要提交的消费位移不是X，而是X+1，它表示下一条需要拉取的消息的位置。在Kafka中默认的消费位移提交方式是自动提交，提交时间默认为5秒，可通过auto.commit.interval.ms配置。</p><p>​        自动提交位移的方式非常简便，但是也会带来重复消费和消息丢失的问题。</p><p>​        假设刚刚提交完一次消费位移，然后拉取一批消息进行消费，在下一次自动位移提交之前，消费者崩了，那么等消费者恢复再来消费消息的时候又得从上一次位移提交的地方重新开始，这样便发生了重复消费的现象。我们可以通过减小位移提交时间间隔来减小重复消息的窗口，但这样并不能避免重复消费的发送，而且也会使得位移提交更加频繁。这里我们可以在拿数据写库前，根据主键去库中查询，如果已有，就update一下好了，若是写入redis，用set存储，去重。</p><p>@by 罗云    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;浅谈Kafka核心原理&quot;&gt;&lt;a href=&quot;#浅谈Kafka核心原理&quot; class=&quot;headerlink&quot; title=&quot;浅谈Kafka核心原理&quot;&gt;&lt;/a&gt;浅谈Kafka核心原理&lt;/h1&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;​    Kafka起初是由LinkedIn公司采用Scala语言开发的一个多分区、多副本且基于Zookeeper协调的分布式消息系统，现已捐献给Apache基金会。目前Kafka已经被定为为一个分布式流式处理平台，它以高吞吐、可持久化、可水平拓展、支持流数据处理等多种特性而被广泛使用。&lt;/p&gt;
&lt;p&gt;​    Kafka之所以受到越来越多的青睐，与它所”扮演“的三大角色是分不开的：&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;消息系统：&lt;/strong&gt;作为消息中间件，具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，Kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费等功能。&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;存储系统：&lt;/strong&gt;Kafka把消息持久化到磁盘，有效降低了数据丢失的风险。也正是得益于Kafka的消息持久化功能和多副本机制，我们可以把Kafka作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可。&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;流式处理平台：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小程序开发技术框架选型</title>
    <link href="http://yoursite.com/2019/06/24/technique-sharing/2019/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/06/24/technique-sharing/2019/小程序框架选型/</id>
    <published>2019-06-24T15:29:08.000Z</published>
    <updated>2020-03-25T10:24:48.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序开发技术框架选型"><a href="#小程序开发技术框架选型" class="headerlink" title="小程序开发技术框架选型"></a>小程序开发技术框架选型</h1><p>标签： 小程序</p><hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>1、业务：公司扩展业务，需要同时开发小程序、公众号、H5移动的等多个平台的服务，在功能、UI交互上基本一致。</li><li>2、团队：前端开发团队，技术栈上基本都熟悉Vue框架，原生小程序框架熟悉了解的几乎没有，除了专门写小程序的新同事。</li><li>3、成本考量：若为单独为小程序、公众好、H5各开发一套代码，开发时间<em>3；后期维护成本</em>3，还得得专门找一个熟悉小程序的人员才能进行，不利于推广，调用整个前端团队能力<br>基于以上考量，迫切需要统一技术框架，能够同时支持兼容多平台的高可用框架。<a id="more"></a></li></ul><h1 id="技术框架选型"><a href="#技术框架选型" class="headerlink" title="技术框架选型"></a>技术框架选型</h1><p>前文说到，开发团队都熟悉Vue框架，框架选型必须基于Vue这个前提。经过一番搜索调查，找到基于Vue语言且支持小程序、H5等多平台的的技术框架有<a href="http://mpvue.com/" target="_blank" rel="noopener">mpvue</a>、<a href="https://uniapp.dcloud.io/" target="_blank" rel="noopener">nui-app</a>两个。最终框架也将在这两个中选择，那么选择哪一个好呢？<br>与但与开发的同事一起对其研究分析，定下评判唯独与标准，最后汇总确认选择。<br>首先定下<strong>评分标准</strong>：</p><ul><li>5分完美 </li><li>4分些许不足总体不影响</li><li>3分一般（勉强能用）</li><li>2分缺陷严重</li></ul><p><strong>评判维度</strong>：</p><ul><li>1、gitHub评分</li><li>2、社区的活跃程度（官方是否有维护、持续更新，与用户交互）</li><li>3、不同平台兼容性（小程序、H5的兼容性、移植性）</li><li>4、是否有组件库、原生api、第三方插件的支持</li><li>5、是否有公司／用户使用该框架并投入使用</li></ul><p>根据评判维护评分分析汇总最终得出：</p><p>1、mpvue</p><ul><li>美团官方推出框架，推出时间早，在gitHub上有18500+🌟；</li><li>基于Vue、Vue-cli2开发，支持Vue语法；</li><li>最新代码更新已经是N久以前，市区活跃度低，提问、评论寥寥无几，且提问并无多少答复；</li><li>官方推出的使用案例，基本上都是小程序，使用手册也基本上没有H5相关。只能在gitHub上找到同时支持小程序、H5案例，还是私人自己改造的；</li><li>没有组件库支持，需要自己引入第三方UI（同事在demo中引用出现样式不生效等兼容性问题）</li></ul><p>2、uni-app</p><ul><li><a href="https://github.com/dcloudio" target="_blank" rel="noopener">dcloudio</a>团队开发推出的框架，在gitHub上有120000+🌟，推出时间晚于mpvue；</li><li>基于Vue、Vue-cli3开发，支持Vue语法；</li><li>社区活跃度高，在查看时候仍然有不少在社区上的交互，有微信交流群，官方会有解答更新；</li><li>有属于自己官方维护的组件库、有自己的第三方插件市场（官方维护兼容性高）；</li><li>第三方参与度高，贡献第三次插件的积极性强；</li><li>官方推出的使用案例不仅有小程序，还有H5。有CSDN这些大厂使用；</li><li>有同事朋友使用过，一年多了没有出现明显漏洞；</li></ul><p>综上所述，mpvue缺陷较多，官方甚至已经停止更新维护了；uni-app生机勃勃，充满活力，更加适合使用。</p><p>@by 刘荣杰</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;小程序开发技术框架选型&quot;&gt;&lt;a href=&quot;#小程序开发技术框架选型&quot; class=&quot;headerlink&quot; title=&quot;小程序开发技术框架选型&quot;&gt;&lt;/a&gt;小程序开发技术框架选型&lt;/h1&gt;&lt;p&gt;标签： 小程序&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1、业务：公司扩展业务，需要同时开发小程序、公众号、H5移动的等多个平台的服务，在功能、UI交互上基本一致。&lt;/li&gt;
&lt;li&gt;2、团队：前端开发团队，技术栈上基本都熟悉Vue框架，原生小程序框架熟悉了解的几乎没有，除了专门写小程序的新同事。&lt;/li&gt;
&lt;li&gt;3、成本考量：若为单独为小程序、公众好、H5各开发一套代码，开发时间&lt;em&gt;3；后期维护成本&lt;/em&gt;3，还得得专门找一个熟悉小程序的人员才能进行，不利于推广，调用整个前端团队能力&lt;br&gt;基于以上考量，迫切需要统一技术框架，能够同时支持兼容多平台的高可用框架。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目国际化方案</title>
    <link href="http://yoursite.com/2019/03/24/technique-sharing/2019/%E9%A1%B9%E7%9B%AE%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/24/technique-sharing/2019/项目国际化方案/</id>
    <published>2019-03-24T15:29:08.000Z</published>
    <updated>2020-03-25T10:24:48.189Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>应泰方要求，运营系统、网上商城以及移动端服务平台等项目都要做国际化，支持英文、泰文等多国语言。故研讨国际化方案对项目进行国际化改造。</p><a id="more"></a><h2 id="1-后端"><a href="#1-后端" class="headerlink" title="1.后端"></a>1.后端</h2><p><strong>关键：使用java.util.Locale类判断地区，处理国际化差异</strong><br>| 项目               | 解决方案                                                     |<br>| —————— | :———————————————————– |<br>| 静态配置文件       | 处理成zh_CN.properties（中文需要处理ASCII编码格式）和th_TH.properties版本，使用java.util.ResourceBundle根据地区读取 |<br>| 错误提示           | 中文翻译成泰文，处理成中文和泰文2个错误枚举类，根据地区选择一个枚举类 |<br>| 日期               | 使用java.util.DateFormat类及其子类SimpleDateFormat根据地区处理 |<br>| 数字、货币、百分比 | 使用java.util.NumberFormat类根据地区处理                     |</p><h2 id="2-前端"><a href="#2-前端" class="headerlink" title="2.前端"></a>2.前端</h2><p><strong>关键：i18n.properties</strong><br>| 项目             | 解决方案                                                     |<br>| —————- | :———————————————————– |<br>| 配置文件         | 配置<em>_i18n.properties 国际字典，用以多国语言翻译             |<br>| 静态文字         | 使用</em>i18n国际化插件匹配字典重新赋值（预估工作量相当大）      |<br>| 动态数据中的文字 | 后端处理后发送到前端                                         |<br>| 样式             | 不同语言文案长度不一样造成的样式错乱，对样式要做适配性修改（预估工作量相当大），先统一处理英文版本，再适配其它语言 |<br>| 图片             | 例如帮助指引等，替换泰文版新图                               |<br>| 第三方服务SDK    | 运营系统中暂时没有                                           |<br>| 数字、货币单位   | 使用阿拉伯数字，货币单位使用฿，要增加货币格式化工具函数处理  |<br>| 日期、时间       | 使用泰国当地时间                                             |</p><h3 id="国际化插件选择"><a href="#国际化插件选择" class="headerlink" title="国际化插件选择"></a><strong>国际化插件选择</strong></h3><p>&emsp;&emsp;前端处理国际化的插件总类繁多，不同的框架各有不同。比如vue有vue-i18n，jquery有 jquery-i18n，构建层面有i18n-webpack-plugin等等。且不同国际化插件语法各不相同，学习起来有一定的时间成本，维护起来也不方便。对于公司来说，项目肯定不止一个，使用的技术框架也不尽相同，如果能有一个通用、易用、好用的的国际化插件统一使用维护那是再好不过了。<br>&emsp;&emsp;既然是通用，便要支持各种技术框架，类似vue-i18n这些配合指定框架的插件便不大适用了。当然，直接vue + vue-i18n这样的固定搭配也是可以的。网传较多的通用国际化插件jQuery.i18n.properties，试用了一下，不是说不好用不能用，只是它依赖JQuery，在页面加载中如果有多处页面引用JQuery，会有JQuery重新加载导致jQuery.i18n被覆盖不能正常试用的情况，这就不大理想了。而且，可能有一些公司项目就不引用JQuery插件，总不能为此强迫人家吧。后来查找发现，di18n-translate插件也可以满足需求，查看了源码并不依赖JQuery等其它插件，纯原生语法编写。使用也是简单。</p><h2 id="di18n-translate"><a href="#di18n-translate" class="headerlink" title="di18n-translate"></a>di18n-translate</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>di18n-translate是基于原生js进行开发的一个函数js，不依赖于某一个构建工具或者某一个框架，即使是原生html也可以使用，在兼容性方面是比较能满足我们的要求的。详情可查看<a href="https://github.com/CommanderXL/di18n-translate" target="_blank" rel="noopener">https://github.com/CommanderXL/di18n-translate</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install di18n-translate</span><br></pre></td></tr></table></figure><h3 id="使用demo"><a href="#使用demo" class="headerlink" title="使用demo"></a>使用demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const DI18n &#x3D; require(&#39;di18n-translate&#39;)</span><br><span class="line">  const di18n &#x3D; new DI18n(&#123;</span><br><span class="line">    locale: &#39;en&#39;,       &#x2F;&#x2F; 语言环境</span><br><span class="line">    isReplace: false,   &#x2F;&#x2F; 是否开启运行时功能(适用于没有使用任何构建工具开发流程)</span><br><span class="line">    messages: &#123;         &#x2F;&#x2F; 语言映射表</span><br><span class="line">      en: &#123;</span><br><span class="line">        你好: &#39;Hello, &#123;xl&#125;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      zh: &#123;</span><br><span class="line">        你好: &#39;你好, &#123;xl&#125;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>di18n有2个翻译方法: $t, $html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 带参数</span><br><span class="line">  di18n.$t(&#39;你好&#39;, &#123;person: &#39;xl&#39;&#125;)    </span><br><span class="line">  &#x2F;&#x2F; 输出 Hello, xl</span><br></pre></td></tr></table></figure><p>字符串拼接的dom中使用${locale}表示语言环境，$t()标识需要翻译的字段，用法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let tpl &#x3D; &#39;&lt;div class&#x3D;&quot;wrapper $&#123;locale&#125;&quot;&gt;&#39; +</span><br><span class="line">    &#39;&lt;img src&#x3D;&quot;&#x2F;images&#x2F;$&#123;locale&#125;&#x2F;test.png&quot;&gt;&#39; +</span><br><span class="line">    &#39;&lt;p&gt;$t(&quot;你好&quot;)&lt;&#x2F;p&gt;&#39; + </span><br><span class="line">    &#39;&lt;&#x2F;div&gt;&#39;</span><br><span class="line"></span><br><span class="line">let str &#x3D; di18n.$html(tpl)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串替换后输出字符串str: </span><br><span class="line">  &lt;div class&#x3D;&quot;wrapper en&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;&#x2F;images&#x2F;en&#x2F;test.png&quot;&gt;</span><br><span class="line">    &lt;p&gt;Hello&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最后再将这个dom字符串传入到页面当中去</span><br><span class="line">document.querySelector(&#39;.box-wrapper&#39;).innerHTML &#x3D; str</span><br></pre></td></tr></table></figure><h1 id="运营系统国际化改造实战"><a href="#运营系统国际化改造实战" class="headerlink" title="运营系统国际化改造实战"></a>运营系统国际化改造实战</h1><p>相信现在除了最传统的web前端项目外，大多数的前端开发都采用组件化的模式，比如小编公司使用的polymer、Vue框架，都封装有大量的组件方便开发使用。在进行国际化时候，为尽可能的的不改变开发模式且减少工作量，将国际化翻译的东西封装在组件的最底层，在组件内部进行改造。</p><h2 id="以运营系统为例："><a href="#以运营系统为例：" class="headerlink" title="以运营系统为例："></a>以运营系统为例：</h2><ul><li>地址栏添加language=‘zh‘属性用以切换区分语言，如<a href="http://127.0.0.1/demo?language=‘zh‘" target="_blank" rel="noopener">http://127.0.0.1/demo?language=‘zh‘</a></li><li>配置语言字典，实例化di18n函数对象。（方法写在o-base-behavior.html中，方便调用）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const di18n &#x3D; new DI18n(&#123;</span><br><span class="line">    locale: LOCALE,</span><br><span class="line">    isReplace: true,   &#x2F;&#x2F; 开启运行时</span><br><span class="line">    messages: &#123;</span><br><span class="line">        en: En,</span><br><span class="line">        zh: Zh</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">English.js</span><br><span class="line">const En &#x3D; &#123;</span><br><span class="line">    搜索: &#39;search&#39;,</span><br><span class="line">    重置: &#39;reset&#39;，</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">Chinese.js</span><br><span class="line">const En &#x3D; &#123;</span><br><span class="line">    搜索: &#39;搜索&#39;,</span><br><span class="line">    重置: &#39; 重置&#39;,</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">o-base-behaviors.html </span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;node_modules&#x2F;di18n-translate&#x2F;dist&#x2F;di18n.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;assets&#x2F;i18n&#x2F;Chinese.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;assets&#x2F;i18n&#x2F;English.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;assets&#x2F;i18n&#x2F;di18n.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    OBaseBehavior &#x3D; &#123;</span><br><span class="line">        properties:&#123;...&#125;,</span><br><span class="line">         &#x2F;**</span><br><span class="line">   * 国际化方法</span><br><span class="line">   * @param arr</span><br><span class="line"> *&#x2F;</span><br><span class="line"> i18n: function(name) &#123;</span><br><span class="line">       const temp &#x3D; di18n.$t(name)</span><br><span class="line">       if (temp &amp;&amp; temp !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">              return di18n.$t(name)</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">              return name</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">h-crud-search.html</span><br><span class="line">&lt;link  rel&#x3D;&quot;import&quot; href&#x3D;&quot;o-base-behavior.html&quot;&gt;</span><br><span class="line">&lt;link  rel&#x3D;&quot;import&quot; href&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;bower_components&#x2F;paper-button&#x2F;paper-button.html&quot;&gt;</span><br><span class="line">&lt;dom-module id&#x3D;&quot;h-crud-search&quot;&gt;</span><br><span class="line">    &lt;template&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;paper-button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn btn-primary float-l&quot; data-args&#x3D;&#39;&#123;&quot;resetPaging&quot;:true&#125;&#39;</span><br><span class="line">                          on-click&#x3D;&quot;_search&quot;&gt;[[i18n(&#39;搜索&#39;)]]</span><br><span class="line">            &lt;&#x2F;paper-button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;dom-module&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Polymer(&#123;</span><br><span class="line">        is: &#39;h-crud-search&#39;,</span><br><span class="line">        behaviors: [OBaseBehavior], &#x2F;&#x2F;引入公共behavior，就可以使用i18n方法进行字符串替换</span><br><span class="line">     properties: &#123;...&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">test.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&quot;import&quot; href&#x3D;&quot;h-crud-search.html&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h-crud-search&gt;&lt;&#x2F;h-crud-search&gt;</span><br><span class="line">&lt;!--中英文切换测试--&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;html-test.html?language&#x3D;en&quot;&gt;en&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;html-test.html?language&#x3D;zh&quot;&gt;zh&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>注意事项： 在组件里面使用i18n方法时，一定要记得引入OBaseBehavior这个公共方法实例化对象，不然i18n会转换失败。</li></ul><h2 id="Vue项目使用di18n-translate"><a href="#Vue项目使用di18n-translate" class="headerlink" title="Vue项目使用di18n-translate"></a>Vue项目使用di18n-translate</h2><p><strong>先进行全局注册：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">main.js</span><br><span class="line">window.LOCALE &#x3D; &#39;en&#39;</span><br><span class="line">const language &#x3D; localStorage.getItem(&#39;language&#39;) &#x2F;&#x2F; 进行语言切换的时候用到</span><br><span class="line">if(language) &#123;</span><br><span class="line">  window.LOCALE &#x3D; language</span><br><span class="line">&#125;</span><br><span class="line">const DI18n &#x3D; require(&#39;di18n-translate&#39;)</span><br><span class="line">const di18n &#x3D; new DI18n(&#123;</span><br><span class="line">  locale: LOCALE,       &#x2F;&#x2F; 语言环境</span><br><span class="line">  isReplace: false,   &#x2F;&#x2F; 是否进行替换(适用于没有使用任何构建工具开发流程)</span><br><span class="line">  messages: &#123;         &#x2F;&#x2F; 语言映射表</span><br><span class="line">    en: &#123;</span><br><span class="line">      你好: &#39;Hello&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    zh: &#123;</span><br><span class="line">      你好: &#39;你好&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.prototype.di18n &#x3D; di18n</span><br><span class="line">Vue.prototype.i18n &#x3D; function (name) &#123; &#x2F;&#x2F;封装一个全局方法，可以在任何vue文件里面进行字符串替换</span><br><span class="line">  const temp &#x3D; di18n.$t(name)  &#x2F;&#x2F; 封装翻译方法</span><br><span class="line">  if (temp &amp;&amp; temp !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    return di18n.$t(name)</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    return name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">18n.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;i18n(&#39;你好&#39;)&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;!--中英文切换测试--&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;changeLanguage(&#39;en&#39;)&quot;&gt;en&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;changeLanguage(&#39;zh&#39;)&quot;&gt;zh&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;i18n&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        title: this.i18n(&#39;飞飞&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      changeLanguage (language) &#123;</span><br><span class="line">        localStorage.setItem(&#39;language&#39;,language) &#x2F;&#x2F;将语言放到localStorage里面，这样下次进来可以直接切换到当前选择的语言</span><br><span class="line">        this.$router.go(0)   &#x2F;&#x2F; 进行页面刷新</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>组件化的代码在底层组件的基础上进行国际化，可以最大程度上减少工作量。从调研结果来看，使用di18n-translate，是可行的。</p><p>by @刘荣杰 @吴丽娅</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;应泰方要求，运营系统、网上商城以及移动端服务平台等项目都要做国际化，支持英文、泰文等多国语言。故研讨国际化方案对项目进行国际化改造。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iplas" scheme="http://yoursite.com/tags/iplas/"/>
    
      <category term="多语言" scheme="http://yoursite.com/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="i18n" scheme="http://yoursite.com/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>Webpack介绍</title>
    <link href="http://yoursite.com/2019/01/24/technique-sharing/2019/Webpack%20Study/"/>
    <id>http://yoursite.com/2019/01/24/technique-sharing/2019/Webpack Study/</id>
    <published>2019-01-24T15:29:08.000Z</published>
    <updated>2020-03-27T02:15:35.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack-学习文档"><a href="#Webpack-学习文档" class="headerlink" title="Webpack 学习文档"></a>Webpack 学习文档</h1><a id="more"></a><blockquote><p>推荐资料：</p><ul><li><a href="https://segmentfault.com/q/1010000008058766" target="_blank" rel="noopener">gulp和webpack究竟有什么区别？</a></li><li><a href="https://www.qingtingip.com/h_199804.html" target="_blank" rel="noopener">Gulp和Webpack的基本区别</a></li><li><a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">Webpack中文文档</a></li><li><a href="https://www.cnblogs.com/yincheng/p/webpack.html" target="_blank" rel="noopener">Webpack从入门到上线</a></li><li><a href="https://juejin.im/post/5b304f1f51882574c72f19b0" target="_blank" rel="noopener">Webpack 4 配置最佳实践</a></li><li><a href="https://juejin.im/post/5ac9dc9af265da23884d5543" target="_blank" rel="noopener">带你走进webpack世界</a></li><li><a href="https://juejin.im/post/5d2b300de51d45775b419c76" target="_blank" rel="noopener">Webpack 理解 Chunk</a></li><li><a href="https://juejin.im/post/5c17b9805188251e663ec239" target="_blank" rel="noopener">webpack build后生成的app、vendor、manifest三者有何职能不同？</a></li><li><a href="https://juejin.im/post/5b45abde51882519ba0044d0" target="_blank" rel="noopener">[译]Webpack 4 — 神秘的SplitChunksc插件</a></li><li><a href="https://www.cnblogs.com/ghost-xyx/p/5812902.html" target="_blank" rel="noopener">webpack踩坑之路 (2)——图片的路径与打包</a></li><li><a href="https://juejin.im/post/5c68f4e9e51d454be11473b9" target="_blank" rel="noopener">webpack4.0+vue+es6配置</a></li><li><a href="https://blog.csdn.net/u012443286/article/details/79577545" target="_blank" rel="noopener">webpack4.x下babel的安装、配置及使用</a></li><li><a href="https://segmentfault.com/a/1190000012718374" target="_blank" rel="noopener">深入Webpack-编写Loader</a></li><li><a href="https://juejin.im/post/5bbf190de51d450ea52fffd3" target="_blank" rel="noopener">webpack loader和plugin编写</a></li><li><a href="https://zxljack.com/2019/03/webpack-plugin/" target="_blank" rel="noopener">webpack自定义插件</a></li><li><a href="https://zoumiaojiang.com/article/what-is-real-webpack-plugin/#compiler-compilation" target="_blank" rel="noopener">webpack中的compiler &amp; compilation 对象</a></li></ul></blockquote><ul><li><a href="#webpack-学习文档"><span style="font-size: 2em;font-weight: bold;">Webpack 学习文档目录</span></a><ul><li><a href="#一安装">一、安装</a></li><li><a href="#二基础打包">二、基础打包</a></li><li><a href="#三使用-webpack-dev-server-打造开发环境">三、使用 webpack-dev-server 打造开发环境</a></li><li><a href="#四webpack-4-配置初解">四、Webpack 4 配置初解</a><ul><li><a href="#41-chunk">4.1 Chunk</a><ul><li><a href="#42-产生-chunk-的多种方式">4.2 产生 Chunk 的多种方式</a></li><li><a href="#43-chunk-和-bundle-概念异同">4.3 Chunk 和 Bundle 概念异同</a></li></ul></li></ul></li><li><a href="#五打包除了-js-以外的文件">五、打包除了 JS 以外的文件</a><ul><li><a href="#51-打包html">5.1 打包html</a></li><li><a href="#52-打包-css">5.2 打包 CSS</a></li></ul></li><li><a href="#六代码分割">六、代码分割</a><ul><li><a href="#61-使用插件分析打包模块">6.1 使用插件分析打包模块</a></li><li><a href="#62-代码分割配置详解">6.2 代码分割配置详解</a><ul><li><a href="#623-三种不同的分割逻辑">6.2.3 三种不同的分割逻辑</a></li></ul></li></ul></li><li><a href="#额外优化">额外优化</a></li><li><a href="#七webpack-项目基本配置">七、WebPack 项目基本配置</a><ul><li><a href="#71-区分生产开发环境">7.1 区分生产开发环境</a></li><li><a href="#72-开发环境配置">7.2 开发环境配置</a></li><li><a href="#73-生产环境配置">7.3 生产环境配置</a></li></ul></li><li><a href="#八资源管理插件-loader">八、资源管理插件-loader</a></li><li><a href="#九vue-环境相关开发配置">九、Vue 环境相关开发配置</a></li><li><a href="#十项目的额外优化">十、项目的额外优化</a><ul><li><a href="#101-babel--loader-配置">10.1 babel -loader 配置</a></li><li><a href="#102-小工具">10.2 小工具</a></li></ul></li><li><a href="#十一编写-loader">十一、编写 Loader</a><ul><li><a href="#111-loader-基础以及使用">11.1 Loader 基础以及使用</a></li><li><a href="#112-loader-api-功能">11.2 Loader API 功能</a><ul><li><a href="#1121-获得-loader-的-options">11.2.1 获得 Loader 的 options</a></li><li><a href="#1122-返回其它结果">11.2.2 返回其它结果</a></li><li><a href="#1123-同步与异步">11.2.3 同步与异步</a></li><li><a href="#1124-处理二进制数据">11.2.4 处理二进制数据</a></li><li><a href="#1125-缓存加速">11.2.5 缓存加速</a></li><li><a href="#1126-其余常用-api">11.2.6 其余常用 API</a></li></ul></li></ul></li><li><a href="#十二编写-plugin">十二、编写 Plugin</a><ul><li><a href="#121-plugin-示例">12.1 Plugin 示例</a></li><li><a href="#121-plugin-涉及概念">12.1 Plugin 涉及概念</a></li><li><a href="#121-plugin-执行流程">12.1 Plugin 执行流程</a></li><li><a href="#122-手写一个骨架屏插件-demo">12.2 手写一个骨架屏插件 Demo</a></li></ul></li><li><a href="#十三额外拓展之-gulp-与-webpack-的区别">十三、额外拓展之-gulp-与-webpack-的区别</a></li></ul></li></ul><hr><p>第一部分 基础学习</p><hr><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><ol><li>确保电脑上安装有 node 环境且 npm 命令可用。</li><li>新建文件夹，使用<code>npm init</code>新建项目</li><li>使用<code>npm install -g webpack webpack-cli</code>安装 webpack 命令</li><li>项目文件夹下执行<code>npm install webpack webpack-cli --save-dev</code>进行项目脚手架安装</li></ol><h2 id="二、基础打包"><a href="#二、基础打包" class="headerlink" title="二、基础打包"></a>二、基础打包</h2><ol><li>新建<strong>webpack.config.js</strong>文件，加入基础配置项目，进行 JS 打包</li><li>在项目文件下执行<code>webpack</code>命令，即可以看到生成的打包文件在 dist 文件夹下</li></ol><h2 id="三、使用-webpack-dev-server-打造开发环境"><a href="#三、使用-webpack-dev-server-打造开发环境" class="headerlink" title="三、使用 webpack-dev-server 打造开发环境"></a>三、使用 webpack-dev-server 打造开发环境</h2><ol><li>项目文件夹下执行<code>npm install webpack-dev-server --save-dev</code>安装环境</li><li>执行<code>npm install -g webpack-dev-server</code>安装命令环境</li><li>项目文件夹下执行<code>webpack-dev-server</code>即可通过访问<em>127.0.0.1:8080</em>（默认端口为 8080，可以通过 –port 参数进行修改）访问当前文件夹</li><li>新版的 webpack-dev-server 自带热更新，任何修改都会导致服务重启</li></ol><h2 id="四、Webpack-4-配置初解"><a href="#四、Webpack-4-配置初解" class="headerlink" title="四、Webpack 4 配置初解"></a>四、Webpack 4 配置初解</h2><p>前三步完成后，一个基础的 Webpack 项目就可以说已经搭起来了，接下来，我们以当前的 webpack.config.js 为例，介绍一个基础的配置文件中包含了什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// The standard entry point and output config</span></span><br><span class="line">  <span class="comment">// 每个页面的js文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/js/home'</span>,</span><br><span class="line">    detail: <span class="string">'./src/js/detail'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].[hash:8].js'</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>entry 项代表入口，webpack 会从该项开始找文件开始解析并打包，每一个子项都会产生一个<strong>chunk</strong>（代码块），chunk 的名字就是每一项的 key 值。</li><li>output 代表的是输出文件的配置，其中 path 代表了打包的输出目录，filename 则是输出文件的名字，其中 [name] 指的是 <strong>chunk</strong> 的名字，[hash:8] 表示根据当前版本生成的 hash 码的前八位。</li></ul><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>上面的配置项反复提到了一个词<strong>Chunk</strong>，代码块。这个概念是入门 Webpack 的一个重要概念。</p><p><strong>Chunk 是 WebPack 打包过程中，一堆 module 的集合</strong>。</p><p>什么是 module 呢？Webpack 在打包所有文件时，其实都会根据<strong>文件后缀名</strong>把文件视为分为个个 module ，比如 css 文件就属于 CSS Module，这也就是为什么 webpack 中有一个 module 选项，可以配置 rules 用于决定哪个 module 应用哪种 loader。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">              &#123;</span><br><span class="line">                loader: <span class="string">"style-loader"</span></span><br><span class="line">              &#125;, &#123;</span><br><span class="line">                loader: <span class="string">"css-loader"</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Webpack 通过入口文件开始，通过引用关系（require、import）挨个打包模块，最终形成的就是 Chunk。</p><p>如果我们有多个入口文件，就会有可能形成多个 Chunk，除了 entry 可以形成多个 chunk 以外，还有其余的两种途径。</p><h4 id="产生-Chunk-的多种方式"><a href="#产生-Chunk-的多种方式" class="headerlink" title="产生 Chunk 的多种方式"></a>产生 Chunk 的多种方式</h4><ol><li><p>通过 entry 配置</p><p>entry 配置项可以接收三种值（以下讨论情况不涉及代码分割）：</p><ul><li><p>字符串，这种情况下只会产生一个 Chunk</p></li><li><p>数组，如<code>entry: [&#39;./src/js/main.js&#39;, &#39;./src/js/other.js&#39;]</code>，这种情况下也只会生成一个Chunk</p></li><li><p>对象，如上面的示例代码。</p><p>这种情况下对象中的一个字段就会产生一个 Chunk ，<strong>所以在这种情况下 output 中的 filename 不可直接写死，否则会报错</strong>。因为产生了两个 Bundle 一个名称必然不够用，需要用 [name] 变量来作为生成 Bundle 们的名称。</p><p>而 entry 对象中的 key，也会被用来当作它对应的 Chunk 的名称。</p></li></ul></li><li><p>异步产生 Chunk</p><p>除了入口文件会影响以外，异步加载的模块也需要生成 Chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  hi: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分割产生 Chunk</p><p>请问以下的配置文件会产生多少个Chunk？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// The standard entry point and output config</span></span><br><span class="line">  <span class="comment">// 每个页面的js文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/js/home'</span>,</span><br><span class="line">    detail: <span class="string">'./src/js/detail'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].[hash:8].js'</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].chunkkk.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="string">'single'</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          maxInitialRequests: <span class="number">5</span>,</span><br><span class="line">          minSize: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// home.js</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./myModule'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br><span class="line"><span class="built_in">console</span>.log(myModule)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detail.js</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br></pre></td></tr></table></figure><p>答案是 4 个。</p><p><img src="/images/webpackSplitChunk.jpg" alt="webpackSplitChunk.jpg"></p><p>其中两个入口文件 home.js 和 detail.js 分别产生一个， runtimeChunk: “single” 会将Webpack在浏览器端运行时需要的代码单独抽离到一个文件，commons 下的配置会产生一个 Chunk，一共是 4 个。</p></li></ol><h4 id="Chunk-和-Bundle-概念异同"><a href="#Chunk-和-Bundle-概念异同" class="headerlink" title="Chunk 和 Bundle 概念异同"></a>Chunk 和 Bundle 概念异同</h4><p>Bundle 是我们最终输出的一个或多个文件（简单来说就是最后生成的文件数量），它的概念与 Chunk 不同。大多数情况下，一个 Chunk 会生成一个 Bundle，但也有不是一对一的情况，比如说下面这样的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     entry: &#123;</span><br><span class="line">    main: __dirname + <span class="string">"/app/main.js"</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     output: &#123;</span><br><span class="line">        path: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">        filename: <span class="string">"[name].js"</span>, <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">      &#125;,</span><br><span class="line">     devtool: <span class="string">'source-map'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下只会产生一个Chunk，但是会产生两个Bundle。</p><p>可以说，Chunk是过程中的代码块，Bundle是结果的代码块。</p><h2 id="五、打包除了-JS-以外的文件"><a href="#五、打包除了-JS-以外的文件" class="headerlink" title="五、打包除了 JS 以外的文件"></a>五、打包除了 JS 以外的文件</h2><p>直到上一个 Tag 为止，我们在做的一直都是 JS 的打包，而 Webpack 能做的显然不止于此。通过 Webpack 的插件配置，我们能为 Webpack 添加更多支持的打包类型。</p><h3 id="打包html"><a href="#打包html" class="headerlink" title="打包html"></a>打包html</h3><p>引入 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a> 用于实现这一目标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin@next --save-dev</span><br></pre></td></tr></table></figure><p>该插件可以给每一个chunk生成html,指定一个<code>template</code>,可以接收参数，在模板里面使用。</p><p>随后在 webpack.config.js 中引入，执行<code>npm run build</code>，该插件就会最终生成一个引用了所有 JS 文件和 CSS 文件的 index.html 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以传入更多参数来进行自定义定制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// The standard entry point and output config</span></span><br><span class="line">  <span class="comment">// 每个页面的js文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/js/home'</span>,</span><br><span class="line">    detail: <span class="string">'./src/js/detail'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].[hash:8].js'</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].chunkkk.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/html/home.html'</span>,</span><br><span class="line">      filename: <span class="string">'home.html'</span>,</span><br><span class="line">      title: <span class="string">'home'</span>,</span><br><span class="line">      chunks: [<span class="string">'home'</span>],</span><br><span class="line">      hash: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./src/html/detail.html'</span>,</span><br><span class="line">      filename: <span class="string">'detail.html'</span>,</span><br><span class="line">      title: <span class="string">'detail'</span>,</span><br><span class="line">      chunks: [<span class="string">'detail'</span>],</span><br><span class="line">      hash: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webpack中，插件的引入顺序没有规定，上面的例子中我们引入了两个 html 模板，且每个 html 都有自己所属的 Chunk 包，打包配置含义如下：</p><ul><li>template: html 模板的路径地址</li><li>filename: 生成的文件名</li><li>title：传入的参数</li><li>chunks：html 文件所需要引入的 chunk，这里传入的是一个由 chunk 的 key 值组成的数组，chunk 的 key 值正如上文所述就是 entry 选项中对象的 key 值。</li><li>hash：在引入的 JS 里面加入 hash 值，用于区分版本避免缓存后无法更新，比如<code>&lt;script src=&quot;detail.4f7295dc.js?4f7295dc91c265ce0b3d&quot;&gt;&lt;/script&gt;</code>这种形式</li><li>removeAttributeQuotes：去掉引号，减小文件大小</li></ul><h3 id="打包-CSS"><a href="#打包-CSS" class="headerlink" title="打包 CSS"></a>打包 CSS</h3><p>要让 webpack 在打包 JS 的时候同时打包 CSS，首先要让 webpack 能够识别到 CSS，否则就会像下面这样报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// home.js</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./myModule'</span>)</span><br><span class="line"><span class="keyword">var</span> css = <span class="built_in">require</span>(<span class="string">'../css/home.css'</span>) <span class="comment">// 通过 require 引入 CSS</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br><span class="line"><span class="built_in">console</span>.log(myModule)</span><br></pre></td></tr></table></figure><p><img src="/images/webpackCssBundleErr.jpg" alt="webpackCssBundleErr.jpg"></p><p>安装 css-loader 拓展即可让 webpack 在打包时识别到 css 文件。安装 style-loader 可以让 Webpack 将引入的 CSS 加上 style 标签用 JS 自动生成在页面里。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行安装</span></span><br><span class="line">npm install css-loader style-loader --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// The standard entry point and output config</span></span><br><span class="line">  <span class="comment">// 每个页面的js文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/js/home'</span>,</span><br><span class="line">    detail: <span class="string">'./src/js/detail'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].[hash:8].js'</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].chunkkk.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>], <span class="comment">// 被引入的 loader 会从右至左顺序执行，css-loader 用于支持 css 中的引入 , style-loader 用于 JS 把 css 写入 style 内嵌标签动态创建</span></span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果你想使用 stylus、scss 等编译型 CSS 语言，也可以引入相应的 loader ，比如 scss 类型的文件就可以引入下面类型的 loader。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader sass-loader node-sass -D</span><br></pre></td></tr></table></figure><p>其中 node-sass 是 sass-loader 的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>], <span class="comment">// 被引入的 loader 会从右至左顺序执行，css-loader 用于支持 css 中的引入 , style-loader 用于 JS 把 css 写入 style 内嵌标签动态创建</span></span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果要把 css 作为一个单独的文件，需要用到一个插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i extract-text-webpack-plugin@next --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// The standard entry point and output config</span></span><br><span class="line">  <span class="comment">// 每个页面的js文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/js/home'</span>,</span><br><span class="line">    detail: <span class="string">'./src/js/detail'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].[hash:8].js'</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].chunkkk.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          <span class="comment">// style-loader 把 css 文件中的数据写入到 html 中的 style 标签</span></span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].[hash:8].css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件配置</p><ul><li>name: chunk 的名字</li><li>hash: 8 根据内容生成 hash 值取前 8 位</li><li>修改 loader 配置下的 use，fallback 指兼容方案</li></ul><h2 id="六、代码分割"><a href="#六、代码分割" class="headerlink" title="六、代码分割"></a>六、代码分割</h2><p>本节要研究的是 webpack 对于代码分割的机制，webpack 可以将多次 import 的文件根据一定的规则打包成一个单独的 JS，用于缩小文件整体大小以及优化加快加载速度。但有时候不当的设置会让 webpack 将文件过度分割，最终导致页面的请求过多，反而拖慢了页面的加载速度（相比于一次性加载一个 1M 的JS文件，发起 1024 次网络请求加载 1024 个 1K 的 JS 文件显然更浪费时间和资源）。因此，理解 webpack 对于代码分割的处理显得至关重要。</p><h3 id="使用插件分析打包模块"><a href="#使用插件分析打包模块" class="headerlink" title="使用插件分析打包模块"></a>使用插件分析打包模块</h3><p>分析代码分割之前首先要有合适的分析工具，<strong>webpack-bundle-analyzer</strong> 插件可以将打包的模块形成可视化缩放树形图。</p><p>下面是使用方法：</p><ul><li><p>使用 npm 执行安装命令（该插件可能需要管理员权限）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-bundle-analyzer</span><br></pre></td></tr></table></figure></li><li><p>加入plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此后执行<code>npm run build --report</code>后访问<code>127.0.0.1:8888</code>即可看到打包后的包分析界面</p></li></ul><h3 id="代码分割配置详解"><a href="#代码分割配置详解" class="headerlink" title="代码分割配置详解"></a>代码分割配置详解</h3><p>webpack 4 舍弃了之前在 webpack 3 中使用的 webpack.optimize.CommonsChunkPlugin，增加了 optimization.splitChunks 配置项用于替代。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置模板</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// chunks：表示从哪些chunks里面抽取代码，除了三个可选字符串值 initial、async、all 之外，还可以通过函数来过滤所需的 chunks</span></span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      <span class="comment">// 表示抽取出来的文件在压缩前的最小大小，默认为 30000</span></span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      <span class="comment">// 表示抽取出来的文件在压缩前的最大大小，默认为 0，表示不限制最大大小</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      <span class="comment">// 表示被引用次数，默认为1</span></span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      <span class="comment">// 最大的按需(异步)加载次数，默认为 5</span></span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      <span class="comment">// 最大的初始化加载次数，默认为 3</span></span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      <span class="comment">// 抽取出来的文件的自动生成名字的分割符，默认为 ~</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      <span class="comment">// 抽取出来文件的名字，默认为 true，表示自动生成文件名</span></span><br><span class="line">      name: <span class="literal">true</span>, </span><br><span class="line">      <span class="comment">// 缓存组，继承了上述的一切属性</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          <span class="comment">// 表示要过滤 modules，默认为所有的 modules，可匹配模块路径或 chunk 名字，当匹配的是 chunk 名字的时候，其里面的所有 modules 都会选中</span></span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="comment">// 表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算</span></span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          <span class="comment">// 表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的各组参数中，最重要的是 <strong>cacheGroups</strong>，不仅继承了父选项的一切属性，还额外提供了 test、priority、reuseExistingChunk 三个选项用于过滤。</p><p><strong>在分割配置中，chunks 选项提供了三种不同的打包模式，分别是 async, initial 及 all，代表了三种分割代码的主要逻辑</strong>。</p><h4 id="三种不同的分割逻辑"><a href="#三种不同的分割逻辑" class="headerlink" title="三种不同的分割逻辑"></a>三种不同的分割逻辑</h4><p>配置文件如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// The standard entry point and output config</span></span><br><span class="line">  <span class="comment">// 每个页面的js文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/js/home'</span>,</span><br><span class="line">    detail: <span class="string">'./src/js/detail'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'[name].[hash:8].js'</span>, <span class="comment">// 输出文件名</span></span><br><span class="line">    chunkFilename: <span class="string">'[name].chunkkk.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          chunks: <span class="string">'async'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          minSize: <span class="number">1</span>,</span><br><span class="line">          priority: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          <span class="comment">// style-loader 把 css 文件中的数据写入到 html 中的 style 标签</span></span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].[hash:8].css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// home.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./test'</span>)</span><br><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./myModule'</span>)</span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./test2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// detail.js</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">'./test'</span>)</span><br><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./myModule'</span>)</span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./test2'</span>)</span><br></pre></td></tr></table></figure><ol><li><p>chunks: ‘async’</p><p>该模式下，webpack 只会对异步加载的模块进行分割，而不理会静态引入的模块。</p><p>打包效果如下：</p><p><img src="/images/asyncSplitReport.png" alt="asyncSplitReport.png"></p><p><strong>可以看到</strong>：</p><ul><li>webpack 对 home.js 和 detail.js 中都进行了异步引入的 test2.js 进行了分离打包</li><li>webpack 对 home.js 中进行了异步调用的 test.js 进行了分离打包（<strong>这其实与优化无关，只是单纯因为我们之前提到的异步文件会单独生成一个 chunk 文件</strong>），而对 detail.js 中静态引入的 test.js 则没有分离</li><li>webpack 对 home.js 和 detail.js 中都进行了静态引入的 myModule.js 没有进行分离打包</li></ul></li><li><p>chunks: ‘initial’</p><p>该模式下 webpack 会关注于静态文件的分离打包。</p><p><img src="/images/initialSplitReport.png" alt="initialSplitReport.png"></p><p><strong>可以看到</strong>：</p><ul><li>对于 test.js ，由于它的静态引入数小于 minChunks: 2，所以 webpack 并没有对 detail.js 中静态引入的 test.js 进行分离打包。而由于其在 home.js 中异步引入，所以额外为其生成了一个 chunk 文件，test2.js 也是同理。</li><li>由于在 detail.js、home.js 两个文件中都静态引入了 myModule.js，所以 webpack 将其打包成了一个通用 JS 供这两个文件引用</li></ul></li><li><p>chunks: ‘all’</p><p>该模式下 webpack 将会对两种引入一视同仁。</p><p><img src="/images/allSplitReport.png" alt="allSplitReport.png"></p><p><strong>可以看到</strong>：</p><ul><li>在该模式下，webpack 认为 test.js 和 test2.js 的引用数都为 2（尽管它们引入的方式不同），所以将其转到单文件 1.cunkkk.js 和 2.chunkkk.js</li><li>myModule.js 依旧被打包进了通用 JS。</li></ul></li></ol><p><strong>结论</strong>：由于 ChunkFile 的特性，无论处于何种模式下，webpack 都会为异步引入的文件单独生成有且只有一个 bundle，这就使得 async 模式有些鸡肋，几乎只是为了不分割静态引入文件而存在的一种模式。而乍一看 all 模式似乎是能将文件分割得最漂亮的模式，但事实上很容易造成文件过度分割，文件过于碎片化的情况。此时若有一个页面需要加载 detail.js，在 initial 模式下浏览器需要下载 detail.xxxx.js、test2.js、vendors.js 三个文件，而在 all 模式下则需要下载 detail.xxxx.js、test.js、test2.js、vendors.js 四个文件。由此，也不难理解为什么常用的分割模式是 initial 了。</p><h2 id="额外优化"><a href="#额外优化" class="headerlink" title="额外优化"></a>额外优化</h2><ul><li><p><strong>每次打包前先清空 dist 目录</strong></p><p>使用 <a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a> 可以方便的实现这一目标。</p><p>安装：<code>npm install --save-dev clean-webpack-plugin</code></p><p>在 webpack.config.js 中加入下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>By default, this plugin will remove all files inside webpack’s <code>output.path</code> directory, as well as all unused webpack assets after every successful rebuild</p><p>默认情况下，这个插件会在每次构建前移除 webpack 选项中，output.path 目录下的所有文件，即使是所有没有用到的静态文件也是如此。</p></blockquote></li></ul><ul><li><p><strong>url-loader 转换图片</strong></p><p>该插件依赖于 file-loader ，用于把图片转换为 base64 嵌入 html，,如果超出一定阈值则交给 file-loader。</p></li><li><p><strong>babel-loader 转化代码</strong></p><p>使用 babel-loader 转换代码，由此让高版本代码获得更强的兼容性。</p></li></ul><hr><p>第二部分 实战练习 手写一个简易 Vue-Cli</p><hr><p>经过了上面的学习以后，我们已经掌握了 webpack 打包的大部分基础知识，接下来，我们将学习如何将所学的知识真正运用到前端工程当中。</p><h2 id="七、WebPack-项目基本配置"><a href="#七、WebPack-项目基本配置" class="headerlink" title="七、WebPack 项目基本配置"></a>七、WebPack 项目基本配置</h2><h3 id="区分生产开发环境"><a href="#区分生产开发环境" class="headerlink" title="区分生产开发环境"></a>区分生产开发环境</h3><p>在 package.json 中的 scripts 项加入如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"dev"</span>: <span class="string">"set NODE_ENV=development&amp;&amp;webpack-dev-server --inline --progress --config build/webpack.dev.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"set NODE_ENV=production&amp;&amp;webpack --mode=production --config build/webpack.prod.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，使用<code>set NODE_ENV=development</code>来启动 webpack ，可以让我们在代码中通过访问<code>process.env.NODE_ENV</code>来判断生产环境还是开发环境。</p><p>如上面的配置中，我们需要准备两套不一样的 webpack 配置文件，分别是 webpack.dev.js 用于开发环境和 webpack.prod.js 用于生产环境。</p><p>但两套环境并不是完全不同，其中一些公用配置完全可以抽出来，作为一个新的文件 webpack.common.js。使用 webpack 支持的 webpack-merge 插件可以很方便地对配置文件进行合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure><p>在根目录下创建一个 build 文件夹，用于放置这三个配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../index.html'</span>),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js &amp;&amp; webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"webpack-merge"</span>)</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就完成了最基本的配置分割。</p><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><p>开发环境中，我们主要关注的有以下几点：</p><ul><li>实时构建</li><li>模块热更新替换</li><li>代码映射用于 Debug</li></ul><p>webpack-dev-server 的原理是基于 express（一个基于 node 构建的高性能异步服务框架）运行的一个服务器，通过 webpack 中的 devServer 选项对其进行配置。</p><p>以下是一个通用的配置文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="comment">//详情https://www.webpackjs.com/configuration/devtool/</span></span><br><span class="line">  devtool: <span class="string">'inline-cheap-module-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'index.html'</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    overlay: <span class="literal">true</span>,</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    inline: <span class="literal">true</span>,</span><br><span class="line">    progress: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//启用热更新配置项</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中的选项配置含义如下：</p><ul><li><code>contentBase</code>: 静态文件地址</li><li><code>port</code>: 端口号</li><li><code>host</code>: 主机</li><li><code>overlay</code>: 如果出错，则在浏览器中显示出错误</li><li><code>compress</code>: 服务器返回浏览器的时候是否启动gzip压缩</li><li><code>open</code>: 打包完成自动打开浏览器</li><li><code>hot</code>: 模块热替换 需要<code>webpack.HotModuleReplacementPlugin</code>插件</li><li><code>inline</code>: 实时构建</li><li><code>progress</code>: 显示打包进度</li><li><code>devtool</code>: 生成代码映射，查看编译前代码，利于找bug</li><li><code>webpack.NamedModulesPlugin</code>: 显示模块的相对路径</li></ul><p>运行<code>npm run dev</code>，试着对 src 文件夹下的 js 文件进行更改，即可看到热更新的效果。</p><p>webpack-dev-server 能做的当然不止这些，proxy 代理，cookie 设置、甚至像 mock 数据这样极其便利的功能，只要配置得当，都是可以使用的。</p><h3 id="生产环境配置"><a href="#生产环境配置" class="headerlink" title="生产环境配置"></a>生产环境配置</h3><p>生产环境的打包我们一般会关注以下几点：</p><ul><li>代码压缩、混淆</li><li>删除开发环境下的特定代码（比如 console、warning 之类的）</li><li>打包速度</li><li>文件分割</li></ul><p>使用 WebpackParallelUglifyPlugin 可以得到代码压缩以及删除代码等功能，且可以并行压缩代码，提升打包效率。</p><p>使用<code>npm install --save-dev webpack-parallel-uglify-plugin</code>即可进行安装。</p><p>其选项配置如下：</p><ul><li><code>mangle</code>: 是否混淆代码</li><li><code>output.beautify</code>: 代码压缩成一行 true为不压缩 false压缩</li><li><code>output.comments</code>: 去掉注释</li><li><code>compress.drop_console</code>: 删除console</li><li><code>compress.collapse_vars</code>: 把定义一次的变量，直接使用，取消定义变量</li><li><code>compress.reduce_vars</code>: 合并多次用到的值，定义成变量</li><li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fuglify-js" rel="nofollow noopener noreferrer">具体文档</a></li></ul><p>使用 optimization 选项即可对文件分割进行配置，最终的配置文件如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">"webpack-merge"</span>)</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>)</span><br><span class="line"><span class="keyword">const</span> WebpackParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    namedChunks: <span class="literal">true</span>,</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'manifest'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//编译错误时不生成</span></span><br><span class="line">    noEmitOnErrors: <span class="literal">true</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 默认配置</span></span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      name: <span class="literal">false</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          <span class="comment">// 覆盖配置</span></span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">false</span>,</span><br><span class="line">          test: <span class="regexp">/node_modules\/(.*)\.js/</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> WebpackParallelUglifyPlugin(&#123;</span><br><span class="line">      uglifyJS: &#123;</span><br><span class="line">        <span class="comment">// 是否混淆变量名称</span></span><br><span class="line">        mangle: <span class="literal">false</span>,</span><br><span class="line">        output: &#123;</span><br><span class="line">          <span class="comment">// 代码是否压缩为多行，false 为压缩</span></span><br><span class="line">          beautify: <span class="literal">false</span>,</span><br><span class="line">          <span class="comment">// 是否去掉注释, true 或 'all' 为保留所有注释</span></span><br><span class="line">          comments: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        compress: &#123;</span><br><span class="line">          <span class="comment">// 删除 console</span></span><br><span class="line">          drop_console: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 把定义一次的变量直接使用</span></span><br><span class="line">          collapse_vars: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 合并多次用到的值，并定义为变量</span></span><br><span class="line">          reduce_vars: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="八、资源管理插件-loader"><a href="#八、资源管理插件-loader" class="headerlink" title="八、资源管理插件-loader"></a>八、资源管理插件-loader</h2><p>直至上一节为止，该 webpack 项目只能打包一个 index.html 和 js 文件，无法识别 css、图片等资源。在本节中，该项目需要安装各类 loader，进行资源管理。</p><p>安装css-loader file-loader url-loader sass-loader node-sass（sass-loader和node-sass配置sass环境，url-loader是基于file-loader，可以进行小图片转换base64）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader css-loader file-loader url-loader sass-loader node-sass</span><br></pre></td></tr></table></figure><p>使用 <strong>postcss-loader</strong> <strong>autoprefixer</strong> 这两个插件可以自动为样式添加前缀，用于浏览器兼容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure><p>使用 mini-css-extract-plugin 可以抽离样式文件到一个单独文件中(webpack4+版本使用，webpack4以下版本使用extract-text-webpack-plugin)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin  --save-dev</span><br></pre></td></tr></table></figure><p>使用 copy-webpack-plugin 可以将一些不用打包的文件在打包后复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install copy-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>文件配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> devMode = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// 打包输出目录</span></span><br><span class="line">    filename: <span class="string">'js/[name].[hash:8].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(sa|sc|c)ss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              hmr: process.env.NODE_ENV === <span class="string">'development'</span>,</span><br><span class="line">              reloadAll: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'sass-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              plugins: [</span><br><span class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                  overrideBrowserslist: [<span class="string">'ie 9-11'</span>, <span class="string">'last 5 version'</span>] <span class="comment">//兼容IE9到11，所有浏览器最近五个版本</span></span><br><span class="line">                &#125;)</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// loader 后面 limit 字段代表图片打包限制，这个限制并不是说超过了就不能打包，而是指当图片大小小于限制时会自动转成 base64 码引用。上例中大于8192字节的图片正常打包，小于8192字节的图片以 base64 的方式引用</span></span><br><span class="line">          <span class="comment">// name 字段指定了在打包根目录（output.path）下生成名为 images 的文件夹，并在原图片名前加上8位 hash 值</span></span><br><span class="line">          <span class="string">'url-loader?limit=8192&amp;name=images/[name].[hash:8].[ext]'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../index.html'</span>),</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode ? <span class="string">'css/[name].css'</span> : <span class="string">'css/[name].[hash:8].css'</span>,</span><br><span class="line">      chunkFilename: devMode ? <span class="string">'css/[id].css'</span> : <span class="string">'css/[id].[hash:8].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">      <span class="keyword">from</span>: path.resolve(__dirname, <span class="string">'../public'</span>),</span><br><span class="line">      to: path.resolve(__dirname, <span class="string">'../dist/static'</span>),</span><br><span class="line">      ignore: [<span class="string">'.*'</span>]</span><br><span class="line">    &#125;])</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、Vue-环境相关开发配置"><a href="#九、Vue-环境相关开发配置" class="headerlink" title="九、Vue 环境相关开发配置"></a>九、Vue 环境相关开发配置</h2><p>万事俱备以后，就只剩下 Vue 相关的打包了，首先要先引入 vue、vue-router 等开发用到的包，以及 vue-style-loader vue-template-compiler 两个用于 webpack 解析 vue 文件的插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue vue-router vue-loader vue-style-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure><p>随后配置 vue-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                use: <span class="string">'vue-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们使用了 MiniCssExtractPlugin 和 vue-loader，所以对于 css 的配置就没有额外添加了，插件会为我们自动识别并提取 vue 文件中的样式的。</p><h2 id="十、项目的额外优化"><a href="#十、项目的额外优化" class="headerlink" title="十、项目的额外优化"></a>十、项目的额外优化</h2><p>至上一节为止，一个能够用于开发 Vue 项目的基于 webpack4 的脚手架就已经搭建完毕了，为了尽善尽美，我们接下来要做一些额外优化，以提升开发体验。</p><h3 id="babel-loader-配置"><a href="#babel-loader-配置" class="headerlink" title="babel -loader 配置"></a>babel -loader 配置</h3><p>对于时下的前端开发来说，不使用 ES6 语法无异于自断双臂，可是直至上一节，如果我们在项目中使用 ES6 语法，在执行  <code>npm run build</code>打包时都会报错（其实是由于我们使用了 WebpackParallelUglifyPlugin 插件进行了代码混淆导致的，如果不进行代码混淆就不会报错，但代码的兼容性还是得不到保障）。下面我们使用 babel 插件转译来解决这个问题。</p><ol><li><p>首先是安装相关依赖，主要用到的依赖有以下几个：</p><ul><li>babel-loader：作为 webpack 的 loader 一种，用于被 webpack 识别并调用 babel 来转译被打包的 js 文件</li><li>babel-core：babel-core 用于提供一系列的 api，当 webpack 使用 babel-loader 处理文件时，babel-loader实际上调用了 babel-core 的 api，因此也必须安装 babel-core。</li><li>babel-preset-env：官方推荐的转码规则，babel 有好几种规则都可以实现对 ES6 语法的转化，如 babel-preset-es2015、babel-preset-latest、babel-preset-env。但目前官方推荐的是 babel-preset-env。</li><li>plugin-transform-runtime：babel 的插件，表示不管浏览器是否支持ES6，只要是ES6的语法，都会进行转码成ES5</li></ul><p>使用下面的命令进行 babel 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/core @babel/plugin-transform-runtime @babel/preset-env babel-loader --save-dev</span><br></pre></td></tr></table></figure></li><li><p>随后需要配置 babel 相关规则，相对简单的规则可以选择在 package.json 中添加 babel 关键字进行添加，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">"babel"</span>: &#123;</span><br><span class="line">        <span class="attr">"presets"</span>: [<span class="string">"env"</span>],</span><br><span class="line">        <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>presets 代表转码规则，plugin 属性用于设置使用到的插件，上面的配置会在打包时使用 babel，并告诉 babel 使用 bable-preset-env 规则和 plugin-transform-runtime 插件。</p><p>当然，为了尽量不污染依赖库的设置，babel 也提供了一种另外的方式，即在项目根目录下建立 .babelrc 文件进行设置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>], </span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，在 webpack.common.js 中进行相关配置，将 js 文件使用 loader 进行转译即可(注意要使用 exclude 将库文件分开，以免影响效率)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成配置以后运行<code>npm run build</code>，此时项目中即便使用了 ES6 语法，也能顺利完成打包并且不用过于担心兼容性了。</p></li></ol><h3 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h3><ul><li><p>使用 ProgressBarPlugin 可以用一个进度条来表示 webpack 的打包进度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install progress-bar-webpack-plugin --save-dev</span></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> ProgressBarPlugin = <span class="built_in">require</span>(<span class="string">'progress-bar-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ProgressBarPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/progressPlugin.png" alt="progressPlugin.png"></p></li><li><p>使用 resolve、extensions 来进行路径简化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [ <span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.scss'</span>, <span class="string">'.css'</span>], <span class="comment">//后缀名自动补全</span></span><br><span class="line">        alias: &#123;                                       </span><br><span class="line">            <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'../src'</span>), <span class="comment">//别名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>至此，一个基于 Webpack4 的 Vue 开发项目已经搭建完成。</p><hr><p>第三部分 Webpack进阶</p><hr><p>要深入学习 Webpack，就绕不过种类繁多的 Loader 和 Plugin，这两种机制作为第三方插件为 Webpack 打包提供了更多的可能性。所以在这部分，我们来掌握 Loader 和 Plugin 的写法。</p><h2 id="十一、编写-Loader"><a href="#十一、编写-Loader" class="headerlink" title="十一、编写 Loader"></a>十一、编写 Loader</h2><p>Loader 用于将源文件经过转化后输出新的结果，且一个文件还可以链式的经过多个 Loader 进行翻译。</p><p>由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数，其工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。</p><p>在进行 loader 的编写时，要注意遵循单一职责原则，通俗来讲就是只做一种转换，由于 Loader 是支持链式调用的，遵循单一职责原则，只关心输入和输出可以让整体逻辑显得更加清晰。</p><h3 id="Loader-基础以及使用"><a href="#Loader-基础以及使用" class="headerlink" title="Loader 基础以及使用"></a>Loader 基础以及使用</h3><p>一个最简单的 Loader 源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader/myLoader.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span></span><br><span class="line">    <span class="comment">// 该函数需要返回处理后的内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是我的第一个 Loader'</span>)</span><br><span class="line">    <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后可以使用三种方式将 loader 配置进 webpack 的配置文件：</p><ol><li><p>直接在 rules 中通过 loader 选项 require 绝对目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">'babel-loader'</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 通过 require.resolve 获取绝对路径</span></span><br><span class="line">                        loader: <span class="built_in">require</span>.resolve(<span class="string">'../loader/myLoader'</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过 ResolveLoader 配置，规定 Webpack 会从哪几个文件夹下寻找 Loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">&#123;</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        <span class="comment">// 去哪些目录下寻找 Loader，从左至右执行，有先后顺序</span></span><br><span class="line">        modules: [<span class="string">'node_modules'</span>, <span class="string">'../loader/'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                use: [<span class="string">'babel-loader'</span>, <span class="string">'myLoader'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>通过<code>npm link</code>命令将本地 loader 注册到 node_modules 目录下，让项目可以直接使用</li></ol><p>配置完毕后，执行打包命令，就可以看到 loader 已经在打包过程中应用了。</p><p><img src="/images/loadersPackage1.jpg" alt="loadersPackage1.jpg"></p><h3 id="Loader-API-功能"><a href="#Loader-API-功能" class="headerlink" title="Loader API 功能"></a>Loader API 功能</h3><h4 id="获得-Loader-的-options"><a href="#获得-Loader-的-options" class="headerlink" title="获得 Loader 的 options"></a>获得 Loader 的 options</h4><p>Webpack 提供了一些 API 以供 loader 调用，可以通过引入 loader-utils 来获取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myLoader.js</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span></span><br><span class="line">  <span class="comment">// 该函数需要返回处理后的内容</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(options)</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回其它结果"><a href="#返回其它结果" class="headerlink" title="返回其它结果"></a>返回其它结果</h4><p>一般的 loader 只是会返回原内容转换后的内容，但在有些场景下还需要返回除了内容之外的东西。</p><p>例如 babel-loader 转换 ES6 ，就还需要输出转换后的 ES5 代码对应的 Source Map用于调试源码，这时候就不能通过 return 简单的进行返回了。</p><p>webpack 为这种情况设计了一个 callback 函数API，方便 loader 和 Webpack 之间通信，使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.callback(</span><br><span class="line">    <span class="comment">// 当无法转换原内容时，给 Webpack 返回一个 Error</span></span><br><span class="line">    err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 原内容转换后的内容</span></span><br><span class="line">    content: string | Buffer,</span><br><span class="line">    <span class="comment">// 用于把转换后的内容得出原内容的 Source Map，方便调试</span></span><br><span class="line">    sourceMap?: SourceMap,</span><br><span class="line">    <span class="comment">// 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回，</span></span><br><span class="line">    <span class="comment">// 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能</span></span><br><span class="line">    abstractSyntaxTree?: AST</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>此外，若当前 loader 需要使用 callback 函数，当前 loader 必须要 return 一个<code>undefined</code>以告诉 webpack 当前 loader 返回的结果在 callback 中而不在 return 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 this.callback 告诉 Webpack 返回的结果</span></span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, sourceMaps)</span><br><span class="line">  <span class="comment">// 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，</span></span><br><span class="line">  <span class="comment">// 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 </span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS： Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。<br>为此 Webpack 为 Loader 提供了 <code>this.sourceMap</code> API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。<br>如果你编写的 Loader 会生成 Source Map，请考虑到这点。</p></blockquote><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>Loader 有同步和异步的区分，有些转换流程复杂的 Loader 需要一些异步步骤来进行转换（例如网络请求），如果采用同步的方式就会阻塞整个构建，拖慢打包进度。</p><p>所以 webpack 提供了一个 async 接口用于异步构建，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果</span></span><br><span class="line">  <span class="keyword">let</span> callback = <span class="keyword">this</span>.async()</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'延时两秒'</span>)</span><br><span class="line">    <span class="comment">// 通过 callback 返回异步执行后的结果，可传入四个参数, err、result、sourceMaps、ast</span></span><br><span class="line">    callback(<span class="literal">null</span>, source)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理二进制数据"><a href="#处理二进制数据" class="headerlink" title="处理二进制数据"></a>处理二进制数据</h4><p>默认情况下，Webpack 传给 Loader 的是 UTF-8 格式编码的字符串，但有些场景下 Loader 需要处理二进制文件而不是文本（例如 file-loader），这时可以通过修改 loader 的 raw 属性来进行传入数据的类型变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLoader</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的</span></span><br><span class="line">  <span class="built_in">console</span>.log(source <span class="keyword">instanceof</span> Buffer)</span><br><span class="line">  <span class="comment">// Loader 返回的类型也可以是 Buffer 类型的</span></span><br><span class="line">  <span class="comment">// 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果</span></span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据</span></span><br><span class="line">myLoader.raw = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = myLoader</span><br></pre></td></tr></table></figure><h4 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h4><p>Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被打包的文件及其依赖文件没有发生变化时是不会重新调用对应的 Loader 去执行转换操作的。</p><p>如果想取消这一默认缓存行为，可以调用 cacheable API 来进行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关闭该 Loader 的缓存功能</span></span><br><span class="line">  <span class="keyword">this</span>.cacheable(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="其余常用-API"><a href="#其余常用-API" class="headerlink" title="其余常用 API"></a>其余常用 API</h4><blockquote><ul><li><code>this.context</code>：当前处理文件的所在目录，假如当前 Loader 处理的文件是 <code>/src/main.js</code>，则 <code>this.context</code> 就等于 <code>/src</code>。</li><li><code>this.resource</code>：当前处理文件的完整请求路径，包括 querystring，例如 <code>/src/main.js?name=1</code>。</li><li><code>this.resourcePath</code>：当前处理文件的路径，例如 <code>/src/main.js</code>。</li><li><code>this.resourceQuery</code>：当前处理文件的 querystring。</li><li><code>this.target</code>：等于 Webpack 配置中的 Target，详情见 <a href="http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-7%E5%85%B6%E5%AE%83%E9%85%8D%E7%BD%AE%E9%A1%B9.html" rel="nofollow noreferrer" target="_blank">2-7其它配置项-Target</a>。</li><li><code>this.loadModule</code>：但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时，就可以通过 <code>this.loadModule(request: string, callback: function(err, source, sourceMap, module))</code> 去获得 <code>request</code> 对应文件的处理结果。</li><li><code>this.resolve</code>：像 <code>require</code> 语句一样获得指定文件的完整路径，使用方法为 <code>resolve(context: string, request: string, callback: function(err, result: string))</code>。</li><li><code>this.addDependency</code>：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 <code>addDependency(file: string)</code>。</li><li><code>this.addContextDependency</code>：和 <code>addDependency</code> 类似，但 <code>addContextDependency</code> 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 <code>addContextDependency(directory: string)</code>。</li><li><code>this.clearDependencies</code>：清除当前正在处理文件的所有依赖，使用方法为 <code>clearDependencies()</code>。</li><li>    <code>this.emitFile</code>：输出一个文件，使用方法为 <code>emitFile(name: string, content: Buffer|string, sourceMap: {...})</code>。</li></ul></blockquote><h2 id="十二、编写-Plugin"><a href="#十二、编写-Plugin" class="headerlink" title="十二、编写 Plugin"></a>十二、编写 Plugin</h2><p>在 Webpack 中，Plugin 与 Loader 的区别主要在于 Loader 承担的是一个翻译员的工作，操作对象是每一个类型的文件，而相对应的，Plugin 则是一个扩展器，操作 webpack 本身，并且可以对整个流程进行控制。</p><p>Plugin 并不直接操作文件，而是基于事件机制，监听 webpack 打包过程中被抛出的节点，执行任务。</p><h3 id="Plugin-示例"><a href="#Plugin-示例" class="headerlink" title="Plugin 示例"></a>Plugin 示例</h3><p>一个最简单的插件如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin constructor:'</span>, options)</span><br><span class="line">  &#125;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 绑定钩子事件(webpack 3 写法)</span></span><br><span class="line">    compiler.plugin(<span class="string">'compilation'</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'MyPlugin'</span>)</span><br><span class="line">      compilation.plugin(<span class="string">'buildModule'</span>, m =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'buildModule'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 绑定钩子事件(webpack 4 写法)</span></span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'MyPlugin'</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="comment">// dosomething</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin</span><br></pre></td></tr></table></figure><h3 id="Plugin-涉及概念"><a href="#Plugin-涉及概念" class="headerlink" title="Plugin 涉及概念"></a>Plugin 涉及概念</h3><p>上面的代码中涉及三个重要的概念：</p><ul><li><p>compiler</p><p>compiler 对象包含了 Webpack 环境中所有的配置信息，可以将其理解为 Webpack 的实例，在一次构建的过程中只会生成一次，<strong>用以监听整个 Webpack 从启动到关闭的生命周期事件</strong>。</p></li><li><p>compilation</p><p>compilation 对象包含了当前打包模块的资源，编译生成资源、变化的文件等等。compiler 负责编译webpack 配置对象并返回一个 compilation 实例，而 compilation 实例执行时，会创建所需的 bundles。<strong>用以监听每个模块编译打包时的生命周期事件</strong>。</p></li><li><p>钩子节点</p><p>无论是 compiler 还是 compilation 都提供了若干的生命周期节点钩子供用户调用，控制整个打包流程中的各个进程。compiler 的生命周期可点击<a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">这里</a>，compilation 的生命点击<a href="https://www.webpackjs.com/api/compilation-hooks/" target="_blank" rel="noopener">这里</a>查看。</p></li></ul><p>此外需要注意的是，compiler 和 compilation 这两个对象都是引用，不要在插件中直接修改这两个对象，会影响后面的插件。</p><h3 id="Plugin-执行流程"><a href="#Plugin-执行流程" class="headerlink" title="Plugin 执行流程"></a>Plugin 执行流程</h3><ol><li>Webpack 在启动后，生成 Webpack 的实例，称作 compiler</li><li>随后 Webpack 在读取配置的过程中会执行<code>new MyPligin(options)</code>，初始化一个插件的实例</li><li>随后调用插件实例的 apply 方法，将实例化的 Webpack ，也就是 compiler 传入。</li><li>插件实例在获得 compiler 后就可以通过<code>compiler.plugin(events, callback)</code>来进行 Webpack 广播事件的监听。</li></ol><p>Webpack 的事件机制应用了观察者模式，类似于 Node 里面的 EventEmitter，你也可以使用 <a href="https://webpack.docschina.org/api/plugins/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-custom-hooks-" target="_blank" rel="noopener">Tapable</a> 来自定义钩子函数。</p><h3 id="手写一个骨架屏插件-Demo"><a href="#手写一个骨架屏插件-Demo" class="headerlink" title="手写一个骨架屏插件 Demo"></a>手写一个骨架屏插件 Demo</h3><p>所谓骨架屏，就是在 JS 渲染页面之前呈现的静态内容，像 Vue 这类单页渲染的 JS 库一般都是选择一个页面上的根节点，使用 JS 进行页面的渲染。</p><p>以下这个插件用于在打包的时候，修改 index.html 的内容，达到骨架屏的效果。</p><p>由于我们的 html 是使用 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a> 来打包的，所以我们需要依赖其输出的结果，通过查看其官网，我们可以使用 afterTemplateExecution 事件触发我们的钩子函数，达到内容修改的目的。</p><p>代码如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  injectSkeletonScreen (htmlData, callback) &#123;</span><br><span class="line">    htmlData.html = htmlData.html.replace(</span><br><span class="line">      <span class="string">`&lt;div id="app"&gt;&lt;/div&gt;`</span>,</span><br><span class="line">       <span class="comment">// 在这里输入骨架屏的内容</span></span><br><span class="line">      <span class="string">`&lt;div id="app"&gt;SkeletonScreen&lt;/div&gt;`</span></span><br><span class="line">    )</span><br><span class="line">    callback(<span class="literal">null</span>, htmlData)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 绑定钩子事件</span></span><br><span class="line">    compiler.hooks.compilation.tap(<span class="string">'MyPlugin'</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">      HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapAsync(<span class="string">'MyPlugin'</span>, (htmlData, callback) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.injectSkeletonScreen(htmlData, callback)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin</span><br></pre></td></tr></table></figure><h2 id="十三、额外拓展之-Gulp-与-Webpack-的区别"><a href="#十三、额外拓展之-Gulp-与-Webpack-的区别" class="headerlink" title="十三、额外拓展之 Gulp 与 Webpack 的区别"></a>十三、额外拓展之 Gulp 与 Webpack 的区别</h2><p>时至今日，如果单从应用场景的角度来看，想要分清 Gulp 和 Webpack 的区别实在是一件不容易的事，因为这二者都是基于 node，而且功能太像了，又经常是处于你中有我，我中有你的混乱状态。</p><p><strong>所以要搞清楚这二者之间的区别，最好是从这两种技术诞生的目的以及演变历史来看</strong>。</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>Gulp 作为一种基于流(stream)的任务式打包工具，其诞生的目的就是为了从项目级别上对前端的资源进行打包。翻译成人话就是，Gulp 是一种可以基于 JS 编写的 shell 文件，可以粗暴的把各类资源整合到一起，以便集中打包发布。一个最简单也是最普遍的 Gulp 打包流程就是：</p><ol><li><code>rm</code> 掉 dist 文件夹中以前的旧文件</li><li>自动把 sass 编译成 css, coffee 编译成 js</li><li>压缩各自的文件，压缩图片，生成图片sprite</li><li>拷贝minified/uglified 文件到 dist 文件夹</li></ol><p>乍一看上去这个流程没有任何问题，已经完全能够满足前端构建的所有基本要求，但其实并非如此。Gulp 的打包有一个致命的缺点：不支持模块化。</p><p>并不是说 Gulp 打包出来的文件无法通过引入的方式引入 JavaScript，实际上，只要你在项目中的每个 JS 都遵循 AMD 规范，并且在相应的 html 中进行引入，那么最后打包出来的文件必然是可以使用的。</p><p>换句话说，也就是 Gulp 并不负责对你的 JS 依赖进行处理。</p><p>这时候就需要 Webpack 的切入了。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>事实上你是完全可以在 Gulp 中使用 Webpack 的，Gulp 本身就有一个 <a href="https://www.npmjs.com/package/gulp-webpack" target="_blank" rel="noopener">gulp-webpack</a> 插件。而这也正是 Webpack 诞生的初心：用于梳理 JS 之间的模块关系。也就是 Gulp 打包流程中的第二步的进一步细化。</p><p>使用 Gulp 来进行整个前端项目资源的整理打包，对于模块化的 JS 部分用 Webpack 进行各种依赖处理，保证其高可用性，这就是前端打包最开始的理想形态。</p><h3 id="Webpack-的进化"><a href="#Webpack-的进化" class="headerlink" title="Webpack 的进化"></a>Webpack 的进化</h3><p>但是随着前端项目越来越轻量化发展，人们忽然发现一个事情：我们不一定需要 Gulp。</p><p>事实就是虽然 Gulp 可以基于流处理大部分的文件，执行相应的 shell 命令，但大部分时间我们只是用他来打包而已。package.json 中的 scripts 选项在大部分情况下已经够用，而且 Webpack 恰好也有 Plugin 选项和 Loader 选项可以控制整个打包的生命流程以及处理不同的文件类型。</p><p>再加上 Webpack 的生态环境日益丰富，sass、图片处理、热更新功能都推出了相应的 loader 和插件，所以慢慢的人们都开始倾向于直接使用 Webpack 而放弃了 Gulp 这位原配。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以在我们进行一些中小型的前端项目时，Webpack 及其丰富的生态环境对于我们来说就已经足够。但是当我们需要考虑对多个前端项目，或者说是一个巨大的包含了各种语言的项目进行打包时，Gulp 或许还是一个不可或缺的存在。</p><p>当然，以上的讨论都是基于技术方案只有 Webpack 和 Gulp 的情况下才能成立，如果真的出现了那种庞然大物一样的巨无霸项目，如果不能用微服务重构的话，建议还是跑路比较合适。</p><p>@by 柳皓文</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Webpack-学习文档&quot;&gt;&lt;a href=&quot;#Webpack-学习文档&quot; class=&quot;headerlink&quot; title=&quot;Webpack 学习文档&quot;&gt;&lt;/a&gt;Webpack 学习文档&lt;/h1&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>http2介绍</title>
    <link href="http://yoursite.com/2019/01/08/technique-sharing/2018/http2%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/01/08/technique-sharing/2018/http2介绍/</id>
    <published>2019-01-08T06:00:00.000Z</published>
    <updated>2020-03-25T10:24:48.082Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="为什么要使用HTTP2"><a href="#为什么要使用HTTP2" class="headerlink" title="为什么要使用HTTP2"></a>为什么要使用HTTP2</h1><h2 id="原因就是慢"><a href="#原因就是慢" class="headerlink" title="原因就是慢"></a>原因就是慢</h2><pre><code>影响一个网络请求的因素主要有两个，带宽和延迟。今天的网络基础建设已经使得带宽得到极大的提升，大部分时候都是延迟在影响。**为什么延迟？？**</code></pre><ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4<br>个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li><li>连接无法复用。每回请求个资源就会有一个请求连接跟断开连接操作，大量请求不断的请求连接跟断开连接时间开销大。<a id="more"></a></li></ul><h2 id="如何高响应速度？pipelining的出现"><a href="#如何高响应速度？pipelining的出现" class="headerlink" title="如何高响应速度？pipelining的出现"></a>如何高响应速度？pipelining的出现</h2><p><img src="https://sfault-image.b0.upaiyun.com/730/391/730391669-573002ce11248_articlex" alt="HTTP1.0 -&gt; HTTP1.1"><br>前文介绍，HTTP 连接无法复用会导致每次请求都经历三次握手和慢启动。由图可知pipelining可有效减少握手时间。</p><p>不过pipelining并不是救世主，它也存在不少缺陷：</p><ol><li>pipelining只能适用于http1.1，一般来说，支持http1.1的server都要求支持pipelining</li><li>只有幂等的请求（GET，HEAD）能使用pipelining，非幂等请求比如POST不能使用，因为请求之间可能会存在先后依赖关系。</li><li>head of line blocking并没有完全得到解决，server的response还是要求依次返回，遵循FIFO(first in first out)原则。也就是说如果请求1的response没有回来，2，3，4，5的response也不会被送回来。</li><li>绝大部分的http代理服务器不支持pipelining。</li><li>和不支持pipelining的老服务器协商有问题。</li><li>可能会导致新的Front of queue blocking问题。</li></ol><h2 id="普通的-HTTPS-网站浏览会比-HTTP-网站稍微慢一些，因为需要处理加密任务。"><a href="#普通的-HTTPS-网站浏览会比-HTTP-网站稍微慢一些，因为需要处理加密任务。" class="headerlink" title="普通的 HTTPS 网站浏览会比 HTTP 网站稍微慢一些，因为需要处理加密任务。"></a>普通的 HTTPS 网站浏览会比 HTTP 网站稍微慢一些，因为需要处理加密任务。</h2><h1 id="HTTP2-VS-HTTP1-1"><a href="#HTTP2-VS-HTTP1-1" class="headerlink" title="HTTP2 VS HTTP1.1"></a>HTTP2 VS HTTP1.1</h1><ol><li>多路复用。<br>多路复用通过多个请求stream共享一个tcp连接的方式（即所有的HTTP2.0的请求都在一个TCP链接上），解决了http1.x holb（head of line blocking）的问题，降低了延迟同时提高了带宽的利用率。<br><img src="https://sfault-image.b0.upaiyun.com/126/067/1260679140-573002cec3232_articlex" alt="多路复用"></li><li>压缩头部。<br>HTTP/2.0规定了在客户端和服务器端会使用并且维护「首部表」来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次。<br>如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。<br>由于减少了大量请求头数据的传输，缓解了网络压力，也提高了响应速度。<br><img src="http://7xs2h9.com1.z0.glb.clouddn.com/blog/Header%E5%A4%8D%E7%94%A8.png" alt="压缩头部"></li><li>二进制分帧<br>在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动HTTP的语义，HTTP 方法、状态码、URI及首部字段的情况下，突破HTTP1.1的性能限制，改进传输性能，实现低延迟和高吞吐量。”<br>在二进制分帧层上，HTTP2.0会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。<br><img src="http://7xs2h9.com1.z0.glb.clouddn.com/blog/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7.png" alt="二进制分帧"></li><li>并行双向字节流的请求和响应<br>在HTTP2.0上，客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收服务器的响应，而服务器那端同理。<br><img src="http://i.imgur.com/WDzDClq.png" alt="并行双向字节流的请求和响应"></li><li>请求优先级<br>多路复用导致所有资源都是并行发送，那么就需要「优先级」的概念了，这样就可以对重要的文件进行先传输，加速页面的渲染。</li><li>服务器推送<br>服务器推送是指在客户端请求之前发送数据的机制。（根据请求资源猜测你可能还需要某某资源，提前推送资源缓存提高响应效率）</li></ol><h1 id="nginx升级HTTP2"><a href="#nginx升级HTTP2" class="headerlink" title="nginx升级HTTP2"></a>nginx升级HTTP2</h1><h3 id="升级准备"><a href="#升级准备" class="headerlink" title="升级准备"></a>升级准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、安装编译器</span><br><span class="line">yum -y install gc gcc gcc-c++   pcre* perl*</span><br><span class="line">2、下载安装包</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.2.tar.gz</span><br><span class="line">wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.2e.tar.gz</span><br><span class="line">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class="line">3、解压安装包</span><br><span class="line">tar -zxvf nginx-1.12.2.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.2e.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br></pre></td></tr></table></figure><h3 id="安装zlib"><a href="#安装zlib" class="headerlink" title="安装zlib"></a>安装zlib</h3><blockquote><p>1、cd zlib<br> 2、./configure<br> 3、make<br> 4、make install</p></blockquote><h3 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h3><blockquote><h2 id="1、cd-openssl"><a href="#1、cd-openssl" class="headerlink" title="1、cd openssl"></a>1、cd openssl</h2><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><p>   ./config shared zlib<br>   make<br>   make install<br>   cd /usr/local/ssl/<br>   ./bin/openssl version -a</p><h2 id="3、替换旧版OpenSSL"><a href="#3、替换旧版OpenSSL" class="headerlink" title="3、替换旧版OpenSSL"></a>3、替换旧版OpenSSL</h2><p>   mv /usr/bin/openssl /usr/bin/openssl.old<br>   mv /usr/include/openssl /usr/include/openssl.old<br>   ln -s /usr/local/ssl/bin/openssl /usr/bin/openssl<br>   ln -s /usr/local/ssl/include/openssl/ /usr/include/openssl</p><h2 id="4、配置库文件搜索路径"><a href="#4、配置库文件搜索路径" class="headerlink" title="4、配置库文件搜索路径"></a>4、配置库文件搜索路径</h2><p>   echo “/usr/local/ssl/lib” &gt;&gt; /etc/ld.so.conf<br>   ldconfig</p><h2 id="5、测试新版本的OpenSSL是否正常工作"><a href="#5、测试新版本的OpenSSL是否正常工作" class="headerlink" title="5、测试新版本的OpenSSL是否正常工作"></a>5、测试新版本的OpenSSL是否正常工作</h2><p>   openssl version -a</p></blockquote><h3 id="4、安装nginx"><a href="#4、安装nginx" class="headerlink" title="4、安装nginx"></a>4、安装nginx</h3><blockquote><h2 id="1、查看ngixn版本及其编译参数，复制你已经编译安装好的模块。"><a href="#1、查看ngixn版本及其编译参数，复制你已经编译安装好的模块。" class="headerlink" title="1、查看ngixn版本及其编译参数，复制你已经编译安装好的模块。"></a>1、查看ngixn版本及其编译参数，复制你已经编译安装好的模块。</h2><p>   nginx -V</p><h2 id="2、进入nginx源码目录"><a href="#2、进入nginx源码目录" class="headerlink" title="2、进入nginx源码目录"></a>2、进入nginx源码目录</h2><p>   cd nginx<br>   执行（在原有的参数上加上–with-zlib=/usr/local/zlib-1.2.11    –with-openssl=/usr/local/openssl-1.0.2e重编译，如下例：）<br>   ./configure  –prefix=/etc/nginx –sbin-path=/usr/sbin/nginx –modules-path=/usr/lib64/nginx/modules –conf-path=/etc/nginx/nginx.conf –error-log-path=/var/log/nginx/error.log –http-log-path=/var/log/nginx/access.log –pid-path=/var/run/nginx.pid –lock-path=/var/run/nginx.lock –http-client-body-temp-path=/var/cache/nginx/client_temp –http-proxy-temp-path=/var/cache/nginx/proxy_temp –http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp –http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp –http-scgi-temp-path=/var/cache/nginx/scgi_temp –user=nginx –group=nginx –with-compat –with-file-aio –with-threads –with-http_addition_module –with-http_auth_request_module –with-http_dav_module –with-http_flv_module –with-http_gunzip_module –with-http_gzip_static_module –with-http_mp4_module –with-http_random_index_module –with-http_realip_module –with-http_secure_link_module –with-http_slice_module –with-http_ssl_module –with-http_stub_status_module –with-http_sub_module –with-http_v2_module –with-mail –with-mail_ssl_module –with-stream –with-stream_realip_module –with-stream_ssl_module –with-stream_ssl_preread_module   –with-zlib=/usr/local/zlib-1.2.11 –with-openssl=/usr/local/openssl-1.0.2e  –with-pcre</p><h2 id="3、然后"><a href="#3、然后" class="headerlink" title="3、然后"></a>3、然后</h2><p>   make   //千万别make install，否则就覆盖安装了<br>   make完之后在objs目录下就多了个nginx，这个就是新版本的程序了</p><h2 id="4、验证新nginx是否可用验证编译后的nginx是否可以使用已有的配置"><a href="#4、验证新nginx是否可用验证编译后的nginx是否可以使用已有的配置" class="headerlink" title="4、验证新nginx是否可用验证编译后的nginx是否可以使用已有的配置"></a>4、验证新nginx是否可用验证编译后的nginx是否可以使用已有的配置</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;objs&#x2F;nginx -t</span><br></pre></td></tr></table></figure><blockquote><h2 id="5、备份旧的nginx："><a href="#5、备份旧的nginx：" class="headerlink" title="5、备份旧的nginx："></a>5、备份旧的nginx：</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx.bak</span><br></pre></td></tr></table></figure><blockquote><h2 id="6、把新的nginx程序覆盖旧的："><a href="#6、把新的nginx程序覆盖旧的：" class="headerlink" title="6、把新的nginx程序覆盖旧的："></a>6、把新的nginx程序覆盖旧的：</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp .&#x2F;objs&#x2F;nginx &#x2F;usr&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure><blockquote><h2 id="7、测试新的nginx程序是否正确"><a href="#7、测试新的nginx程序是否正确" class="headerlink" title="7、测试新的nginx程序是否正确"></a>7、测试新的nginx程序是否正确</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><blockquote><h2 id="8、修改Nginx的-conf-文件"><a href="#8、修改Nginx的-conf-文件" class="headerlink" title="8、修改Nginx的 .conf 文件"></a>8、修改Nginx的 .conf 文件</h2><p>   在监听443的后面加上http2，如下：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 443 ssl http2 default_server;</span><br><span class="line">server_name www.jiezaizone.cn; </span><br><span class="line">ssl on;</span><br><span class="line">ssl_certificate &#x2F;etc&#x2F;nginx&#x2F;1_jiezaizone.cn_bundle.crt;</span><br><span class="line">ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;2_jiezaizone.cn.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2; </span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">root   &#x2F;; </span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   注：某些服务开启http2后不能访问，在http2 后面加上 default_server 就可以了</p><h2 id="9、重新加载nginx"><a href="#9、重新加载nginx" class="headerlink" title="9、重新加载nginx"></a>9、重新加载nginx</h2></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="安装异常及其解决方法"><a href="#安装异常及其解决方法" class="headerlink" title="安装异常及其解决方法"></a>安装异常及其解决方法</h3><blockquote><p>异常1：<br>/usr/bin/ld: /usr/local/lib/libz.a(crc32.o): relocation R_X86_64_32 against `a local symbol’ can not be used when making a shared object; recompile with -fPIC</p></blockquote><blockquote><p>/usr/local/lib/libz.a: could not read symbols: Bad value<br>处理方法:<br>cd zlib-1.2.3 //进入zlib目录</p></blockquote><blockquote><p>CFLAGS=”-O3 -fPIC” ./configure   //使用64位元的方法进行编译</p></blockquote><blockquote><p>make</p></blockquote><blockquote><p>异常2：<br>/usr/bin/ld: /etc/nginx/openssl-1.0.2e/.openssl/lib/libssl.a(s23_meth.o): relocation R_X86_64_32 against `.rodata’ can not be used when making a shared object; recompile with -fPIC<br>   解决方法：<br>   cd openssl<br>   ./config -fPIC –prefix=/usr/local/openssl/ enable-shared<br>   make</p></blockquote><p>​    </p><h1 id="测试环境运营系统已经全面支持https"><a href="#测试环境运营系统已经全面支持https" class="headerlink" title="测试环境运营系统已经全面支持https"></a>测试环境运营系统已经全面支持https</h1><p>1、仓库已经push了nginx1.11.1，直接支持http2，可通过下述命令直接拉取下拉使用<br>docker pull docker.oa.isuwang.com:5000/system/nginx:1.11.1<br>2、在我们的nginx项目http2分支，已经写好了构建支持http2的nginx dockerdile，可直接下载下拉查看。<br><a href="http://git.oa.isuwang.com/isuwang-docker/nginx.git" target="_blank" rel="noopener">http://git.oa.isuwang.com/isuwang-docker/nginx.git</a></p><p>提问：</p><ol><li>HTTPS有并发吗，如何实现的？一个连接怎么实现并发呢</li><li>http2的长连接是怎么回事</li></ol><p>答：</p><ol><li>http2有并发。它支持多路复用，并行双向字节流的请求和响应，它以“流”的形式在客户端和服务器间独立的双向的交换的帧序列。流具有一些重要的特性：<ul><li>单个的HTTP/2连接可以包含多个并发打开的流，各个终端多个流的帧可以交叉。</li><li>流可以单方面地建立和使用，或由客户端或服务器共享。</li><li>流可以被任何一端关闭。</li><li>流中帧的发送顺序是值得注意的。接收者以它们收到帧的顺序处理。特别的，HEADERS帧和DATA帧在语义上是非常重要的。</li><li>流由一个整数标识。流标识符由发起流的一端来赋值。</li></ul></li></ol><p>虽然只有一个TCP连接，却能够在这个连接同时处理客户端和服务端的多个数据传输。<br>2. HTTP2只有一个TCP连接，它并不像http1.1中的TCP连接一样，在处理当前传输数据后就关闭，而是一直连通的，客户端和服务端可以通过它持续往返传输数据。这个TCP流的传输通道，是可以被任何一端给关闭的。</p><p>@By：刘荣杰</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;为什么要使用HTTP2&quot;&gt;&lt;a href=&quot;#为什么要使用HTTP2&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用HTTP2&quot;&gt;&lt;/a&gt;为什么要使用HTTP2&lt;/h1&gt;&lt;h2 id=&quot;原因就是慢&quot;&gt;&lt;a href=&quot;#原因就是慢&quot; class=&quot;headerlink&quot; title=&quot;原因就是慢&quot;&gt;&lt;/a&gt;原因就是慢&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;影响一个网络请求的因素主要有两个，带宽和延迟。今天的网络基础建设已经使得带宽得到极大的提升，大部分时候都是延迟在影响。

**为什么延迟？？**&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4&lt;br&gt;个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。&lt;/li&gt;
&lt;li&gt;DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。&lt;/li&gt;
&lt;li&gt;建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。&lt;/li&gt;
&lt;li&gt;连接无法复用。每回请求个资源就会有一个请求连接跟断开连接操作，大量请求不断的请求连接跟断开连接时间开销大。
    
    </summary>
    
    
      <category term="iplas" scheme="http://yoursite.com/tags/iplas/"/>
    
      <category term="http2" scheme="http://yoursite.com/tags/http2/"/>
    
  </entry>
  
  <entry>
    <title>Sql注入 解决方案</title>
    <link href="http://yoursite.com/2019/01/04/technique-sharing/2019/Sql%E6%B3%A8%E5%85%A5%E9%A2%84%E9%98%B2/"/>
    <id>http://yoursite.com/2019/01/04/technique-sharing/2019/Sql注入预防/</id>
    <published>2019-01-04T06:00:00.000Z</published>
    <updated>2020-03-27T02:15:35.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记一次Sql注入-解决方案"><a href="#记一次Sql注入-解决方案" class="headerlink" title="记一次Sql注入 解决方案"></a>记一次Sql注入 解决方案</h3><p>老大反馈代码里面存在sql注入，这个漏洞会导致系统遭受攻击，定位到对应的代码，如下图所示</p><p><img src="/images/8D7C6C95-0D95-43d6-85AE-0128D12FF1BB.png" alt=""></p><p>like 进行了一个字符串拼接，正常的情况下，前端传一个 cxk 过来，那么执行的sql就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where name like &#39;%cxk%&#39;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>好像没有什么问题，但是，如果被攻击了传了个 cxk%’; DELETE FROM test WHERE name like ‘%cxk</p><p>那么 这条sql 将会拼接成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from test where name like &#39;%cxk%&#39;; DELETE FROM test WHERE name like &#39;%cxk%&#39;;</span><br></pre></td></tr></table></figure><p>执行不会报错，结果是 name  like cxk 的数据全部删除，这个还是比较温柔的sql注入，如果是 drop table ，那不是要原地爆炸?</p><p>既然Sql 注入危害这么大，那么怎么防范呢？</p><p>采用sql语句预编译和绑定变量，是最简单，也是最有效的方案.</p><p>那什么是预编译呢？</p><p>like this </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  * from test where name like ?  args: WrappedArray(JdbcValue(%cxk%))</span><br></pre></td></tr></table></figure><p>先是 select  * from test where name like ? 这样预编译好，然后传进来的数据以参数化的形式执行sql,就可以防止sql 注入。</p><p>为什么这样可以防止sql 注入呢？</p><p>分别给两种场景测试</p><p>1.likeString </p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def likeString(name:String) &#x3D;&#123;</span><br><span class="line">    dataSource.rows[Test](sql&quot; select  * from test where name like  &quot;+s&quot;&#39;%$&#123;name&#125;%&#39;&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输入 cxk%’; DELETE FROM test WHERE name like ‘%cxk</p><p>打断点可以看到</p><p><img src="/images/sql18.png" alt=""></p><p>将statement 中的值复制出来 到navicat 中，可以看到 </p><p><img src="/images/sql16.png" alt=""></p><p>那么jdbc 执行就会 直接执行，然后把cxk 删了。</p><p>2.like</p><p>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def like(name:String) &#x3D;&#123;</span><br><span class="line">   &#x2F;&#x2F; cxu</span><br><span class="line">   &#x2F;&#x2F; %cku%</span><br><span class="line">   dataSource.rows[Test](sql&quot; select  * from test where name like $&#123;name.likeSql&#125;&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> implicit class StringBuildSqlLikeImplicit(s:String)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   def likeSql: String &#x3D;&#123;</span><br><span class="line">     s&quot;%$&#123;s&#125;%&quot;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   def likeLeftSql: String &#x3D; &#123;</span><br><span class="line">      s&quot;%$&#123;s&#125;&quot;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   def likeRightSql: String &#x3D;&#123;</span><br><span class="line">     s&quot;$&#123;s&#125;%&quot;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输入 cxk%’; DELETE FROM test WHERE name like ‘%cxk</p><p>打断点可以看到</p><p><img src="/images/sql13.png" alt=""></p><p><img src="/images/sql14.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到 statement &#x3D;   select  * from test where name like ** NOT SPECIFIED **</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PreparedStatement.setString(1,&#39;cxk%&#39;; DELETE FROM test WHERE name like &#39;%cxk&#39;)</span><br></pre></td></tr></table></figure><p>之后，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statement &#x3D; </span><br><span class="line">select  * from test where name like &#39;%cxk\&#39;; DELETE FROM test WHERE name like \&#39;%cxk%&#39;</span><br></pre></td></tr></table></figure><p>将statement 中的值复制出来 到navicat 中，可以看到 </p><p><img src="/images/sql15.png" alt=""></p><p>string 内部的; % 被格式化， 这样执行的话，内部的sql 就以字符串的形式存在，这样避免了Sql 注入。</p><p>那 PreparedStatement 是这么做到的呢， 主要的原因是 PreparedStatement.setString(int parameterIndex, String x)</p><p>这里面会对x 进行一个格式化</p><p>判断是否需要格式化</p><p><img src="/images/20191114195945.png" alt=""></p><p>贴上源码  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private boolean isEscapeNeededForString(String x, int stringLength) &#123;</span><br><span class="line">    boolean needsHexEscape &#x3D; false;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; stringLength; ++i) &#123;</span><br><span class="line">        char c &#x3D; x.charAt(i);</span><br><span class="line"></span><br><span class="line">        switch (c) &#123;</span><br><span class="line">            case 0: &#x2F;* Must be escaped for &#39;mysql&#39; *&#x2F;</span><br><span class="line"></span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &#39;\n&#39;: &#x2F;* Must be escaped for logs *&#x2F;</span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &#39;\r&#39;:</span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &#39;\\&#39;:</span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &#39;\&#39;&#39;:</span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &#39;&quot;&#39;: &#x2F;* Better safe than sorry *&#x2F;</span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line"></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &#39;\032&#39;: &#x2F;* This gives problems on Win32 *&#x2F;</span><br><span class="line">                needsHexEscape &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (needsHexEscape) &#123;</span><br><span class="line">            break; &#x2F;&#x2F; no need to scan more</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return needsHexEscape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 它会对传进来的参数判断，如果含有一些非法字符会判断传过来的值需要格式化， 那它是怎么格式化的呢？  我们看下源码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; setString  里的部分源码</span><br><span class="line"></span><br><span class="line">  if (this.isLoadDataQuery || isEscapeNeededForString(x, stringLength)) &#123;</span><br><span class="line">                    needsQuoted &#x3D; false; &#x2F;&#x2F; saves an allocation later</span><br><span class="line"></span><br><span class="line">                    StringBuilder buf &#x3D; new StringBuilder((int) (x.length() * 1.1));</span><br><span class="line"></span><br><span class="line">                    buf.append(&#39;\&#39;&#39;);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;</span><br><span class="line">                    &#x2F;&#x2F; Note: buf.append(char) is _faster_ than appending in blocks, because the block append requires a System.arraycopy().... go figure...</span><br><span class="line">                    &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">                    for (int i &#x3D; 0; i &lt; stringLength; ++i) &#123;</span><br><span class="line">                        char c &#x3D; x.charAt(i);</span><br><span class="line"></span><br><span class="line">                        switch (c) &#123;</span><br><span class="line">                            case 0: &#x2F;* Must be escaped for &#39;mysql&#39; *&#x2F;</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line">                                buf.append(&#39;0&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;\n&#39;: &#x2F;* Must be escaped for logs *&#x2F;</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line">                                buf.append(&#39;n&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;\r&#39;:</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line">                                buf.append(&#39;r&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;\\&#39;:</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;\&#39;&#39;:</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line">                                buf.append(&#39;\&#39;&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;&quot;&#39;: &#x2F;* Better safe than sorry *&#x2F;</span><br><span class="line">                                if (this.usingAnsiMode) &#123;</span><br><span class="line">                                    buf.append(&#39;\\&#39;);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                buf.append(&#39;&quot;&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;\032&#39;: &#x2F;* This gives problems on Win32 *&#x2F;</span><br><span class="line">                                buf.append(&#39;\\&#39;);</span><br><span class="line">                                buf.append(&#39;Z&#39;);</span><br><span class="line"></span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line">                            case &#39;\u00a5&#39;:</span><br><span class="line">                            case &#39;\u20a9&#39;:</span><br><span class="line">                                &#x2F;&#x2F; escape characters interpreted as backslash by mysql</span><br><span class="line">                                if (this.charsetEncoder !&#x3D; null) &#123;</span><br><span class="line">                                    CharBuffer cbuf &#x3D; CharBuffer.allocate(1);</span><br><span class="line">                                    ByteBuffer bbuf &#x3D; ByteBuffer.allocate(1);</span><br><span class="line">                                    cbuf.put(c);</span><br><span class="line">                                    cbuf.position(0);</span><br><span class="line">                                    this.charsetEncoder.encode(cbuf, bbuf, true);</span><br><span class="line">                                    if (bbuf.get(0) &#x3D;&#x3D; &#39;\\&#39;) &#123;</span><br><span class="line">                                        buf.append(&#39;\\&#39;);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F; fall through</span><br><span class="line"></span><br><span class="line">                            default:</span><br><span class="line">                                buf.append(c);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    buf.append(&#39;\&#39;&#39;);</span><br><span class="line"></span><br><span class="line">                    parameterAsString &#x3D; buf.toString();</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，会讲’ 加一个’&#39;  那么原传入的Sring 就会被格式化成上文所说。<br>打断点我们可以看到</p><p><img src="/images/sql21.png" alt=""></p><p>这一块是jdbc PreparedStatement  对SQL注入的防范。</p><p>从网上我还看到了一些这样的 </p><p>那么，什么是所谓的“precompiled SQL statement”呢？</p><p>回答这个问题之前需要先了解下一个SQL文在DB中执行的具体步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.Convert given SQL query into DB format -- 将SQL语句转化为DB形式（语法树结构）</span><br><span class="line">2.Check for syntax -- 检查语法</span><br><span class="line">3.Check for semantics -- 检查语义</span><br><span class="line">4.Prepare execution plan -- 准备执行计划（也是优化的过程，这个步骤比较重要，关系到你SQL文的效率，准备在后续文章介绍）</span><br><span class="line">5.Set the run-time values into the query -- 设置运行时的参数</span><br><span class="line">6.Run the query and fetch the output -- 执行查询并取得结果</span><br></pre></td></tr></table></figure><p>出自  <a href="https://www.cnblogs.com/roostinghawk/p/9703806.html" target="_blank" rel="noopener">是如何防止SQL注入的</a></p><p>打断点调试的时候看到，PreparedStatement 最终还是会转化成statement 然后执行，<br>jdbc 这么做应该是做应该是为了 mysql 的缓存机制，我们知道，mysql 进行select 查询的时候，会有一个缓存机制，如果执行语句一致的话，就会拿mysql 的缓存直接获取数据，如果以参数形式传到mysql 的话，这样就没有办法命中缓存了（个人看法，错误请佐证）。</p><p> 综上所述，SQL注入，用PreparedStatement 防治是可以防治的，代码中也尽量用 PreparedStatement 这种形式。</p><p> 题外话，那么这个是jdbc 的做法，那其他的框架是怎么解决SQL 注入的呢?</p><h4 id="PHP-防治Sql注入"><a href="#PHP-防治Sql注入" class="headerlink" title="PHP 防治Sql注入"></a>PHP 防治Sql注入</h4><p>  1.通过函数去对一些特殊字符进行处理  例如 addslashes($str) ，mysql_escape_string($str)</p><p>  2.预编译的做法</p><h4 id="Node-防治SQL-注入"><a href="#Node-防治SQL-注入" class="headerlink" title="Node 防治SQL 注入"></a>Node 防治SQL 注入</h4><p> 1.使用escape()对传入参数进行编码，</p><p> 2.使用connection.query()的查询参数占位符：（预编译）</p><p> 3.使用escapeId()编码SQL查询标识符：</p><p> 4.使用mysql.format()转义参数：</p><p>参考文章 <a href="https://blog.csdn.net/lin_tuer/article/details/54809330" target="_blank" rel="noopener">node-mysql中防止SQL注入</a></p><p>@by 蒙初开</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;记一次Sql注入-解决方案&quot;&gt;&lt;a href=&quot;#记一次Sql注入-解决方案&quot; class=&quot;headerlink&quot; title=&quot;记一次Sql注入 解决方案&quot;&gt;&lt;/a&gt;记一次Sql注入 解决方案&lt;/h3&gt;&lt;p&gt;老大反馈代码里面存在sql注入，这个漏洞会导致系统遭受攻击，定位到对应的代码，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/8D7C6C95-0D95-43d6-85AE-0128D12FF1BB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;like 进行了一个字符串拼接，正常的情况下，前端传一个 cxk 过来，那么执行的sql就是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from test where name like &amp;#39;%cxk%&amp;#39;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nuxt.js</title>
    <link href="http://yoursite.com/2019/01/03/technique-sharing/2019/nuxt.js%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/03/technique-sharing/2019/nuxt.js学习/</id>
    <published>2019-01-03T06:00:00.000Z</published>
    <updated>2020-03-25T10:24:48.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nuxt-js简介"><a href="#nuxt-js简介" class="headerlink" title="nuxt.js简介"></a>nuxt.js简介</h2><p>nuxt.js是一个基于vue.js的通用框架，集成了Vue 2、Vue-Router、Vuex、Vue-ssr(服务端渲染)、Vue-Meta，最常用的是用来作ssr（服务端渲染）。这里，我们先来科普一下服务端渲染跟客户端渲染的区别.</p><a id="more"></a><h3 id="1-服务端渲染与客户端渲染"><a href="#1-服务端渲染与客户端渲染" class="headerlink" title="(1)服务端渲染与客户端渲染"></a>(1)服务端渲染与客户端渲染</h3><p><img src="https://upload-images.jianshu.io/upload_images/13541244-4634f4ddea06b8d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务端渲染与客户端渲染过程对比图.png"><br>最大的区别，简单点来说就是责任越大压力越大(谁渲染谁压力大)<br>1)服务端渲染优缺点：<br>优点：前端耗时少、有利于SEO、无需占用客户端资源、后端生成静态文件<br>缺点：不利于前后端分离、占用服务器资源<br>适用于应用交互不太复杂需要良好的SEO且服务器性能好<br>2)客户端渲染优缺点：<br>优点：有利于前后端分离、服务器压力小<br>缺点：前端响应慢、不利于SEO<br>适用于应用交互复杂且不需要良好的SEO，例如企业内部系统</p><h3 id="2-Vue-ssr"><a href="#2-Vue-ssr" class="headerlink" title="(2)Vue ssr"></a>(2)Vue ssr</h3><p>既然nuxt.js最常用是用来做ssr，那就更有必要提一下Vue SSR了。一目了然，它是基于vue.js的服务端渲染。主要渲染插件是：vue-server-renderer，官网给出的流程图如下：<br><img src="https://upload-images.jianshu.io/upload_images/13541244-3d8ef5729011b4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vue-server-renderer流程图.png"><br>可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。<br>source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象。<br>关于vue-ssr的配置使用，不是本篇文章的重点，就不一一详述了。具体参见<a href="https://ssr.vuejs.org/zh/guide/" target="_blank" rel="noopener">vue-ssr官网</a></p><h3 id="3-nuxt-js的使用"><a href="#3-nuxt-js的使用" class="headerlink" title="(3)nuxt.js的使用"></a>(3)nuxt.js的使用</h3><p>前面科普了一大堆，只是为了让我们能更好的上手nuxt.js。<br>1)使用npx或者yarn两种方式下载<br><code>npx create-nuxt-app &lt;项目名&gt;</code><br><code>yarn create nuxt-app &lt;项目名&gt;</code><br>2)接着需要你做一些选择，下载方式、UI框架、集成的服务端框架、语法校验等等，做完选择后会帮你安装相关依赖。<br>3)完成后，进入文件夹，运行<code>npm run dev</code>即可<br>4)nuxt.js概述：<br><img src="https://upload-images.jianshu.io/upload_images/13541244-4212d977471bec70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nuxt.js.png"><br>5）一些常用配置<br>js、css引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">css: [</span><br><span class="line">    &#39;iview&#x2F;dist&#x2F;styles&#x2F;iview.css&#39;</span><br><span class="line">  ],</span><br><span class="line"> plugins: [</span><br><span class="line">    &#39;@&#x2F;plugins&#x2F;iview&#39;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>修改网站icon<br>icon.png文件存放在static文件夹下，nuxt.config.js中配置head属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">head: &#123;</span><br><span class="line">    title: process.env.npm_package_name || &#39;&#39;,</span><br><span class="line">    meta: [</span><br><span class="line">      &#123; charset: &#39;utf-8&#39; &#125;,</span><br><span class="line">      &#123; name: &#39;viewport&#39;, content: &#39;width&#x3D;device-width, initial-scale&#x3D;1&#39; &#125;,</span><br><span class="line">      &#123; hid: &#39;description&#39;, name: &#39;description&#39;, content: process.env.npm_package_description || &#39;&#39; &#125;</span><br><span class="line">    ],</span><br><span class="line">    link: [</span><br><span class="line">      &#123; rel: &#39;icon&#39;, type: &#39;image&#x2F;x-icon&#39;, href: &#39;&#x2F;favicon.ico&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>中间件的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局使用</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: &#39;中间件名称&#39;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;页面单独使用</span><br><span class="line">export default &#123;</span><br><span class="line">    middleware: &#39;中间件名称&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于nuxt.config.js的其他配置，官网说得很详细，可以直接在<a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">官网</a>学习使用。</p><h2 id="nuxt-js一些常用操作"><a href="#nuxt-js一些常用操作" class="headerlink" title="nuxt.js一些常用操作"></a>nuxt.js一些常用操作</h2><h3 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h3><p>只要我们在pages创建新的vue页面时，运行时.nuxt包中的router.js就会自动生成路由地址。<br><img src="https://upload-images.jianshu.io/upload_images/13541244-397e541a98b32c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成路由地址"></p><h3 id="1-路由跳转"><a href="#1-路由跳转" class="headerlink" title="(1)路由跳转"></a>(1)路由跳转</h3><p>路由跳转有两种方式，router-link与nuxt-link,使用方式跟原来vue一样</p><figure class="highlight plain"><figcaption><span>to</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nuxt-link :to&#x3D;&quot;&#123;name:&#39;user-id&#39;,params:&#123;id:2&#125;&#125;&quot;&gt;页面跳转2&lt;&#x2F;nuxt-link&gt;</span><br></pre></td></tr></table></figure><p>也可以使用<br><code>this.$router.push({name:&#39;user-id&#39;})</code></p><h3 id="2-关于带参数的路由地址校验"><a href="#2-关于带参数的路由地址校验" class="headerlink" title="(2)关于带参数的路由地址校验"></a>(2)关于带参数的路由地址校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">       validate (&#123; params &#125;) &#123;</span><br><span class="line">       &#x2F;&#x2F; 路由参数校验，必须是一个数字,如果校验失败，抛出异常</span><br><span class="line">       if(&#x2F;^\d+$&#x2F;.test(params.id))&#123;</span><br><span class="line">        return true</span><br><span class="line">       &#125;</span><br><span class="line">       throw new Error(&#39;Under Construction!&#39;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在跳转页面的js中加上validate校验，这样在页面预渲染时就会自动校验路由参数是否符合规范，否则抛出异常</p><h3 id="3-页面是否必须已登录才能访问"><a href="#3-页面是否必须已登录才能访问" class="headerlink" title="(3)页面是否必须已登录才能访问"></a>(3)页面是否必须已登录才能访问</h3><p>在没有使用nuxt.js框架时，我们可以采取的办法一般有：在配置路由时，给路由加个meta:{isHadLogin: true},再通过router.beforeEach判断,简单例子如下：</p><figure class="highlight plain"><figcaption><span>Vue from 'vue'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import Store from &#39;..&#x2F;vuex&#x2F;store&#39;</span><br><span class="line">Vue.use(Router)</span><br><span class="line">const route &#x3D; [&#123;</span><br><span class="line">    path: &quot;&#x2F;login&quot;,</span><br><span class="line">    component:()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;login&#39;),</span><br><span class="line">    name: &quot;login&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;One&quot;,</span><br><span class="line">    component: ()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;user&#x2F;one&#39;),</span><br><span class="line">    name: &quot;user-One&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;:id&quot;,</span><br><span class="line">    component: ()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;user&#x2F;_id&#39;),</span><br><span class="line">    name: &quot;user-id&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;&quot;,</span><br><span class="line">    component:()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;index&#39;),</span><br><span class="line">    name: &quot;index&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;:slug&#x2F;component&quot;,</span><br><span class="line">    component: ()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;_slug&#x2F;component&#39;),</span><br><span class="line">    name: &quot;slug-component&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)]</span><br><span class="line">const router &#x3D; new Router(&#123;</span><br><span class="line">  mode:&#39;history&#39;,</span><br><span class="line">  route</span><br><span class="line">&#125;)</span><br><span class="line">router.beforeEach((to,from,next)&#x3D;&gt;&#123;</span><br><span class="line">  store.dispatch(&#39;getCurrentUser&#39;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 未登录，需要登录跳转到登录页面</span><br><span class="line">    if (to.meta.isHadLogin &amp;&amp; !Store.state.authUser) &#123;</span><br><span class="line">      window.location.href &#x3D; &#39;localhost:1000&#x2F;login&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用nuxt.js框架的话，需要在middleware(中间件)中加个控制，需要登录才能访问的页面再加个middleware配置即可。例如：<br>文件地址：middleware/auth.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function (&#123; store, redirect &#125;) &#123;</span><br><span class="line">  if (!store.state.authUser) &#123;</span><br><span class="line">    &#x2F;&#x2F; error(&#123;</span><br><span class="line">    &#x2F;&#x2F;   message: &#39;You are not connected&#39;,</span><br><span class="line">    &#x2F;&#x2F;   statusCode: 403</span><br><span class="line">    &#x2F;&#x2F; &#125;)</span><br><span class="line">    return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要登录才能访问的页面配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  middleware: &#39;auth&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置之后，在跳转到该页面时，如果没有登录，就会跳到登录页面。</p><h3 id="axios跨域请求"><a href="#axios跨域请求" class="headerlink" title="axios跨域请求"></a>axios跨域请求</h3><p>在nuxt项目中，是默认安装axios，但跨域请求，有点小区别于非nuxt.js的项目。<br>在没有使用nuxt.js时，我们在vue.config.js文件中配置proxy代理，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        devServer: &#123;</span><br><span class="line">           port: 8085, &#x2F;&#x2F; 端口号</span><br><span class="line">            host: &#39;127.0.0.1&#39;,</span><br><span class="line">            https: false ,</span><br><span class="line">            proxy: &#123;</span><br><span class="line">              &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">                target: &#39;http:&#x2F;&#x2F;localhost:9094&#39;, &#x2F;&#x2F; 对应自己的接口</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                ws: true,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                  &#39;^&#x2F;api&#x2F;&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在nuxt.js的项目中，我们是在nuxt.config.js中配置proxy代理，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">modules: [</span><br><span class="line">    &#39;@nuxtjs&#x2F;axios&#39;,</span><br><span class="line">    &#39;@nuxtjs&#x2F;proxy&#39;</span><br><span class="line">  ],</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">      target: &#39;http:www.xxx.com&#39;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        &#39;^&#x2F;api &#39;: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-为项目配置固定的ip端口号"><a href="#3-为项目配置固定的ip端口号" class="headerlink" title="3.为项目配置固定的ip端口号"></a>3.为项目配置固定的ip端口号</h3><p>在nuxt.js项目中中，我们是在pagekage.json文件中配置如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">    &quot;nuxt&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">      &quot;port&quot;: &quot;3000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>而本人之前在普通vue项目中，遇到过在vue.config.js设置了固定端口号，可是项目运行起来并不是我原来想要的端口号，在网上找到的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install portfinder@1.0.21</span><br></pre></td></tr></table></figure><p>运行这个命令就可</p><h3 id="4-跨域身份验证"><a href="#4-跨域身份验证" class="headerlink" title="4.跨域身份验证"></a>4.跨域身份验证</h3><p>1）package.json配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;example-auth-jwt&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;cookieparser&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;js-cookie&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">    &quot;nuxt&quot;: &quot;latest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;nuxt&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;nuxt build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;nuxt start&quot;,</span><br><span class="line">    &quot;post-update&quot;: &quot;yarn upgrade --latest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)vuex配置：即store文件夹中的index.js配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const cookieparser &#x3D; process.server ? require(&#39;cookieparser&#39;) : undefined</span><br><span class="line"></span><br><span class="line">export const state &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    auth: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">  setAuth (state, auth) &#123;</span><br><span class="line">    state.auth &#x3D; auth</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const actions &#x3D; &#123;</span><br><span class="line">  nuxtServerInit (&#123; commit &#125;, &#123; req &#125;) &#123;</span><br><span class="line">    let auth &#x3D; null</span><br><span class="line">    if (req.headers.cookie) &#123;</span><br><span class="line">      const parsed &#x3D; cookieparser.parse(req.headers.cookie)</span><br><span class="line">      try &#123;</span><br><span class="line">        auth &#x3D; JSON.parse(parsed.auth)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        &#x2F;&#x2F; No valid cookie found</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    commit(&#39;setAuth&#39;, auth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录页配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const Cookie &#x3D; process.client ? require(&#39;js-cookie&#39;) : undefined</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  middleware: &#39;notAuthenticated&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    postLogin () &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; we simulate the async request with timeout.</span><br><span class="line">        const auth &#x3D; &#123;</span><br><span class="line">          accessToken: &#39;someStringGotFromApiServiceWithAjax&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        this.$store.commit(&#39;setAuth&#39;, auth) &#x2F;&#x2F; mutating to store for client rendering</span><br><span class="line">        Cookie.set(&#39;auth&#39;, auth) &#x2F;&#x2F; saving token in cookie for server rendering</span><br><span class="line">        this.$router.push(&#39;&#x2F;&#39;)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这样，我们就能做出一个跨域带身份认证的登陆了，登录后的信息存在store里面，只要调用this.$store.state.auth即可拿到。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>nuxt.js还有很多优秀的功能供我们使用，但小编的体验还不够深入，所以暂时只能介绍这么多了。以后对nuxt.js有了更深入的体验，再来进一步更新。感恩观看！</p><p>@by 曾晓霞</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nuxt-js简介&quot;&gt;&lt;a href=&quot;#nuxt-js简介&quot; class=&quot;headerlink&quot; title=&quot;nuxt.js简介&quot;&gt;&lt;/a&gt;nuxt.js简介&lt;/h2&gt;&lt;p&gt;nuxt.js是一个基于vue.js的通用框架，集成了Vue 2、Vue-Router、Vuex、Vue-ssr(服务端渲染)、Vue-Meta，最常用的是用来作ssr（服务端渲染）。这里，我们先来科普一下服务端渲染跟客户端渲染的区别.&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="nuxt" scheme="http://yoursite.com/tags/nuxt/"/>
    
      <category term="vue ssr" scheme="http://yoursite.com/tags/vue-ssr/"/>
    
  </entry>
  
  <entry>
    <title>nuxt.js</title>
    <link href="http://yoursite.com/2019/01/03/technique-sharing/2019/nuxt.js%D1%A7%CF%B0/"/>
    <id>http://yoursite.com/2019/01/03/technique-sharing/2019/nuxt.jsѧϰ/</id>
    <published>2019-01-03T06:00:00.000Z</published>
    <updated>2020-03-25T10:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nuxt-js简介"><a href="#nuxt-js简介" class="headerlink" title="nuxt.js简介"></a>nuxt.js简介</h2><p>nuxt.js是一个基于vue.js的通用框架，集成了Vue 2、Vue-Router、Vuex、Vue-ssr(服务端渲染)、Vue-Meta，最常用的是用来作ssr（服务端渲染）。这里，我们先来科普一下服务端渲染跟客户端渲染的区别.</p><a id="more"></a><h3 id="1-服务端渲染与客户端渲染"><a href="#1-服务端渲染与客户端渲染" class="headerlink" title="(1)服务端渲染与客户端渲染"></a>(1)服务端渲染与客户端渲染</h3><p><img src="https://upload-images.jianshu.io/upload_images/13541244-4634f4ddea06b8d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务端渲染与客户端渲染过程对比图.png"><br>最大的区别，简单点来说就是责任越大压力越大(谁渲染谁压力大)<br>1)服务端渲染优缺点：<br>优点：前端耗时少、有利于SEO、无需占用客户端资源、后端生成静态文件<br>缺点：不利于前后端分离、占用服务器资源<br>适用于应用交互不太复杂需要良好的SEO且服务器性能好<br>2)客户端渲染优缺点：<br>优点：有利于前后端分离、服务器压力小<br>缺点：前端响应慢、不利于SEO<br>适用于应用交互复杂且不需要良好的SEO，例如企业内部系统</p><h3 id="2-Vue-ssr"><a href="#2-Vue-ssr" class="headerlink" title="(2)Vue ssr"></a>(2)Vue ssr</h3><p>既然nuxt.js最常用是用来做ssr，那就更有必要提一下Vue SSR了。一目了然，它是基于vue.js的服务端渲染。主要渲染插件是：vue-server-renderer，官网给出的流程图如下：<br><img src="https://upload-images.jianshu.io/upload_images/13541244-3d8ef5729011b4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vue-server-renderer流程图.png"><br>可以看出vue的后端渲染分三个部分组成：页面的源码（source），node层的渲染部分和浏览器端的渲染部分。<br>source分为两种entry point,一个是前端页面的入口client entry,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口server entry,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象。<br>关于vue-ssr的配置使用，不是本篇文章的重点，就不一一详述了。具体参见<a href="https://ssr.vuejs.org/zh/guide/" target="_blank" rel="noopener">vue-ssr官网</a></p><h3 id="3-nuxt-js的使用"><a href="#3-nuxt-js的使用" class="headerlink" title="(3)nuxt.js的使用"></a>(3)nuxt.js的使用</h3><p>前面科普了一大堆，只是为了让我们能更好的上手nuxt.js。<br>1)使用npx或者yarn两种方式下载<br><code>npx create-nuxt-app &lt;项目名&gt;</code><br><code>yarn create nuxt-app &lt;项目名&gt;</code><br>2)接着需要你做一些选择，下载方式、UI框架、集成的服务端框架、语法校验等等，做完选择后会帮你安装相关依赖。<br>3)完成后，进入文件夹，运行<code>npm run dev</code>即可<br>4)nuxt.js概述：<br><img src="https://upload-images.jianshu.io/upload_images/13541244-4212d977471bec70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nuxt.js.png"><br>5）一些常用配置<br>js、css引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">css: [</span><br><span class="line">    &#39;iview&#x2F;dist&#x2F;styles&#x2F;iview.css&#39;</span><br><span class="line">  ],</span><br><span class="line"> plugins: [</span><br><span class="line">    &#39;@&#x2F;plugins&#x2F;iview&#39;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><p>修改网站icon<br>icon.png文件存放在static文件夹下，nuxt.config.js中配置head属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">head: &#123;</span><br><span class="line">    title: process.env.npm_package_name || &#39;&#39;,</span><br><span class="line">    meta: [</span><br><span class="line">      &#123; charset: &#39;utf-8&#39; &#125;,</span><br><span class="line">      &#123; name: &#39;viewport&#39;, content: &#39;width&#x3D;device-width, initial-scale&#x3D;1&#39; &#125;,</span><br><span class="line">      &#123; hid: &#39;description&#39;, name: &#39;description&#39;, content: process.env.npm_package_description || &#39;&#39; &#125;</span><br><span class="line">    ],</span><br><span class="line">    link: [</span><br><span class="line">      &#123; rel: &#39;icon&#39;, type: &#39;image&#x2F;x-icon&#39;, href: &#39;&#x2F;favicon.ico&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>中间件的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局使用</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: &#39;中间件名称&#39;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;页面单独使用</span><br><span class="line">export default &#123;</span><br><span class="line">    middleware: &#39;中间件名称&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于nuxt.config.js的其他配置，官网说得很详细，可以直接在<a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">官网</a>学习使用。</p><h2 id="nuxt-js一些常用操作"><a href="#nuxt-js一些常用操作" class="headerlink" title="nuxt.js一些常用操作"></a>nuxt.js一些常用操作</h2><h3 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h3><p>只要我们在pages创建新的vue页面时，运行时.nuxt包中的router.js就会自动生成路由地址。<br><img src="https://upload-images.jianshu.io/upload_images/13541244-397e541a98b32c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动生成路由地址"></p><h3 id="1-路由跳转"><a href="#1-路由跳转" class="headerlink" title="(1)路由跳转"></a>(1)路由跳转</h3><p>路由跳转有两种方式，router-link与nuxt-link,使用方式跟原来vue一样</p><figure class="highlight plain"><figcaption><span>to</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;nuxt-link :to&#x3D;&quot;&#123;name:&#39;user-id&#39;,params:&#123;id:2&#125;&#125;&quot;&gt;页面跳转2&lt;&#x2F;nuxt-link&gt;</span><br></pre></td></tr></table></figure><p>也可以使用<br><code>this.$router.push({name:&#39;user-id&#39;})</code></p><h3 id="2-关于带参数的路由地址校验"><a href="#2-关于带参数的路由地址校验" class="headerlink" title="(2)关于带参数的路由地址校验"></a>(2)关于带参数的路由地址校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">       validate (&#123; params &#125;) &#123;</span><br><span class="line">       &#x2F;&#x2F; 路由参数校验，必须是一个数字,如果校验失败，抛出异常</span><br><span class="line">       if(&#x2F;^\d+$&#x2F;.test(params.id))&#123;</span><br><span class="line">        return true</span><br><span class="line">       &#125;</span><br><span class="line">       throw new Error(&#39;Under Construction!&#39;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在跳转页面的js中加上validate校验，这样在页面预渲染时就会自动校验路由参数是否符合规范，否则抛出异常</p><h3 id="3-页面是否必须已登录才能访问"><a href="#3-页面是否必须已登录才能访问" class="headerlink" title="(3)页面是否必须已登录才能访问"></a>(3)页面是否必须已登录才能访问</h3><p>在没有使用nuxt.js框架时，我们可以采取的办法一般有：在配置路由时，给路由加个meta:{isHadLogin: true},再通过router.beforeEach判断,简单例子如下：</p><figure class="highlight plain"><figcaption><span>Vue from 'vue'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import Store from &#39;..&#x2F;vuex&#x2F;store&#39;</span><br><span class="line">Vue.use(Router)</span><br><span class="line">const route &#x3D; [&#123;</span><br><span class="line">    path: &quot;&#x2F;login&quot;,</span><br><span class="line">    component:()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;login&#39;),</span><br><span class="line">    name: &quot;login&quot;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;One&quot;,</span><br><span class="line">    component: ()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;user&#x2F;one&#39;),</span><br><span class="line">    name: &quot;user-One&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;user&#x2F;:id&quot;,</span><br><span class="line">    component: ()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;user&#x2F;_id&#39;),</span><br><span class="line">    name: &quot;user-id&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;&quot;,</span><br><span class="line">    component:()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;index&#39;),</span><br><span class="line">    name: &quot;index&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &quot;&#x2F;:slug&#x2F;component&quot;,</span><br><span class="line">    component: ()&#x3D;&gt;import(&#39;..&#x2F;pages&#x2F;_slug&#x2F;component&#39;),</span><br><span class="line">    name: &quot;slug-component&quot;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      isHadLogin:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)]</span><br><span class="line">const router &#x3D; new Router(&#123;</span><br><span class="line">  mode:&#39;history&#39;,</span><br><span class="line">  route</span><br><span class="line">&#125;)</span><br><span class="line">router.beforeEach((to,from,next)&#x3D;&gt;&#123;</span><br><span class="line">  store.dispatch(&#39;getCurrentUser&#39;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 未登录，需要登录跳转到登录页面</span><br><span class="line">    if (to.meta.isHadLogin &amp;&amp; !Store.state.authUser) &#123;</span><br><span class="line">      window.location.href &#x3D; &#39;localhost:1000&#x2F;login&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用nuxt.js框架的话，需要在middleware(中间件)中加个控制，需要登录才能访问的页面再加个middleware配置即可。例如：<br>文件地址：middleware/auth.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function (&#123; store, redirect &#125;) &#123;</span><br><span class="line">  if (!store.state.authUser) &#123;</span><br><span class="line">    &#x2F;&#x2F; error(&#123;</span><br><span class="line">    &#x2F;&#x2F;   message: &#39;You are not connected&#39;,</span><br><span class="line">    &#x2F;&#x2F;   statusCode: 403</span><br><span class="line">    &#x2F;&#x2F; &#125;)</span><br><span class="line">    return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要登录才能访问的页面配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  middleware: &#39;auth&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置之后，在跳转到该页面时，如果没有登录，就会跳到登录页面。</p><h3 id="axios跨域请求"><a href="#axios跨域请求" class="headerlink" title="axios跨域请求"></a>axios跨域请求</h3><p>在nuxt项目中，是默认安装axios，但跨域请求，有点小区别于非nuxt.js的项目。<br>在没有使用nuxt.js时，我们在vue.config.js文件中配置proxy代理，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        devServer: &#123;</span><br><span class="line">           port: 8085, &#x2F;&#x2F; 端口号</span><br><span class="line">            host: &#39;127.0.0.1&#39;,</span><br><span class="line">            https: false ,</span><br><span class="line">            proxy: &#123;</span><br><span class="line">              &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">                target: &#39;http:&#x2F;&#x2F;localhost:9094&#39;, &#x2F;&#x2F; 对应自己的接口</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                ws: true,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                  &#39;^&#x2F;api&#x2F;&#39;: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在nuxt.js的项目中，我们是在nuxt.config.js中配置proxy代理，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">modules: [</span><br><span class="line">    &#39;@nuxtjs&#x2F;axios&#39;,</span><br><span class="line">    &#39;@nuxtjs&#x2F;proxy&#39;</span><br><span class="line">  ],</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">      target: &#39;http:www.xxx.com&#39;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        &#39;^&#x2F;api &#39;: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-为项目配置固定的ip端口号"><a href="#3-为项目配置固定的ip端口号" class="headerlink" title="3.为项目配置固定的ip端口号"></a>3.为项目配置固定的ip端口号</h3><p>在nuxt.js项目中中，我们是在pagekage.json文件中配置如下设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;config&quot;: &#123;</span><br><span class="line">    &quot;nuxt&quot;: &#123;</span><br><span class="line">      &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">      &quot;port&quot;: &quot;3000&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>而本人之前在普通vue项目中，遇到过在vue.config.js设置了固定端口号，可是项目运行起来并不是我原来想要的端口号，在网上找到的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install portfinder@1.0.21</span><br></pre></td></tr></table></figure><p>运行这个命令就可</p><h3 id="4-跨域身份验证"><a href="#4-跨域身份验证" class="headerlink" title="4.跨域身份验证"></a>4.跨域身份验证</h3><p>1）package.json配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;example-auth-jwt&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;cookieparser&quot;: &quot;^0.1.0&quot;,</span><br><span class="line">    &quot;js-cookie&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">    &quot;nuxt&quot;: &quot;latest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;nuxt&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;nuxt build&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;nuxt start&quot;,</span><br><span class="line">    &quot;post-update&quot;: &quot;yarn upgrade --latest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)vuex配置：即store文件夹中的index.js配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const cookieparser &#x3D; process.server ? require(&#39;cookieparser&#39;) : undefined</span><br><span class="line"></span><br><span class="line">export const state &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    auth: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const mutations &#x3D; &#123;</span><br><span class="line">  setAuth (state, auth) &#123;</span><br><span class="line">    state.auth &#x3D; auth</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export const actions &#x3D; &#123;</span><br><span class="line">  nuxtServerInit (&#123; commit &#125;, &#123; req &#125;) &#123;</span><br><span class="line">    let auth &#x3D; null</span><br><span class="line">    if (req.headers.cookie) &#123;</span><br><span class="line">      const parsed &#x3D; cookieparser.parse(req.headers.cookie)</span><br><span class="line">      try &#123;</span><br><span class="line">        auth &#x3D; JSON.parse(parsed.auth)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        &#x2F;&#x2F; No valid cookie found</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    commit(&#39;setAuth&#39;, auth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录页配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const Cookie &#x3D; process.client ? require(&#39;js-cookie&#39;) : undefined</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  middleware: &#39;notAuthenticated&#39;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    postLogin () &#123;</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; we simulate the async request with timeout.</span><br><span class="line">        const auth &#x3D; &#123;</span><br><span class="line">          accessToken: &#39;someStringGotFromApiServiceWithAjax&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        this.$store.commit(&#39;setAuth&#39;, auth) &#x2F;&#x2F; mutating to store for client rendering</span><br><span class="line">        Cookie.set(&#39;auth&#39;, auth) &#x2F;&#x2F; saving token in cookie for server rendering</span><br><span class="line">        this.$router.push(&#39;&#x2F;&#39;)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这样，我们就能做出一个跨域带身份认证的登陆了，登录后的信息存在store里面，只要调用this.$store.state.auth即可拿到。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>nuxt.js还有很多优秀的功能供我们使用，但小编的体验还不够深入，所以暂时只能介绍这么多了。以后对nuxt.js有了更深入的体验，再来进一步更新。感恩观看！</p><p>@by 曾晓霞</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nuxt-js简介&quot;&gt;&lt;a href=&quot;#nuxt-js简介&quot; class=&quot;headerlink&quot; title=&quot;nuxt.js简介&quot;&gt;&lt;/a&gt;nuxt.js简介&lt;/h2&gt;&lt;p&gt;nuxt.js是一个基于vue.js的通用框架，集成了Vue 2、Vue-Router、Vuex、Vue-ssr(服务端渲染)、Vue-Meta，最常用的是用来作ssr（服务端渲染）。这里，我们先来科普一下服务端渲染跟客户端渲染的区别.&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="nuxt" scheme="http://yoursite.com/tags/nuxt/"/>
    
      <category term="vue ssr" scheme="http://yoursite.com/tags/vue-ssr/"/>
    
  </entry>
  
  <entry>
    <title>mockjs的使用</title>
    <link href="http://yoursite.com/2019/01/02/technique-sharing/2019/mock.js%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/02/technique-sharing/2019/mock.js学习/</id>
    <published>2019-01-02T06:00:00.000Z</published>
    <updated>2020-03-25T10:24:48.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、了解mockjs"><a href="#一、了解mockjs" class="headerlink" title="一、了解mockjs"></a>一、了解mockjs</h3><p>前言：mockjs是什么</p><p>生成随机数据，拦截 Ajax 请求。</p><p>通过随机数据，模拟各种场景；不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据；支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等；支持支持扩展更多数据类型，支持自定义函数和正则。</p><p>优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型.</p><a id="more"></a><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><h4 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Mock &#x3D; require(&#39;mockjs&#39;)    &#x2F;&#x2F;普通引用方式</span><br><span class="line"></span><br><span class="line">import Mock from &#39;mockjs&#39;      &#x2F;&#x2F;在vue中可以这样引用</span><br></pre></td></tr></table></figure><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testMockJs()&#123;</span><br><span class="line">    let data &#x3D; Mock.mock(&#123; </span><br><span class="line">        &#39;list|1-10&#39;:[&#123; &#39;id|+1&#39;:1,</span><br><span class="line">        &#39;engName|2-4&#39;:&#39;Hello&#39;,</span><br><span class="line">        &#39;chinaName|5&#39;:&#39;Chinese&#39;,</span><br><span class="line">        &#39;number|1-6&#39;:3,</span><br><span class="line">        &#39;aNumber|1-6.5&#39;:4,</span><br><span class="line">        &#39;first: &#39;@FIRST&#39;,    &#x2F;&#x2F;指随机生成英语中的first name</span><br><span class="line">        middle: &#39;@FIRST&#39;,</span><br><span class="line">        last: &#39;@LAST&#39;,      &#x2F;&#x2F;指随机生成英语中的last name</span><br><span class="line">        full: &#39;@first @middle @last&#39; &#125;]  &#x2F;&#x2F;@+变量名，指引用该变量的属性值</span><br><span class="line">    &#125;)</span><br><span class="line">        console.log(&#96;data:$&#123;JSON.stringify(data, null, 4)&#125;&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-8591909d7ad643ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成随机json数据"></p><h4 id="4-语法规范"><a href="#4-语法规范" class="headerlink" title="4.语法规范"></a>4.语法规范</h4><p>4.1数据模板定义规范（Data Template Definition，DTD）</p><p><strong>数据模板中的属性构成：“name|rule”:value</strong></p><p>(1).属性值是字符串String</p><p><strong>‘name|min-max’: string</strong></p><p>通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。</p><p><strong>‘name|count’: string</strong></p><p>通过重复 string 生成一个字符串，重复次数等于 count。</p><p>‘engName|2-4’:’Hello’,</p><p>‘chinaName|5’:’Chinese’,</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-df9abe4b0670dbc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成规则1"></p><p>（2）属性值是数字Number</p><p><strong>‘name|+1’: number</strong></p><p>属性值自动加 1，初始值为 number。</p><p><strong>‘name|min-max’: number</strong></p><p>生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。</p><p><strong>‘name|min-max.dmin-dmax’: number</strong></p><p>生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; Mock.mock(&#123;</span><br><span class="line">                &#39;list|1-10&#39;:[&#123;</span><br><span class="line">                &#39;number1|1-100.1-10&#39;: 1,</span><br><span class="line">                &#39;number2|123.1-10&#39;: 1,</span><br><span class="line">                &#39;number3|123.3&#39;: 1,</span><br><span class="line">                &#39;number4|123.10&#39;: 1.123 &#125;]</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>===&gt;生成结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;list&quot;: [ </span><br><span class="line">                &#123; &quot;number1&quot;: 2.73803408, &quot;number2&quot;: 123.46, &quot;number3&quot;: 123.748, &quot;number4&quot;: 123.1237616335 &#125;,</span><br><span class="line">                &#123; &quot;number1&quot;: 67.0562188234,&quot;number2&quot;: 123.5817686348,&quot;number3&quot;: 123.541,&quot;number4&quot;: 123.1238281167 &#125;]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>（3）属性值是布尔型Boolean</p><p><strong>‘name|1’: boolean</strong></p><p>随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。</p><p><strong>‘name|min-max’: value</strong></p><p>随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; Mock.mock(&#123;</span><br><span class="line">                &#39;list|1-10&#39;:[&#123;</span><br><span class="line">                &#39;boolean1|1&#39;: false,</span><br><span class="line">                &#39;boolean2|6-5&#39;: true &#125;]</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure><p>===》生成结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:&#123; &quot;list&quot;: [ </span><br><span class="line">                &#123; &quot;boolean1&quot;: true, &quot;boolean2&quot;: false &#125;, </span><br><span class="line">                &#123; &quot;boolean1&quot;: true, &quot;boolean2&quot;: true &#125;, </span><br><span class="line">                &#123; &quot;boolean1&quot;: true, &quot;boolean2&quot;: false &#125;]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>(4)属性值是对象Object</p><p><strong>‘name|count’: object</strong></p><p>从属性值 object 中随机选取 count 个属性。</p><p><strong>‘name|min-max’: object</strong></p><p>从属性值 object 中随机选取 min 到 max 个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mockdata &#x3D; Mock.mock(&#123;</span><br><span class="line">        &#39;people|3&#39;:&#123;name:&#39;Marry&#39;,age:14,gender:&#39;girl&#39;,eat:&#39;apple&#39;&#125;,</span><br><span class="line">        &#39;peoples|1-2&#39;:&#123;name:&#39;Marry&#39;,age:14,gender:&#39;girl&#39;,eat:&#39;apple&#39;&#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>===》生成结果<br><img src="https://upload-images.jianshu.io/upload_images/13541244-306d615522225b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="5-方法"><a href="#5-方法" class="headerlink" title="5.方法"></a>5.方法</h4><p>5.1Mock.mock()</p><p><strong>rurl</strong> :可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。<br>例如: //domain/list.json/、’/domian/list.json’。</p><p><strong>rtype</strong>：可选。表示需要拦截的 Ajax 请求类型。<br>例如 GET、POST、PUT、DELETE 等。</p><p><strong>template</strong>：可选。表示数据模板，可以是对象或字符串。<br>例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。</p><p><strong>function(options)</strong>：可选。表示用于生成响应数据的函数。</p><p>(1)<strong>Mock.mock(template)</strong></p><p>根据模板生成模拟数据</p><p>(2)<strong>Mock.mock( rurl, template )</strong></p><p>记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。</p><p>(3)<strong>Mock.mock( rurl, function( options ) )</strong></p><p>记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。</p><p>(4)<strong>Mock.mock( rurl, rtype, template )</strong></p><p>记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。</p><p>(5)<strong>Mock.mock( rurl, rtype, function( options ) )</strong></p><p>记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。</p><p>5.2 Mock.setup()</p><p>配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。</p><p>5.3 Mock.Random()</p><p>是一个工具类，用于生成各种随机数据。(在数据模板中成为占位符，书写格式为<strong>@占位符(参数 [, 参数])</strong>)</p><p>5.4 Mock.valid()</p><p>校验真实数据 data 是否与数据模板 template 匹配。</p><p>5.5 Mock.toJSONSchema()</p><p>把 Mock.js 风格的数据模板 template 转换成<a href="http://json-schema.org/" target="_blank" rel="noopener">JSON Schema</a>。</p><h3 id="二、在polymer项目中"><a href="#二、在polymer项目中" class="headerlink" title="二、在polymer项目中"></a>二、在polymer项目中</h3><p>前言：因为在polymer中，js文件不能直接引用外部文件，所以我们需要新建一个html,把我们需要引用的文件放在HTML中使用。</p><p>1.安装mockjs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g bower</span><br><span class="line">bower install --save mockjs</span><br></pre></td></tr></table></figure><p>2.在项目中新建mockData文件夹</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-9d6b0aebdf33f105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mockData文件夹"></p><p>3.mockData.js中定义模拟数据以及需要拦截的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  const userInfo &#x3D; Mock.mock(&#123;</span><br><span class="line">    &quot;rows|10&quot;:[&#123; &#x2F;&#x2F;&quot;name|number&quot;:[]生成number个数组</span><br><span class="line">      &quot;id|+1&quot;:1, &#x2F;&#x2F;&quot;name|+number&quot;:number 生成的每个id比前面一个大number</span><br><span class="line">      &quot;name&quot;:&quot;@name()&quot;,&#x2F;&#x2F;&quot;@name()&quot;随机生成name</span><br><span class="line">      &quot;email&quot;: &quot;@email()&quot;, &#x2F;&#x2F;&quot;@email&quot;随机生成邮箱</span><br><span class="line">      &quot;groupId|35-47&quot;: 35, &#x2F;&#x2F;&quot;groupId|35-47&quot;随机生成35-47中的某个整数</span><br><span class="line">      &quot;setGroupId|1&quot;: true,&#x2F;&#x2F;&quot;setGroupId|1&quot;随机生成boolean值</span><br><span class="line">      &quot;setId|1&quot;: true,</span><br><span class="line">      &quot;setName|1&quot;: true,</span><br><span class="line">      &quot;setSort|1&quot;: true,</span><br><span class="line">      &quot;setUrl|1&quot;: true,</span><br><span class="line">      &quot;sort|1-10&quot;: 1,</span><br><span class="line">      &quot;url&quot;: &quot;@url()&quot; &#x2F;&#x2F;&quot;@url()&quot;随机生成url</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;定义你需要拦截的接口对应的方法,可重写拦截后返回的操作方法</span><br><span class="line">  Mock.mock(RegExp(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;groupsList.do&#39;) + &quot;.*&quot;),&#39;get&#39;,function (options) &#123; &#x2F;&#x2F;get请求使用正则匹配是为了拦截带参数的get请求</span><br><span class="line">    return userInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  Mock.mock(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;add.do&#39;),&#39;post&#39;,function (options) &#123;</span><br><span class="line">    addMockData(options,userInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">  Mock.mock(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;update.do&#39;),&#39;post&#39;,function (options) &#123;</span><br><span class="line">    updateMockData(options,userInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">  Mock.mock(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;delete.do&#39;),&#39;delete&#39;,function (options) &#123;</span><br><span class="line">    deleteMockData(options,userInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F;把url统一改成&#39;&#x2F;mock&#39;+url</span><br><span class="line">function getMockUrl(url)&#123;</span><br><span class="line">  return &#96;&#x2F;mock$&#123;url&#125;&#96;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;把请求的参数转换成js</span><br><span class="line">function getOptions(options) &#123;</span><br><span class="line">  return JSON.parse(options.body)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;add method</span><br><span class="line">function addMockData(options,mockData) &#123;</span><br><span class="line">  const obj &#x3D; this.getOptions(options)</span><br><span class="line">  obj.id &#x3D; mockData.rows.length+1</span><br><span class="line">  mockData.rows.push(obj)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;update method</span><br><span class="line">function updateMockData(options,mockData) &#123;</span><br><span class="line">  const obj &#x3D; this.getOptions(options)</span><br><span class="line">  mockData.rows &#x3D; mockData.rows.map(item&#x3D;&gt;&#123;</span><br><span class="line">    return item.id &#x3D;&#x3D;&#x3D; obj.id?obj:item</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;delete method</span><br><span class="line">function deleteMockData(options,mockData) &#123;</span><br><span class="line">  const id &#x3D; parseInt(this.getOptions(options).id)</span><br><span class="line">  mockData.rows &#x3D; mockData.rows.filter(item&#x3D;&gt;&#123;</span><br><span class="line">    return item.id !&#x3D;&#x3D; id</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在mockData.html中引用mockjs以及mockData.js两个脚本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;bower_components2&#x2F;mockjs&#x2F;dist&#x2F;mock.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;mock-data.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>5.需要使用模拟数据的页面，引用mockData.html</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-db20e6a7a516fd21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在已有的项目中加入mockjs框架，已封装http请求接口，且不影响原有的使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-40cbae3116f762b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在该封装接口的脚本中引用mockData.html,在原来的基础上加一个参数，判断是否使用模拟数据.如果是，在url上做文章。这样可以保证不会影响到其他模块的使用。</p><h3 id="三、在vue项目中"><a href="#三、在vue项目中" class="headerlink" title="三、在vue项目中"></a>三、在vue项目中</h3><p>1.先在vue工程文件中下载mockjs</p><p>一般是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><p>2.在src中创建 mock.js,在mock.js中导入mockjs,即可使用Mock的各种方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Mock &#x3D; require(&#39;mockjs&#39;)     &#x2F;&#x2F;导入mockjs</span><br><span class="line">            const userInfo &#x3D;Mock.mock(&#123;       &#x2F;&#x2F;生成随机数</span><br><span class="line">                &#39;data|10&#39;:[</span><br><span class="line">                    &#123; &#39;id|+1&#39;:1,</span><br><span class="line">                    name:&#39;@ctitle(2,10)&#39;,</span><br><span class="line">                    avatar:&#39;@image(\&#39;600x600\&#39;,@color)&#39;,</span><br><span class="line">                    &#39;gender|1&#39;:true,</span><br><span class="line">                    &#39;age|18-25&#39;:20 &#125;]</span><br><span class="line">                 &#125;)</span><br><span class="line">Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;queryUser&#39;,&#39;get&#39;,function () &#123; return userInfo.data&#125;) &#x2F;&#x2F;获取模拟</span><br><span class="line">数据的接口</span><br></pre></td></tr></table></figure><p>3.在main.js中导入刚刚新建的mock.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&#39;.&#x2F;mock.js&#39;)</span><br></pre></td></tr></table></figure><p>至此，我们就可以访问我们定义的模拟数据接口了。</p><p>以下是鄙人自己写的实现数据增删改查接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import Mock from &#39;mockjs&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  mockData()&#123;</span><br><span class="line">    const userInfo &#x3D; Mock.mock(</span><br><span class="line">      &#123;</span><br><span class="line">        &#39;data|10&#39;:[&#123;</span><br><span class="line">          &#39;id|+1&#39;:1,</span><br><span class="line">          name:&#39;@ctitle(2,10)&#39;,</span><br><span class="line">          avatar:&#39;@image(\&#39;600x600\&#39;,@color)&#39;,</span><br><span class="line">          &#39;gender|1&#39;:true,</span><br><span class="line">          &#39;age|18-25&#39;:20</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">&#x2F;&#x2F;模拟删除数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;deleteUser&#39;,&#39;delete&#39;,function (options) &#123;</span><br><span class="line">      const id &#x3D; parseInt(JSON.parse(options.body).id)</span><br><span class="line">      userInfo.data &#x3D; userInfo.data.filter(item&#x3D;&gt;&#123;</span><br><span class="line">        return item.id !&#x3D;&#x3D; id</span><br><span class="line">      &#125;)</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;模拟查询数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;web&#x2F;itemPrice&#x2F;findFinalPriceOfferPage&#39;,&#39;get&#39;,function (options) &#123;</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;模拟更新数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;updateUser&#39;,&#39;post&#39;,function (options) &#123;</span><br><span class="line">      const obj &#x3D; JSON.parse(options.body)</span><br><span class="line">      userInfo.data &#x3D; userInfo.data.map(item&#x3D;&gt;&#123;</span><br><span class="line">        return item.id &#x3D;&#x3D;&#x3D; obj.id?obj:item</span><br><span class="line">      &#125;)</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;模拟添加数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;addUser&#39;,&#39;post&#39;,function (options) &#123;</span><br><span class="line">      const obj &#x3D; JSON.parse(options.body)</span><br><span class="line">      obj.id &#x3D; userInfo.data.length+1</span><br><span class="line">      userInfo.data.push(obj)</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vue.config.js中设置代理服务，即可以测试接口是否被拦截</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:9094&#39;, &#x2F;&#x2F; 请求的接口</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        ws: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#39;^&#x2F;api&#x2F;&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在我们的实际项目中，很多时候都是把get post请求封装好，以不用多次自己手写ajax或者axios请求。所以我们可以这样做：</p><p>在封装请求的方法里加一个isMock判断是否使用模拟数据，是的话改变它的url，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get(url,params&#x3D;&#123;&#125;,isMock)&#123;</span><br><span class="line">    url &#x3D; isMock?&#96;&#x2F;mock$&#123;url&#125;&#96;:url</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">      axios.get(url,params)</span><br><span class="line">        .then(res&#x3D;&gt;&#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(error&#x3D;&gt;&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在mockUrl中，在url前缀加上/mock，以防止在不使用mock数据模拟的时候，影响了原有的url请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(RegExp(&#39;&#x2F;mock&#x2F;api&#x2F;web&#x2F;itemPrice&#x2F;findFinalPriceOfferPage&#39; +&#39;.*&#39;), &#39;get&#39;, function () &#123; </span><br><span class="line">                 return data.itemPriceInfo</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure><h3 id="四、在vue项目中的应用（升级版）"><a href="#四、在vue项目中的应用（升级版）" class="headerlink" title="四、在vue项目中的应用（升级版）"></a>四、在vue项目中的应用（升级版）</h3><p><strong>适用对象：</strong> 项目已开发了一部分，后续想引入mockjs<br><strong>优点：</strong> 不影响原来请求的使用，其他成员想使用模拟数据时只需要新建按要求data数据即可，不需要修改原有的代码，不担心错提交或漏提交导致测试环境甚至生产环境跑不起来问题<br>前面操作一样，先install mockjs，在封装好的http请求中，若使用模拟数据，给url加个前缀识别,如：。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get (url, params, isMock &#x3D; false) &#123;</span><br><span class="line">    url &#x3D; isMock ? &#96;&#x2F;mock$&#123;url&#125;&#96; : url</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      axios.get(url, &#123;</span><br><span class="line">        params: params</span><br><span class="line">      &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        resolve(res.data)</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="不同的是："><a href="#不同的是：" class="headerlink" title="不同的是："></a>不同的是：</h4><p>在目录中,新建mockData文件夹，mockData的组成有：<br><strong>data文件夹</strong>：用于存放其他成员使用模拟数据时其数据文件；<br><strong>getMockData.js</strong>：自动读取data中新增的数据脚本文件；<br><strong>mockBaseFunction</strong>:封装一些基础的增删改查方法，方便其他成员按需引用。<br><img src="https://upload-images.jianshu.io/upload_images/13541244-56b1a21840629977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mockData目录"><br>data中的数据文件，需要用export 封装起来，方便读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import mockBaseFunction from &#39;..&#x2F;mockBaseFunction&#39;</span><br><span class="line">const successData &#x3D; &#123; data: null, meta: &#123; success: true, message: &#39;ok&#39; &#125; &#125;</span><br><span class="line">const itemPriceInfo &#x3D; mockBaseFunction.mock(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    &#39;rows|5&#39;: [&#123;</span><br><span class="line">      category: &#39;@name()&#39;, &#x2F;&#x2F; &#39;@name()随机生成英文名字&#39;</span><br><span class="line">      createdByName: &#39;@cname()&#39;, &#x2F;&#x2F; &#39;@name()随机生成中文名字&#39;</span><br><span class="line">      &#39;id|+1&#39;: 63, &#x2F;&#x2F; &quot;id|+number&quot;:number 生成的每个id比前面一个大number</span><br><span class="line">      manufacturerName: &#39;@ctitle()&#39;,</span><br><span class="line">      &#39;status|1-3&#39;: 3, &#x2F;&#x2F; &quot;status1-3&quot;随机生成1-3中的某个整数</span><br><span class="line">      supplierCompanyId: 61,</span><br><span class="line">      supplierCompanyName: &#39;@ctitle()&#39;, &#x2F;&#x2F; &#39;@ctitle()&#39;随机生成中文标题</span><br><span class="line">    &#125;],</span><br><span class="line">    pageResponse: &#123; start: 0, limit: 5, results: 60 &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    message: &#39;ok&#39;,</span><br><span class="line">    success: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mockDemo () &#123;</span><br><span class="line">    &#x2F;&#x2F; 拦截的url：fun.getMockUrl(&#39;需要拦截的url&#39;),请求方法，可为空:&#39;&#39;,拦截后的操作方法</span><br><span class="line">    &#x2F;&#x2F; 拦截get请求，返回模拟数据</span><br><span class="line">    mockBaseFunction.mock(RegExp(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;web&#x2F;itemPrice&#x2F;findFinalPriceOfferPage&#39;) + &#39;.*&#39;), &#39;get&#39;, function (options) &#123;</span><br><span class="line">      return mockBaseFunction.queryMockData(options, itemPriceInfo)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拦截post请求，增加数据，拦截后返回增加模拟数据方法</span><br><span class="line">    mockBaseFunction.mock(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;userInfo&#x2F;addUser&#39;), &#39;post&#39;, function (options) &#123;</span><br><span class="line">      mockBaseFunction.addMockData(options, itemPriceInfo, successData)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拦截post请求，修改数据，拦截后返回修改模拟数据方法</span><br><span class="line">    mockBaseFunction.mock(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;userInfo&#x2F;updateUser&#39;), &#39;post&#39;, function (options) &#123;</span><br><span class="line">      mockBaseFunction.updateMockData(options, itemPriceInfo, successData)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拦截post请求，删除数据，拦截后返回删除模拟数据方法</span><br><span class="line">    mockBaseFunction.mock(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;userInfo&#x2F;deleteUser&#39;), &#39;post&#39;, function (options) &#123;</span><br><span class="line">      mockBaseFunction.deleteMockData(options, itemPriceInfo, successData)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getMockData.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  const mockData &#x3D; require.context(&#39;..&#x2F;mockData&#x2F;data&#39;, false, &#x2F;[A-Za-z0-9-_,\s]+\.js$&#x2F;i)</span><br><span class="line">  mockData.keys().reduce((modules, modulePath) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; set &#39;.&#x2F;app.js&#39; &#x3D;&gt; &#39;app&#39;</span><br><span class="line">    const moduleName &#x3D; modulePath.replace(&#x2F;^\.\&#x2F;(.*)\.\w+$&#x2F;, &#39;$1&#39;)</span><br><span class="line">    const value &#x3D; mockData(modulePath)</span><br><span class="line">      modules[moduleName] &#x3D; value.default</span><br><span class="line">      return modules[moduleName][moduleName]()</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="重点在于使用require-context（）读取data中的数据文件"><a href="#重点在于使用require-context（）读取data中的数据文件" class="headerlink" title="重点在于使用require.context（）读取data中的数据文件"></a>重点在于使用require.context（）读取data中的数据文件</h3><p><strong>mockBaseFunction.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import Mock from &#39;mockjs&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mock: Mock.mock,  &#x2F;&#x2F;这里定义mock变量，是为了方便其他成员使用mockjs，不需要再自己引用mockjs,直接引用mockBaseFunction.js即可</span><br><span class="line">&#x2F;&#x2F; 将url转换成&#x2F;mock+url格式</span><br><span class="line">  getMockUrl (url) &#123;</span><br><span class="line">    return &#96;&#x2F;mock$&#123;url&#125;&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 将请求的传参转换成js对象</span><br><span class="line">  getOptions (options) &#123;</span><br><span class="line">    return JSON.parse(options.body)</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 查询模拟数据</span><br><span class="line">  queryMockData (option, mockData, selfFunction) &#123;</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      return mockData</span><br><span class="line">    &#125;</span><br><span class="line">    return selfFunction()</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 模拟新增数据</span><br><span class="line">  addMockData (options, mockData, successData &#x3D; &#123;&#125;, selfFunction) &#123;</span><br><span class="line">    const params &#x3D; this.getOptions(options)</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      params.id &#x3D; mockData.data.rows.length + 1</span><br><span class="line">      mockData.data.rows.push(params)</span><br><span class="line">      return successData || &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return selfFunction()</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 模拟编辑数据</span><br><span class="line">  updateMockData (options, mockData, successData &#x3D; &#123;&#125;, selfFunction) &#123;</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const obj &#x3D; this.getOptions(options)</span><br><span class="line">      mockData.data.rows &#x3D; mockData.data.rows.map(item &#x3D;&gt; &#123;</span><br><span class="line">        return item.id &#x3D;&#x3D;&#x3D; obj.id ? obj : item</span><br><span class="line">      &#125;)</span><br><span class="line">      return successData || &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return selfFunction()</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 模拟删除数据</span><br><span class="line">  deleteMockData (options, mockData, successData &#x3D; &#123;&#125;, selfFunction) &#123;</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const id &#x3D; parseInt(this.getOptions(options).id)</span><br><span class="line">      mockData.data.rows &#x3D; mockData.data.rows.filter(item &#x3D;&gt; &#123;</span><br><span class="line">        return item.id !&#x3D;&#x3D; id</span><br><span class="line">      &#125;)</span><br><span class="line">      return successData || &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    selfFunction()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>突破点：</strong>读取data中的数据文件并且调用封装好的方法。</p><p>@ by 曾晓霞</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、了解mockjs&quot;&gt;&lt;a href=&quot;#一、了解mockjs&quot; class=&quot;headerlink&quot; title=&quot;一、了解mockjs&quot;&gt;&lt;/a&gt;一、了解mockjs&lt;/h3&gt;&lt;p&gt;前言：mockjs是什么&lt;/p&gt;
&lt;p&gt;生成随机数据，拦截 Ajax 请求。&lt;/p&gt;
&lt;p&gt;通过随机数据，模拟各种场景；不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据；支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等；支持支持扩展更多数据类型，支持自定义函数和正则。&lt;/p&gt;
&lt;p&gt;优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型.&lt;/p&gt;
    
    </summary>
    
    
      <category term="mock" scheme="http://yoursite.com/tags/mock/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>mockjs的使用</title>
    <link href="http://yoursite.com/2019/01/02/technique-sharing/2019/mock.js%D1%A7%CF%B0/"/>
    <id>http://yoursite.com/2019/01/02/technique-sharing/2019/mock.jsѧϰ/</id>
    <published>2019-01-02T06:00:00.000Z</published>
    <updated>2020-03-25T10:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、了解mockjs"><a href="#一、了解mockjs" class="headerlink" title="一、了解mockjs"></a>一、了解mockjs</h3><p>前言：mockjs是什么</p><p>生成随机数据，拦截 Ajax 请求。</p><p>通过随机数据，模拟各种场景；不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据；支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等；支持支持扩展更多数据类型，支持自定义函数和正则。</p><p>优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型.</p><a id="more"></a><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><h4 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Mock &#x3D; require(&#39;mockjs&#39;)    &#x2F;&#x2F;普通引用方式</span><br><span class="line"></span><br><span class="line">import Mock from &#39;mockjs&#39;      &#x2F;&#x2F;在vue中可以这样引用</span><br></pre></td></tr></table></figure><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testMockJs()&#123;</span><br><span class="line">    let data &#x3D; Mock.mock(&#123; </span><br><span class="line">        &#39;list|1-10&#39;:[&#123; &#39;id|+1&#39;:1,</span><br><span class="line">        &#39;engName|2-4&#39;:&#39;Hello&#39;,</span><br><span class="line">        &#39;chinaName|5&#39;:&#39;Chinese&#39;,</span><br><span class="line">        &#39;number|1-6&#39;:3,</span><br><span class="line">        &#39;aNumber|1-6.5&#39;:4,</span><br><span class="line">        &#39;first: &#39;@FIRST&#39;,    &#x2F;&#x2F;指随机生成英语中的first name</span><br><span class="line">        middle: &#39;@FIRST&#39;,</span><br><span class="line">        last: &#39;@LAST&#39;,      &#x2F;&#x2F;指随机生成英语中的last name</span><br><span class="line">        full: &#39;@first @middle @last&#39; &#125;]  &#x2F;&#x2F;@+变量名，指引用该变量的属性值</span><br><span class="line">    &#125;)</span><br><span class="line">        console.log(&#96;data:$&#123;JSON.stringify(data, null, 4)&#125;&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的结果如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-8591909d7ad643ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成随机json数据"></p><h4 id="4-语法规范"><a href="#4-语法规范" class="headerlink" title="4.语法规范"></a>4.语法规范</h4><p>4.1数据模板定义规范（Data Template Definition，DTD）</p><p><strong>数据模板中的属性构成：“name|rule”:value</strong></p><p>(1).属性值是字符串String</p><p><strong>‘name|min-max’: string</strong></p><p>通过重复 string 生成一个字符串，重复次数大于等于 min，小于等于 max。</p><p><strong>‘name|count’: string</strong></p><p>通过重复 string 生成一个字符串，重复次数等于 count。</p><p>‘engName|2-4’:’Hello’,</p><p>‘chinaName|5’:’Chinese’,</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-df9abe4b0670dbc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成规则1"></p><p>（2）属性值是数字Number</p><p><strong>‘name|+1’: number</strong></p><p>属性值自动加 1，初始值为 number。</p><p><strong>‘name|min-max’: number</strong></p><p>生成一个大于等于 min、小于等于 max 的整数，属性值 number 只是用来确定类型。</p><p><strong>‘name|min-max.dmin-dmax’: number</strong></p><p>生成一个浮点数，整数部分大于等于 min、小于等于 max，小数部分保留 dmin 到 dmax 位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; Mock.mock(&#123;</span><br><span class="line">                &#39;list|1-10&#39;:[&#123;</span><br><span class="line">                &#39;number1|1-100.1-10&#39;: 1,</span><br><span class="line">                &#39;number2|123.1-10&#39;: 1,</span><br><span class="line">                &#39;number3|123.3&#39;: 1,</span><br><span class="line">                &#39;number4|123.10&#39;: 1.123 &#125;]</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>===&gt;生成结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;list&quot;: [ </span><br><span class="line">                &#123; &quot;number1&quot;: 2.73803408, &quot;number2&quot;: 123.46, &quot;number3&quot;: 123.748, &quot;number4&quot;: 123.1237616335 &#125;,</span><br><span class="line">                &#123; &quot;number1&quot;: 67.0562188234,&quot;number2&quot;: 123.5817686348,&quot;number3&quot;: 123.541,&quot;number4&quot;: 123.1238281167 &#125;]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>（3）属性值是布尔型Boolean</p><p><strong>‘name|1’: boolean</strong></p><p>随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。</p><p><strong>‘name|min-max’: value</strong></p><p>随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; Mock.mock(&#123;</span><br><span class="line">                &#39;list|1-10&#39;:[&#123;</span><br><span class="line">                &#39;boolean1|1&#39;: false,</span><br><span class="line">                &#39;boolean2|6-5&#39;: true &#125;]</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure><p>===》生成结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:&#123; &quot;list&quot;: [ </span><br><span class="line">                &#123; &quot;boolean1&quot;: true, &quot;boolean2&quot;: false &#125;, </span><br><span class="line">                &#123; &quot;boolean1&quot;: true, &quot;boolean2&quot;: true &#125;, </span><br><span class="line">                &#123; &quot;boolean1&quot;: true, &quot;boolean2&quot;: false &#125;]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>(4)属性值是对象Object</p><p><strong>‘name|count’: object</strong></p><p>从属性值 object 中随机选取 count 个属性。</p><p><strong>‘name|min-max’: object</strong></p><p>从属性值 object 中随机选取 min 到 max 个属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const mockdata &#x3D; Mock.mock(&#123;</span><br><span class="line">        &#39;people|3&#39;:&#123;name:&#39;Marry&#39;,age:14,gender:&#39;girl&#39;,eat:&#39;apple&#39;&#125;,</span><br><span class="line">        &#39;peoples|1-2&#39;:&#123;name:&#39;Marry&#39;,age:14,gender:&#39;girl&#39;,eat:&#39;apple&#39;&#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><p>===》生成结果<br><img src="https://upload-images.jianshu.io/upload_images/13541244-306d615522225b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="5-方法"><a href="#5-方法" class="headerlink" title="5.方法"></a>5.方法</h4><p>5.1Mock.mock()</p><p><strong>rurl</strong> :可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。<br>例如: //domain/list.json/、’/domian/list.json’。</p><p><strong>rtype</strong>：可选。表示需要拦截的 Ajax 请求类型。<br>例如 GET、POST、PUT、DELETE 等。</p><p><strong>template</strong>：可选。表示数据模板，可以是对象或字符串。<br>例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。</p><p><strong>function(options)</strong>：可选。表示用于生成响应数据的函数。</p><p>(1)<strong>Mock.mock(template)</strong></p><p>根据模板生成模拟数据</p><p>(2)<strong>Mock.mock( rurl, template )</strong></p><p>记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。</p><p>(3)<strong>Mock.mock( rurl, function( options ) )</strong></p><p>记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。</p><p>(4)<strong>Mock.mock( rurl, rtype, template )</strong></p><p>记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。</p><p>(5)<strong>Mock.mock( rurl, rtype, function( options ) )</strong></p><p>记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。</p><p>5.2 Mock.setup()</p><p>配置拦截 Ajax 请求时的行为。支持的配置项有：timeout。</p><p>5.3 Mock.Random()</p><p>是一个工具类，用于生成各种随机数据。(在数据模板中成为占位符，书写格式为<strong>@占位符(参数 [, 参数])</strong>)</p><p>5.4 Mock.valid()</p><p>校验真实数据 data 是否与数据模板 template 匹配。</p><p>5.5 Mock.toJSONSchema()</p><p>把 Mock.js 风格的数据模板 template 转换成<a href="http://json-schema.org/" target="_blank" rel="noopener">JSON Schema</a>。</p><h3 id="二、在polymer项目中"><a href="#二、在polymer项目中" class="headerlink" title="二、在polymer项目中"></a>二、在polymer项目中</h3><p>前言：因为在polymer中，js文件不能直接引用外部文件，所以我们需要新建一个html,把我们需要引用的文件放在HTML中使用。</p><p>1.安装mockjs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g bower</span><br><span class="line">bower install --save mockjs</span><br></pre></td></tr></table></figure><p>2.在项目中新建mockData文件夹</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-9d6b0aebdf33f105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mockData文件夹"></p><p>3.mockData.js中定义模拟数据以及需要拦截的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  const userInfo &#x3D; Mock.mock(&#123;</span><br><span class="line">    &quot;rows|10&quot;:[&#123; &#x2F;&#x2F;&quot;name|number&quot;:[]生成number个数组</span><br><span class="line">      &quot;id|+1&quot;:1, &#x2F;&#x2F;&quot;name|+number&quot;:number 生成的每个id比前面一个大number</span><br><span class="line">      &quot;name&quot;:&quot;@name()&quot;,&#x2F;&#x2F;&quot;@name()&quot;随机生成name</span><br><span class="line">      &quot;email&quot;: &quot;@email()&quot;, &#x2F;&#x2F;&quot;@email&quot;随机生成邮箱</span><br><span class="line">      &quot;groupId|35-47&quot;: 35, &#x2F;&#x2F;&quot;groupId|35-47&quot;随机生成35-47中的某个整数</span><br><span class="line">      &quot;setGroupId|1&quot;: true,&#x2F;&#x2F;&quot;setGroupId|1&quot;随机生成boolean值</span><br><span class="line">      &quot;setId|1&quot;: true,</span><br><span class="line">      &quot;setName|1&quot;: true,</span><br><span class="line">      &quot;setSort|1&quot;: true,</span><br><span class="line">      &quot;setUrl|1&quot;: true,</span><br><span class="line">      &quot;sort|1-10&quot;: 1,</span><br><span class="line">      &quot;url&quot;: &quot;@url()&quot; &#x2F;&#x2F;&quot;@url()&quot;随机生成url</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;定义你需要拦截的接口对应的方法,可重写拦截后返回的操作方法</span><br><span class="line">  Mock.mock(RegExp(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;groupsList.do&#39;) + &quot;.*&quot;),&#39;get&#39;,function (options) &#123; &#x2F;&#x2F;get请求使用正则匹配是为了拦截带参数的get请求</span><br><span class="line">    return userInfo</span><br><span class="line">  &#125;)</span><br><span class="line">  Mock.mock(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;add.do&#39;),&#39;post&#39;,function (options) &#123;</span><br><span class="line">    addMockData(options,userInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">  Mock.mock(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;update.do&#39;),&#39;post&#39;,function (options) &#123;</span><br><span class="line">    updateMockData(options,userInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">  Mock.mock(getMockUrl(&#39;&#x2F;management&#x2F;link&#x2F;delete.do&#39;),&#39;delete&#39;,function (options) &#123;</span><br><span class="line">    deleteMockData(options,userInfo)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F;把url统一改成&#39;&#x2F;mock&#39;+url</span><br><span class="line">function getMockUrl(url)&#123;</span><br><span class="line">  return &#96;&#x2F;mock$&#123;url&#125;&#96;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;把请求的参数转换成js</span><br><span class="line">function getOptions(options) &#123;</span><br><span class="line">  return JSON.parse(options.body)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;add method</span><br><span class="line">function addMockData(options,mockData) &#123;</span><br><span class="line">  const obj &#x3D; this.getOptions(options)</span><br><span class="line">  obj.id &#x3D; mockData.rows.length+1</span><br><span class="line">  mockData.rows.push(obj)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;update method</span><br><span class="line">function updateMockData(options,mockData) &#123;</span><br><span class="line">  const obj &#x3D; this.getOptions(options)</span><br><span class="line">  mockData.rows &#x3D; mockData.rows.map(item&#x3D;&gt;&#123;</span><br><span class="line">    return item.id &#x3D;&#x3D;&#x3D; obj.id?obj:item</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;delete method</span><br><span class="line">function deleteMockData(options,mockData) &#123;</span><br><span class="line">  const id &#x3D; parseInt(this.getOptions(options).id)</span><br><span class="line">  mockData.rows &#x3D; mockData.rows.filter(item&#x3D;&gt;&#123;</span><br><span class="line">    return item.id !&#x3D;&#x3D; id</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在mockData.html中引用mockjs以及mockData.js两个脚本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;bower_components2&#x2F;mockjs&#x2F;dist&#x2F;mock.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;mock-data.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>5.需要使用模拟数据的页面，引用mockData.html</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-db20e6a7a516fd21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在已有的项目中加入mockjs框架，已封装http请求接口，且不影响原有的使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/13541244-40cbae3116f762b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在该封装接口的脚本中引用mockData.html,在原来的基础上加一个参数，判断是否使用模拟数据.如果是，在url上做文章。这样可以保证不会影响到其他模块的使用。</p><h3 id="三、在vue项目中"><a href="#三、在vue项目中" class="headerlink" title="三、在vue项目中"></a>三、在vue项目中</h3><p>1.先在vue工程文件中下载mockjs</p><p>一般是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><p>2.在src中创建 mock.js,在mock.js中导入mockjs,即可使用Mock的各种方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Mock &#x3D; require(&#39;mockjs&#39;)     &#x2F;&#x2F;导入mockjs</span><br><span class="line">            const userInfo &#x3D;Mock.mock(&#123;       &#x2F;&#x2F;生成随机数</span><br><span class="line">                &#39;data|10&#39;:[</span><br><span class="line">                    &#123; &#39;id|+1&#39;:1,</span><br><span class="line">                    name:&#39;@ctitle(2,10)&#39;,</span><br><span class="line">                    avatar:&#39;@image(\&#39;600x600\&#39;,@color)&#39;,</span><br><span class="line">                    &#39;gender|1&#39;:true,</span><br><span class="line">                    &#39;age|18-25&#39;:20 &#125;]</span><br><span class="line">                 &#125;)</span><br><span class="line">Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;queryUser&#39;,&#39;get&#39;,function () &#123; return userInfo.data&#125;) &#x2F;&#x2F;获取模拟</span><br><span class="line">数据的接口</span><br></pre></td></tr></table></figure><p>3.在main.js中导入刚刚新建的mock.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&#39;.&#x2F;mock.js&#39;)</span><br></pre></td></tr></table></figure><p>至此，我们就可以访问我们定义的模拟数据接口了。</p><p>以下是鄙人自己写的实现数据增删改查接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import Mock from &#39;mockjs&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  mockData()&#123;</span><br><span class="line">    const userInfo &#x3D; Mock.mock(</span><br><span class="line">      &#123;</span><br><span class="line">        &#39;data|10&#39;:[&#123;</span><br><span class="line">          &#39;id|+1&#39;:1,</span><br><span class="line">          name:&#39;@ctitle(2,10)&#39;,</span><br><span class="line">          avatar:&#39;@image(\&#39;600x600\&#39;,@color)&#39;,</span><br><span class="line">          &#39;gender|1&#39;:true,</span><br><span class="line">          &#39;age|18-25&#39;:20</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">&#x2F;&#x2F;模拟删除数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;deleteUser&#39;,&#39;delete&#39;,function (options) &#123;</span><br><span class="line">      const id &#x3D; parseInt(JSON.parse(options.body).id)</span><br><span class="line">      userInfo.data &#x3D; userInfo.data.filter(item&#x3D;&gt;&#123;</span><br><span class="line">        return item.id !&#x3D;&#x3D; id</span><br><span class="line">      &#125;)</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;模拟查询数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;web&#x2F;itemPrice&#x2F;findFinalPriceOfferPage&#39;,&#39;get&#39;,function (options) &#123;</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;模拟更新数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;updateUser&#39;,&#39;post&#39;,function (options) &#123;</span><br><span class="line">      const obj &#x3D; JSON.parse(options.body)</span><br><span class="line">      userInfo.data &#x3D; userInfo.data.map(item&#x3D;&gt;&#123;</span><br><span class="line">        return item.id &#x3D;&#x3D;&#x3D; obj.id?obj:item</span><br><span class="line">      &#125;)</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;模拟添加数据</span><br><span class="line">    Mock.mock(&#39;&#x2F;api&#x2F;userInfo&#x2F;addUser&#39;,&#39;post&#39;,function (options) &#123;</span><br><span class="line">      const obj &#x3D; JSON.parse(options.body)</span><br><span class="line">      obj.id &#x3D; userInfo.data.length+1</span><br><span class="line">      userInfo.data.push(obj)</span><br><span class="line">      return userInfo.data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vue.config.js中设置代理服务，即可以测试接口是否被拦截</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#39;&#x2F;api&#39;: &#123;</span><br><span class="line">        target: &#39;http:&#x2F;&#x2F;localhost:9094&#39;, &#x2F;&#x2F; 请求的接口</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        ws: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#39;^&#x2F;api&#x2F;&#39;: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在我们的实际项目中，很多时候都是把get post请求封装好，以不用多次自己手写ajax或者axios请求。所以我们可以这样做：</p><p>在封装请求的方法里加一个isMock判断是否使用模拟数据，是的话改变它的url，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get(url,params&#x3D;&#123;&#125;,isMock)&#123;</span><br><span class="line">    url &#x3D; isMock?&#96;&#x2F;mock$&#123;url&#125;&#96;:url</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">      axios.get(url,params)</span><br><span class="line">        .then(res&#x3D;&gt;&#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(error&#x3D;&gt;&#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在mockUrl中，在url前缀加上/mock，以防止在不使用mock数据模拟的时候，影响了原有的url请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(RegExp(&#39;&#x2F;mock&#x2F;api&#x2F;web&#x2F;itemPrice&#x2F;findFinalPriceOfferPage&#39; +&#39;.*&#39;), &#39;get&#39;, function () &#123; </span><br><span class="line">                 return data.itemPriceInfo</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure><h3 id="四、在vue项目中的应用（升级版）"><a href="#四、在vue项目中的应用（升级版）" class="headerlink" title="四、在vue项目中的应用（升级版）"></a>四、在vue项目中的应用（升级版）</h3><p><strong>适用对象：</strong> 项目已开发了一部分，后续想引入mockjs<br><strong>优点：</strong> 不影响原来请求的使用，其他成员想使用模拟数据时只需要新建按要求data数据即可，不需要修改原有的代码，不担心错提交或漏提交导致测试环境甚至生产环境跑不起来问题<br>前面操作一样，先install mockjs，在封装好的http请求中，若使用模拟数据，给url加个前缀识别,如：。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">get (url, params, isMock &#x3D; false) &#123;</span><br><span class="line">    url &#x3D; isMock ? &#96;&#x2F;mock$&#123;url&#125;&#96; : url</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      axios.get(url, &#123;</span><br><span class="line">        params: params</span><br><span class="line">      &#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">        resolve(res.data)</span><br><span class="line">      &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="不同的是："><a href="#不同的是：" class="headerlink" title="不同的是："></a>不同的是：</h4><p>在目录中,新建mockData文件夹，mockData的组成有：<br><strong>data文件夹</strong>：用于存放其他成员使用模拟数据时其数据文件；<br><strong>getMockData.js</strong>：自动读取data中新增的数据脚本文件；<br><strong>mockBaseFunction</strong>:封装一些基础的增删改查方法，方便其他成员按需引用。<br><img src="https://upload-images.jianshu.io/upload_images/13541244-56b1a21840629977.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mockData目录"><br>data中的数据文件，需要用export 封装起来，方便读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import mockBaseFunction from &#39;..&#x2F;mockBaseFunction&#39;</span><br><span class="line">const successData &#x3D; &#123; data: null, meta: &#123; success: true, message: &#39;ok&#39; &#125; &#125;</span><br><span class="line">const itemPriceInfo &#x3D; mockBaseFunction.mock(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    &#39;rows|5&#39;: [&#123;</span><br><span class="line">      category: &#39;@name()&#39;, &#x2F;&#x2F; &#39;@name()随机生成英文名字&#39;</span><br><span class="line">      createdByName: &#39;@cname()&#39;, &#x2F;&#x2F; &#39;@name()随机生成中文名字&#39;</span><br><span class="line">      &#39;id|+1&#39;: 63, &#x2F;&#x2F; &quot;id|+number&quot;:number 生成的每个id比前面一个大number</span><br><span class="line">      manufacturerName: &#39;@ctitle()&#39;,</span><br><span class="line">      &#39;status|1-3&#39;: 3, &#x2F;&#x2F; &quot;status1-3&quot;随机生成1-3中的某个整数</span><br><span class="line">      supplierCompanyId: 61,</span><br><span class="line">      supplierCompanyName: &#39;@ctitle()&#39;, &#x2F;&#x2F; &#39;@ctitle()&#39;随机生成中文标题</span><br><span class="line">    &#125;],</span><br><span class="line">    pageResponse: &#123; start: 0, limit: 5, results: 60 &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    message: &#39;ok&#39;,</span><br><span class="line">    success: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mockDemo () &#123;</span><br><span class="line">    &#x2F;&#x2F; 拦截的url：fun.getMockUrl(&#39;需要拦截的url&#39;),请求方法，可为空:&#39;&#39;,拦截后的操作方法</span><br><span class="line">    &#x2F;&#x2F; 拦截get请求，返回模拟数据</span><br><span class="line">    mockBaseFunction.mock(RegExp(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;web&#x2F;itemPrice&#x2F;findFinalPriceOfferPage&#39;) + &#39;.*&#39;), &#39;get&#39;, function (options) &#123;</span><br><span class="line">      return mockBaseFunction.queryMockData(options, itemPriceInfo)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拦截post请求，增加数据，拦截后返回增加模拟数据方法</span><br><span class="line">    mockBaseFunction.mock(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;userInfo&#x2F;addUser&#39;), &#39;post&#39;, function (options) &#123;</span><br><span class="line">      mockBaseFunction.addMockData(options, itemPriceInfo, successData)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拦截post请求，修改数据，拦截后返回修改模拟数据方法</span><br><span class="line">    mockBaseFunction.mock(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;userInfo&#x2F;updateUser&#39;), &#39;post&#39;, function (options) &#123;</span><br><span class="line">      mockBaseFunction.updateMockData(options, itemPriceInfo, successData)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拦截post请求，删除数据，拦截后返回删除模拟数据方法</span><br><span class="line">    mockBaseFunction.mock(mockBaseFunction.getMockUrl(&#39;&#x2F;api&#x2F;userInfo&#x2F;deleteUser&#39;), &#39;post&#39;, function (options) &#123;</span><br><span class="line">      mockBaseFunction.deleteMockData(options, itemPriceInfo, successData)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getMockData.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  const mockData &#x3D; require.context(&#39;..&#x2F;mockData&#x2F;data&#39;, false, &#x2F;[A-Za-z0-9-_,\s]+\.js$&#x2F;i)</span><br><span class="line">  mockData.keys().reduce((modules, modulePath) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; set &#39;.&#x2F;app.js&#39; &#x3D;&gt; &#39;app&#39;</span><br><span class="line">    const moduleName &#x3D; modulePath.replace(&#x2F;^\.\&#x2F;(.*)\.\w+$&#x2F;, &#39;$1&#39;)</span><br><span class="line">    const value &#x3D; mockData(modulePath)</span><br><span class="line">      modules[moduleName] &#x3D; value.default</span><br><span class="line">      return modules[moduleName][moduleName]()</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="重点在于使用require-context（）读取data中的数据文件"><a href="#重点在于使用require-context（）读取data中的数据文件" class="headerlink" title="重点在于使用require.context（）读取data中的数据文件"></a>重点在于使用require.context（）读取data中的数据文件</h3><p><strong>mockBaseFunction.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import Mock from &#39;mockjs&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mock: Mock.mock,  &#x2F;&#x2F;这里定义mock变量，是为了方便其他成员使用mockjs，不需要再自己引用mockjs,直接引用mockBaseFunction.js即可</span><br><span class="line">&#x2F;&#x2F; 将url转换成&#x2F;mock+url格式</span><br><span class="line">  getMockUrl (url) &#123;</span><br><span class="line">    return &#96;&#x2F;mock$&#123;url&#125;&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 将请求的传参转换成js对象</span><br><span class="line">  getOptions (options) &#123;</span><br><span class="line">    return JSON.parse(options.body)</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 查询模拟数据</span><br><span class="line">  queryMockData (option, mockData, selfFunction) &#123;</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      return mockData</span><br><span class="line">    &#125;</span><br><span class="line">    return selfFunction()</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 模拟新增数据</span><br><span class="line">  addMockData (options, mockData, successData &#x3D; &#123;&#125;, selfFunction) &#123;</span><br><span class="line">    const params &#x3D; this.getOptions(options)</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      params.id &#x3D; mockData.data.rows.length + 1</span><br><span class="line">      mockData.data.rows.push(params)</span><br><span class="line">      return successData || &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return selfFunction()</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 模拟编辑数据</span><br><span class="line">  updateMockData (options, mockData, successData &#x3D; &#123;&#125;, selfFunction) &#123;</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const obj &#x3D; this.getOptions(options)</span><br><span class="line">      mockData.data.rows &#x3D; mockData.data.rows.map(item &#x3D;&gt; &#123;</span><br><span class="line">        return item.id &#x3D;&#x3D;&#x3D; obj.id ? obj : item</span><br><span class="line">      &#125;)</span><br><span class="line">      return successData || &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    return selfFunction()</span><br><span class="line">  &#125;,</span><br><span class="line">&#x2F;&#x2F; 模拟删除数据</span><br><span class="line">  deleteMockData (options, mockData, successData &#x3D; &#123;&#125;, selfFunction) &#123;</span><br><span class="line">    if (typeof (selfFunction) !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const id &#x3D; parseInt(this.getOptions(options).id)</span><br><span class="line">      mockData.data.rows &#x3D; mockData.data.rows.filter(item &#x3D;&gt; &#123;</span><br><span class="line">        return item.id !&#x3D;&#x3D; id</span><br><span class="line">      &#125;)</span><br><span class="line">      return successData || &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    selfFunction()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>突破点：</strong>读取data中的数据文件并且调用封装好的方法。</p><p>@ by 曾晓霞</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、了解mockjs&quot;&gt;&lt;a href=&quot;#一、了解mockjs&quot; class=&quot;headerlink&quot; title=&quot;一、了解mockjs&quot;&gt;&lt;/a&gt;一、了解mockjs&lt;/h3&gt;&lt;p&gt;前言：mockjs是什么&lt;/p&gt;
&lt;p&gt;生成随机数据，拦截 Ajax 请求。&lt;/p&gt;
&lt;p&gt;通过随机数据，模拟各种场景；不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据；支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等；支持支持扩展更多数据类型，支持自定义函数和正则。&lt;/p&gt;
&lt;p&gt;优点是非常简单方便, 无侵入性, 基本覆盖常用的接口数据类型.&lt;/p&gt;
    
    </summary>
    
    
      <category term="mock" scheme="http://yoursite.com/tags/mock/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Kafka常见问题整理</title>
    <link href="http://yoursite.com/2019/01/01/technique-sharing/2019/Kafka%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/01/technique-sharing/2019/Kafka常见问题整理/</id>
    <published>2019-01-01T06:00:00.000Z</published>
    <updated>2020-03-27T02:15:35.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kafka常见问题整理"><a href="#Kafka常见问题整理" class="headerlink" title="Kafka常见问题整理"></a>Kafka常见问题整理</h3><h4 id="1、Kafka如何防止数据丢失"><a href="#1、Kafka如何防止数据丢失" class="headerlink" title="1、Kafka如何防止数据丢失"></a>1、Kafka如何防止数据丢失</h4><p><strong>1）消费端弄丢数据</strong></p><p>​    消费者在消费完消息之后需要执行消费位移的提交，该消费位移表示下一条需要拉取的消息的位置。Kafka默认位移提交方式是自动提交，但它不是在你每消费一次数据之后就提交一次位移，而是每隔5秒将拉取到的每个分区中的最大的消费位移进行提交。自动位移提交在正常情况下不会发生消息丢失或重复消费的现象，唯一可能的情况，你拉取到消息后，消费者那边刚好进行了位移提交，Kafka那边以为你已经消费了这条消息，其实你刚开始准备对这条消息进行业务处理，但你还没处理完，然后因为某些原因，自己挂掉了，当你服务恢复后再去消费，那就是消费下一条消息了，那么这条未处理的消息就相当于丢失了。所以，很多时候并不是说拉取到消息就算消费完成，而是将消息写入数据库或缓存中，或者是更加复杂的业务处理，在这些情况下，所有的业务处理完成才能认为消息被成功消费。Kafka也提供了对位移提交进行手动提交的方式，开启手动提交的前提是消费者客户端参数enable.auto.commit配置为false，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>​    消费者端手动提交方式提供了两种，commitSync()同步提交方式和commitAsync()异步提交方式。commitSync()同步提交方式在调用时Consumer程序会处于阻塞状态，直到远端的broker返回提交结果，这个状态才会结束，这样会对消费者的性能有一定的影响。commitAsync()异步提交方式在执行后会立刻返回，不会被阻塞，但是它也有相应的问题产生，如果异步提交失败后，它虽然也有重试，但是重试提交的位移值可能早已经“过期”或者不是最新的值了，因此异步提交的重试其实没有意义。这里我们可以把同步提交和异步提交相结合，以达到最理想的效果。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">               <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                   <span class="comment">// 处理消息 record</span></span><br><span class="line">               &#125;</span><br><span class="line">               consumer.commitAsync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="comment">// 处理异常</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               consumer.commitSync();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               consumer.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>2)Kafka端弄丢数据</strong></p><p>​    如下图，副本A为leader副本，副本B为follower副本，它们的HW和LEO都为4。</p><p>​    <img src="/images/1571561573874.png" alt=""></p><p>​    此时，A中写入一条消息，它的LEO更新为5，B从A中同步了这条数据，自己的LEO也更新为5</p><p><img src="/images/1571561821171.png" alt=""></p><p>​    之后B再向A发起请求以拉取数据，该FetchRequest请求中带上了B中的LEO信息，A在收到该请求后根据B的LEO值更新了自己的HW为5，A中虽然没有更多的消息，但还是在延时一段时间之后返回FetchRresponse，其中也包含了HW信息，最后B根据返回的HW信息更新自己的HW为5。</p><p><img src="/images/1571562261415.png" alt=""></p><p>​    可以看到整个过程中两者之间的HW同步有一个间隙，B在同步A中的消息之后需要再一轮的FetchRequest/FetchResponse才能更新自身的HW为5。如果在更新HW之前，B宕机了，那么B在重启之后会根据之前HW位置进行日志截断，这样便会将4这条消息截断，然后再向A发送请求拉取消息。此时若A再宕机，那么B就会被选举为新的leader。B恢复之后会成为follower，由于follower副本的HW不能比leader副本的HW高，所以还会做一次日志截断，以此将HW调整为4。这样一来4这条数据就丢失了（就算A不能恢复，这条数据也同样丢失了）。</p><p><img src="/images/1571563944273.png" alt=""></p><p>​    对于这种情况，一般要求起码设置如下4个参数：</p><p>1）给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition必须有至少2个副本</p><p>2）在kafka服务端设置min.insync.replicas参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系，没掉队，这样才能确保leader挂了还有一个follower</p><p>3）在producer端设置acks=all或-1：这个是要求每条数据，必须是写入所有replica之后，才能认为是写成功了</p><p>4）在producer端设置retries为很大的一个值：这个是要求一旦写入失败，就无限重试，它默认为0，即在发生异常之后不进行任何重试。</p><p>​    当然，设置了acks等于all或-1之后，会影响一定的性能。Kafka从0.11.0.0（我们公司现在用的版本为0.10.0.0）开始引入了leader epoch的概念，在需要截断数据的时候使用leader epoch作为参考依据而不是原本的HW。leader epoch代表leader的纪元信息，初始值为0，每当leader变更一次，leader epoch的值就会加1，相当于为leader增设了一个版本号。引入leader epoch很好的解决了前面所说的数据丢失问题，也就不需要去设置acks=all了。</p><p><strong>3）生产者端不会丢失数据</strong></p><p>​    如果你配置了上面场景的参数，就是当数据写入leader副本和所有follower副本成功后才返回响应给生产者，如果写入不成功，生产者会不断重试。</p><h4 id="2、Kafka-怎么防止重复消费"><a href="#2、Kafka-怎么防止重复消费" class="headerlink" title="2、Kafka 怎么防止重复消费"></a>2、Kafka 怎么防止重复消费</h4><p>​    消费者的自动位移提交方式会带来重复消费的问题。假设刚刚提交完一次消费位移，然后拉取一批消息进行消费，在下一次自动位移提交之前，消费者崩了，那么等消费者恢复再来消费消息的时候又得从上一次位移提交的地方重新开始，这样便发生了重复消费的现象。</p><p>​    其实这里可以类似上面消费端丢失数据的情况，很多时候并不是说拉取到消息就算消费完成，而是将消息写入数据库或缓存中，或者是更加复杂的业务处理，重复消费也同样如此，重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。这里防止重复消费，你可以像上面一样把自动提交改为手动提交，或者是保证消息消费的幂等性。</p><p>保证消费消息幂等性</p><p>1）如果你是要插入mysql中，可以对其设置唯一键，插入重复的数据只会插入报错，不会有重复数据产生</p><p>2）如果你是要写入redis中，每次都是set操作，可以保证幂等性</p><p>​    如何保证消息消费是幂等性的，需要结合具体的业务来看。</p><h4 id="3、Kafka为什么这么快？"><a href="#3、Kafka为什么这么快？" class="headerlink" title="3、Kafka为什么这么快？"></a>3、Kafka为什么这么快？</h4><p>1）消息压缩</p><p>​    Kafka在对消息进行压缩，Producer 端压缩、Broker 端保持、Consum进行解压缩。它秉承了用时间去换空间的思想，具体来说就是用CPU时间去换磁盘空间或网络I/O传输量，希望以较小的CPU开销带来更少的磁盘占用或更少的网络I/O传输。Kafka支持多种压缩算法，如GZIP、Snappy 和 LZ4。</p><p>2）数据读写</p><p>​    Kafka会把收到的消息都写入到磁盘中，它绝对不会丢失数据。因为磁盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是最耗时的。所以磁盘最讨厌随机I/O，最喜欢顺序I/O。为了提高读写硬盘的速度，Kafka就是使用顺序I/O。</p><p><img src="/images/1571570013654.png" alt=""></p><p>​    如上图，每个partition在存储层面可以看作一个可追加的日志文件，收到消息后Kafka会把数据顺序写入文件末尾。</p><p>​    即便是顺序写入磁盘，磁盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入磁盘，它充分利用了现代操作系统的页缓存，就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问，来利用内存提高I/O效率。</p><p>​    除了消息顺序追加、页缓存等技术，Kafka还使用了零拷贝（Zero-Copy）技术来进一步提升性能。所谓的零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手，这样大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。</p><h4 id="4、消息队列时间开销最大的在哪儿？"><a href="#4、消息队列时间开销最大的在哪儿？" class="headerlink" title="4、消息队列时间开销最大的在哪儿？"></a>4、消息队列时间开销最大的在哪儿？</h4><p>​    根据上面对Kafka的分析，可以类推作为一个消息中间件所需的时间开销主要在以下两个方面：1）消息读写 2）网络传输</p><h4 id="5、Kafka跟其他消息队列的差异与适应的场景是哪些？"><a href="#5、Kafka跟其他消息队列的差异与适应的场景是哪些？" class="headerlink" title="5、Kafka跟其他消息队列的差异与适应的场景是哪些？"></a>5、Kafka跟其他消息队列的差异与适应的场景是哪些？</h4><p>​    简单介绍下比较常用的消息中间件：</p><p>​    <strong>RabbitMQ</strong>是采用Erlang语言实现的AMQP协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储和转发消息。RabbitMQ发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。</p><p>​    <strong>RocketMQ</strong>是阿里开源的消息中间件，目前已捐献给Apache基金会，它是由Java语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点，经历过“双十一”的洗礼，实力不容小觑。</p><pre><code>从以下几个方面来分析Kafka与其它常用的消息中间件的差异：</code></pre><p><strong>可靠性</strong>：Kafka的ISR机制保证其高可用，一主多从，leader副本挂掉后，可以自动选举新的leader；RocketMQ也支持主从机制保证其高可用，通过设定brokerId=0来设置master，不支持主从切换，master失效以后，从slave中进行消费；RabbitMQ也是支持主从机制保证高可用，master挂掉以后，最早加入集群的slave成为master，支持主从自动切换。</p><p><strong>单机吞吐量：</strong>RabbitMQ单机吞吐量在万级别之内，吞吐量比RocketMQ和Kafka要低了一个数量级；RocketMQ和Kafka单机吞吐量可以维持在十万级别。</p><p><strong>应用场景：</strong>RabbitMQ在金融支付领域使用较多，而在日志处理、大数据等方面Kafka使用居多，而RocketMQ目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景，支撑了阿里多次双十一活动。</p><h4 id="6、Kafka在我们系统中的应用，生产者、消费者分别是什么？groupid是什么，topic是什么？"><a href="#6、Kafka在我们系统中的应用，生产者、消费者分别是什么？groupid是什么，topic是什么？" class="headerlink" title="6、Kafka在我们系统中的应用，生产者、消费者分别是什么？groupid是什么，topic是什么？"></a>6、Kafka在我们系统中的应用，生产者、消费者分别是什么？groupid是什么，topic是什么？</h4><p><img src="/images/1571579017660.png" alt=""></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kafka常见问题整理&quot;&gt;&lt;a href=&quot;#Kafka常见问题整理&quot; class=&quot;headerlink&quot; title=&quot;Kafka常见问题整理&quot;&gt;&lt;/a&gt;Kafka常见问题整理&lt;/h3&gt;&lt;h4 id=&quot;1、Kafka如何防止数据丢失&quot;&gt;&lt;a href=&quot;#1、Kafka如何防止数据丢失&quot; class=&quot;headerlink&quot; title=&quot;1、Kafka如何防止数据丢失&quot;&gt;&lt;/a&gt;1、Kafka如何防止数据丢失&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1）消费端弄丢数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    消费者在消费完消息之后需要执行消费位移的提交，该消费位移表示下一条需要拉取的消息的位置。Kafka默认位移提交方式是自动提交，但它不是在你每消费一次数据之后就提交一次位移，而是每隔5秒将拉取到的每个分区中的最大的消费位移进行提交。自动位移提交在正常情况下不会发生消息丢失或重复消费的现象，唯一可能的情况，你拉取到消息后，消费者那边刚好进行了位移提交，Kafka那边以为你已经消费了这条消息，其实你刚开始准备对这条消息进行业务处理，但你还没处理完，然后因为某些原因，自己挂掉了，当你服务恢复后再去消费，那就是消费下一条消息了，那么这条未处理的消息就相当于丢失了。所以，很多时候并不是说拉取到消息就算消费完成，而是将消息写入数据库或缓存中，或者是更加复杂的业务处理，在这些情况下，所有的业务处理完成才能认为消息被成功消费。Kafka也提供了对位移提交进行手动提交的方式，开启手动提交的前提是消费者客户端参数enable.auto.commit配置为false，&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;​    消费者端手动提交方式提供了两种，commitSync()同步提交方式和commitAsync()异步提交方式。commitSync()同步提交方式在调用时Consumer程序会处于阻塞状态，直到远端的broker返回提交结果，这个状态才会结束，这样会对消费者的性能有一定的影响。commitAsync()异步提交方式在执行后会立刻返回，不会被阻塞，但是它也有相应的问题产生，如果异步提交失败后，它虽然也有重试，但是重试提交的位移值可能早已经“过期”或者不是最新的值了，因此异步提交的重试其实没有意义。这里我们可以把同步提交和异步提交相结合，以达到最理想的效果。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式详解</title>
    <link href="http://yoursite.com/2018/12/03/technique-sharing/2018/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E4%BA%AB-20181203/"/>
    <id>http://yoursite.com/2018/12/03/technique-sharing/2018/正则表达式分享-20181203/</id>
    <published>2018-12-03T03:33:00.000Z</published>
    <updated>2020-03-25T10:24:48.094Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一个非常有用的用来匹配验证字符串的工具。很多人觉得正则表达式规则繁多，学了也会忘记，不如等到需要使用的时候再去查阅即可。这样的观点也无可厚非，不过我曾经看到过一个绝妙的关于阅读的比喻，阅读就像是将竹篓浸入到水里面，虽然捞打上来的时候竹篓里并没有装水，但是竹篓已经被浸湿了。学习正则表达式也是如此，循序渐进，方能厚积薄发。</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>◆ 常用的正则表达式</p><p>◆ 分组捕获与后向引用</p><p>◆ 贪婪模式与非贪婪模式</p><p>◆ 应用场景</p><h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><h3 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h3><table><thead><tr><th>元字符</th><th>释义</th></tr></thead><tbody><tr><td>普通字符</td><td>如A-Z、a-z、0-9 等等</td></tr><tr><td>.</td><td>除换行以外的其他任意字符, 如果需要匹配换行符，可用[.\n]</td></tr><tr><td>\s</td><td>空白字符</td></tr><tr><td>\S</td><td>除空白字符以外的任意字符</td></tr><tr><td>\w</td><td>字母、数字、下划线</td></tr><tr><td>\W</td><td>除了字母、数字、下划线以外的任意字符</td></tr><tr><td>\d</td><td>数字 0-9</td></tr><tr><td>\D</td><td>除了数字之外的任意字符</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置</td></tr><tr><td>\b</td><td>单词边界，匹配一个完整的单词可以使用 \bword\b</td></tr></tbody></table><a id="more"></a><p>以上是最常用的正则表达式匹配字符，当然，还有很多其他的匹配元字符，比如<code>\t</code>匹配制表符，<code>\r</code>匹配回车符，<code>\n</code>匹配换行符等。</p><p>以<code>\d</code>为例，<code>\d</code>代表数字0-9，等价于字符组<code>[0-9]</code></p><blockquote><p>例：匹配字符串 ‘fefafe332gt66ooj44nie85kk’ 中的所有数字</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'fefafe332gt66ooj44nie85kk'</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)) <span class="comment">// 结果未["332", "66", "44", "85"]</span></span><br></pre></td></tr></table></figure><h3 id="2-限定符"><a href="#2-限定符" class="headerlink" title="2.限定符"></a>2.限定符</h3><table><thead><tr><th>限定符</th><th>释义</th></tr></thead><tbody><tr><td>*</td><td>0到无数次。例如，zo* 能匹配 “z” 以及 “zoo”</td></tr><tr><td>+</td><td>1到无数次。例如，zo+ 不能匹配 “z” 但是能匹配 “zo”和“zoo”</td></tr><tr><td>?</td><td>0 或者1 次。例如，zo? 能匹配 “z”和 “zo” 但是不能匹配 “zoo”</td></tr><tr><td>{n}</td><td>匹配确定的N次。 例如， zo{2} 只能匹配到 zoo</td></tr><tr><td>{n,}</td><td>匹配n到无限次。 例如，zo{1,} 不能匹配“z” 但是能匹配“zo”和“zoo”</td></tr><tr><td>{n,m}</td><td>匹配n到m次。注意：在逗号和两个数之间不能有空格</td></tr></tbody></table><p>以上这些限定符，可以匹配指定个数的字符，在能够匹配的范围之内，尽可能多的匹配。其中<code>{n,m}</code>限定符有两个注意点：</p><ol><li>n不能大于m</li><li>在逗号和两个数之间不能有空格，否则无法匹配</li></ol><blockquote><p>例：匹配38到288之间的数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\b((38|39)|([4-9]\d)|(1\d&#123;2&#125;)|(2[0-7]\d)|(28[0-8]))\b/g</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'45 454 255 288 38 88 11 37 100 109 28 000 289 209'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg)) <span class="comment">// ["45", "255", "288", "38", "88", "100", "109", "209"]</span></span><br></pre></td></tr></table></figure><h3 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="3.修饰符"></a>3.修饰符</h3><table><thead><tr><th>修饰符</th><th>释义</th></tr></thead><tbody><tr><td>g</td><td>global 全局搜索 (不添加 搜索到第一个匹配停止)</td></tr><tr><td>i</td><td>ignore case 忽略大小写</td></tr><tr><td>m</td><td>multiline 多行匹配</td></tr></tbody></table><p>m多行匹配用得相对较少，但是也有一定用处。</p><blockquote><p>例：对比m和mg</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str8 = <span class="string">"abeifenabc\nabpheeabc"</span> </span><br><span class="line"><span class="keyword">var</span> reg8a = <span class="regexp">/^ab/gm</span></span><br><span class="line"><span class="keyword">var</span> reg8b = <span class="regexp">/^ab/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str8.match(reg8a)) <span class="comment">// 结果为：["ab", "ab"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str8.match(reg8b)) <span class="comment">// 结果为：["ab"]</span></span><br></pre></td></tr></table></figure><p>上面三个修饰符最常用。当然，还有其他修饰符，比如<code>A</code>表示强制从目标字符串开头匹配,<code>x</code>表示将模式中的空白忽略。</p><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h3><table><thead><tr><th>常用符号</th><th>释义</th></tr></thead><tbody><tr><td>分支符号”|”</td><td>用来匹配指定几个规则中的一个</td></tr><tr><td>转义符号”\“</td><td>用于匹配”[“”^””+””)”等有特殊含义符号</td></tr><tr><td>字符组 []</td><td>用于匹配指定范围之内的任意一个字符</td></tr></tbody></table><p>例如：表达式 <code>[cChH]at</code> 可以只能匹配到 <code>cat</code>、<code>Cat</code>、<code>hat</code>、<code>Hat</code> 四个字符串中的一个</p><blockquote><p>例：敏感词过滤。比如：“我草你妈哈哈背景天胡景涛哪肉涯剪短发欲望”，过滤：’草肉欲胡景涛’</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str9 = <span class="string">'我草你妈哈哈背景天胡景涛哪肉涯剪短发欲望'</span>;</span><br><span class="line"><span class="keyword">let</span> regExp = <span class="regexp">/草|肉|欲|胡景涛/g</span>;</span><br><span class="line"><span class="keyword">let</span> result = str9.replace(regExp, <span class="function"><span class="keyword">function</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = match.length;</span><br><span class="line">    <span class="keyword">let</span> str;</span><br><span class="line">    <span class="keyword">switch</span> (len) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            str = <span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            str = <span class="string">"**"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            str = <span class="string">"***"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            str = <span class="string">'****'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//我*你妈哈哈背景天***哪*涯剪短发*望</span></span><br></pre></td></tr></table></figure><h2 id="分组捕获与后向引用"><a href="#分组捕获与后向引用" class="headerlink" title="分组捕获与后向引用"></a>分组捕获与后向引用</h2><h3 id="1-分组捕获"><a href="#1-分组捕获" class="headerlink" title="1.分组捕获"></a>1.分组捕获</h3><p>当我们想要匹配多个字符的时候，可以使用限定符来指定个数，那当我们需要匹配多个字符串的情况，该怎么办呢？可以使用<strong>分组捕获</strong>。</p><ul><li>概念：</li></ul><p>分组捕获是指将想要匹配的正则表达式用小括号括起来，然后与限定符组合使用，可以连续匹配符合规则的字符串。每一个小括号代表的表达式分为一组，作为子表达式，后期可以通过捕获不同组的内容来进行替换等操作。</p><blockquote><p>例：匹配字符串isuwang连续出现3次的情况</p></blockquote><p><em>isuwang{3}</em>  <img src="/image/isuwang1.png" alt="isuwang1" title="非分组捕获"></p><p><em>(isuwang){3}</em>  <img src="/image/isuwang2.png" alt="isuwang2" title="分组捕获"></p><p>可以看到，下面一组例子将isuwang字符串当作一个组，整体匹配了3次。</p><h3 id="2-非捕获分组"><a href="#2-非捕获分组" class="headerlink" title="2.非捕获分组"></a>2.非捕获分组</h3><ul><li>分组捕获的缺点：</li></ul><p>有些不得不用（）但是后期又不会用到的子表达式内容，记录在组里面会占用内存，降低匹配效率</p><ul><li>解决：</li></ul><p>使用非捕获组。只进行分组，并不将子表达式匹配到的内容捕获到组里。</p><table><thead><tr><th>字符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>(?:pattern)</td><td>匹配pattern，但不捕获匹配结果。</td><td>‘industr(?:y|ies)匹配’industry’或’industries’</td></tr><tr><td>(?=pattern)</td><td>零宽度正向预查，不捕获匹配结果。</td><td>‘Windows (?=95|98|NT|2000)’匹配 “Windows2000” 中的 “Windows”,不匹配 “Windows3.1” 中的 “Windows”。</td></tr><tr><td>(?!pattern)</td><td>零宽度负向预查，不捕获匹配结果。</td><td>‘Windows (?!95|98|NT|2000)’匹配 “Windows3.1” 中的 “Windows”不匹配 “Windows2000” 中的 “Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>零宽度正向回查，不捕获匹配结果。</td><td>‘2000 (?&lt;=Office|Word|Excel)’匹配 “ Office2000” 中的 “2000”,不匹配 “Windows2000” 中的 “2000”。</td></tr><tr><td>(?&lt;!pattern)</td><td>零宽度负向回查，不捕获匹配结果。</td><td>‘2000 (?&lt;!Office|Word|Excel)’匹配 “ Windows2000” 中的 “2000”,不匹配 “ Office2000” 中的 “2000”。</td></tr></tbody></table><ul><li>使用情况：</li></ul><p>一般只有在比较复杂，“（）”使用较多的情况下会考虑使用非捕获组。比如验证日期的正则表达式。</p><ul><li>对比：</li></ul><p><strong>未使用非捕获组的正则</strong></p><blockquote><p><code>^((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)$</code></p></blockquote><p><strong>使用了非捕获组的正则：</strong></p><blockquote><p><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></p></blockquote><h3 id="3-后向引用"><a href="#3-后向引用" class="headerlink" title="3.后向引用"></a>3.后向引用</h3><ul><li>作用：</li></ul><p>后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code> 代表分组1匹配的文本，也可以用<code>$1</code>来表示</p><ul><li>说明：</li></ul><p>子分组捕获的内容可在正则表达式里面或者其他文本里面作进一步的处理。默认情况下，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。也可以使用命名分组的方式，对每个分组进行命名。</p><blockquote><p>例：检查重复字符串<br>给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回false</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str4 = <span class="string">'abccdefgjhiss'</span></span><br><span class="line"><span class="keyword">let</span> reg4a = <span class="regexp">/([a-zA-Z])\1/g</span></span><br><span class="line"><span class="keyword">let</span> reg4b = <span class="regexp">/([a-zA-Z])&#123;2&#125;/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str4.match(reg4a)) <span class="comment">// ["cc", "ss"]</span></span><br><span class="line"><span class="built_in">console</span>.log(str4.match(reg4b)) <span class="comment">// ["ab", "cc", "de", "fg", "jh", "is"]</span></span><br></pre></td></tr></table></figure><h3 id="4-贪婪模式和非贪婪模式"><a href="#4-贪婪模式和非贪婪模式" class="headerlink" title="4.贪婪模式和非贪婪模式"></a>4.贪婪模式和非贪婪模式</h3><ul><li><strong>贪婪模式：</strong></li></ul><p>在整个表达式匹配成功的前提下，尽可能多的匹配</p><ul><li><strong>非贪婪模式：</strong></li></ul><p>整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。</p><ul><li><strong>量词：</strong></li></ul><table><thead><tr><th>贪婪模式</th><th>非贪婪模式</th></tr></thead><tbody><tr><td>{m,n}</td><td>{m,n}?</td></tr><tr><td>{m,}</td><td>{m,}?</td></tr><tr><td>?</td><td>??</td></tr><tr><td>*</td><td>*？</td></tr><tr><td>+</td><td>+？</td></tr></tbody></table><blockquote><p>例子：<br>提取两个””中的子串，其中不能再包含””<br>字符串：”The colleagues in “kuaisuwang” are very “diligent” and united”</p></blockquote><p>错误解法（通过非贪婪匹配）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str6=<span class="string">'"The colleagues in "isuwang" are very "diligent" and united"'</span></span><br><span class="line"><span class="keyword">let</span> reg6a=<span class="regexp">/".*?" /g</span> <span class="comment">// 注意"后面还有个空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str6.match(reg6a)) <span class="comment">//  [""The colleagues in "isuwang" ", ""diligent" "]</span></span><br></pre></td></tr></table></figure><p>正确解法（通过贪婪模式匹配）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str6=<span class="string">'"The colleagues in "isuwang" are very "diligent" and united"'</span></span><br><span class="line"><span class="keyword">let</span> reg6b=<span class="regexp">/"[^"]*" /g</span> <span class="comment">// 注意"后面还有个空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str6.match(reg6b)) <span class="comment">//[""isuwang" ", ""diligent" "]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此篇文章主要讲述了常用的正则表达式符号，以及分组和后向引用，贪婪模式和非贪婪模式两种模式，这些知识点呢，在工作当中会非常有用。</p><p>@by 吴丽娅</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式是一个非常有用的用来匹配验证字符串的工具。很多人觉得正则表达式规则繁多，学了也会忘记，不如等到需要使用的时候再去查阅即可。这样的观点也无可厚非，不过我曾经看到过一个绝妙的关于阅读的比喻，阅读就像是将竹篓浸入到水里面，虽然捞打上来的时候竹篓里并没有装水，但是竹篓已经被浸湿了。学习正则表达式也是如此，循序渐进，方能厚积薄发。&lt;/p&gt;
&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;p&gt;◆ 常用的正则表达式&lt;/p&gt;
&lt;p&gt;◆ 分组捕获与后向引用&lt;/p&gt;
&lt;p&gt;◆ 贪婪模式与非贪婪模式&lt;/p&gt;
&lt;p&gt;◆ 应用场景&lt;/p&gt;
&lt;h2 id=&quot;常用的正则表达式&quot;&gt;&lt;a href=&quot;#常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;常用的正则表达式&quot;&gt;&lt;/a&gt;常用的正则表达式&lt;/h2&gt;&lt;h3 id=&quot;1-元字符&quot;&gt;&lt;a href=&quot;#1-元字符&quot; class=&quot;headerlink&quot; title=&quot;1.元字符&quot;&gt;&lt;/a&gt;1.元字符&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;释义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;普通字符&lt;/td&gt;
&lt;td&gt;如A-Z、a-z、0-9 等等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;除换行以外的其他任意字符, 如果需要匹配换行符，可用[.\n]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;空白字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;除空白字符以外的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;字母、数字、下划线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;除了字母、数字、下划线以外的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;数字 0-9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;除了数字之外的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配输入字符串开始的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配输入字符串结尾的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;单词边界，匹配一个完整的单词可以使用 \bword\b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="正则表达式" scheme="http://yoursite.com/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
